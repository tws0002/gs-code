//CopyRight Dustin Nelson 2010-2016. Please do not distribute
//http://www.creativecrash.com/maya/script/-rapid-rig-modular-procedural-auto-rig-for-maya
//Script for Modular Character Rigging.
//VERSION 2.0.1
//July 25, 2016
//FILE IS NOT INTENDED TO BE HARMFUL, HOWEVER USE AT YOUR OWN RISK
/*/////////////////////////////////////////////////////////////////////////////
// 
//	INSTRUCTIONS:
//	1. INSTALLATION
//	TYPE IN THE FOLLOWING COMMAND IN MAYA TO GET YOUR SCRIPT DIRECTORY:
//
//	internalVar -userScriptDir;
//
//	2. PUT THE RapidRig_Modular_V2.mel FILE IN THAT DIRECTORY.
//
//	3. START UP MAYA, ENTER THE FOLLOWING COMMAND INTO
//	THE COMMAND LINE OR THE SCRIPT EDITOR:
//
//	RapidRig_Modular_V2;
//
//	4. TO HAVE EASY ACCESS TO SCRIPT, CREATE A SHELF BUTTON    
//	WITH ONLY THAT COMMAND. EVERY TIME YOU HIT THE BUTTON,    
//	THE RAPID RIG INTERFACE WILL POP UP. HAPPY ANIMATING!    
//                  
////////////////////////////////////////////////////////////////////////*/
global proc int RRM_CheckName(string $validate)
{
	string $nameMatch = `match "^[a-zA-Z][0-9a-zA-Z_]*$" $validate`;
	int $goodMatch = ! `strcmp $nameMatch $validate`;
	
	return $goodMatch;
}

global proc RRM_CreateProxyModuleProxy(string $crntUnit, string $proxyName)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	
	//CREATE PROXY BASE
	circle -n $proxyName -nr 0 1 0 -r 0.25 -ch 0;
	duplicate -rr -n ($proxyName + "_2");
	rotate 90 0 0 ($proxyName + "_2");
	makeIdentity -apply true -t 1 -r 1 -s 1 ($proxyName + "_2");
	duplicate -rr -n ($proxyName + "_3");
	rotate 0 90 0 ($proxyName + "_3"); 
	makeIdentity -apply true -t 1 -r 1 -s 1 ($proxyName + "_3");
	
	spaceLocator -n ($proxyName + "_4");
	setAttr (($proxyName + "_4Shape.localScale"), 0.25, 0.25, 0.25);
	if ($crntUnit == "m")
	{
		setAttr (($proxyName + "_4Shape.localScale"), 0.0025, 0.0025, 0.0025);
	}
		
	parent -r -s ($proxyName + "_2Shape") ($proxyName + "_3Shape") ($proxyName + "_4Shape") $proxyName;
	delete ($proxyName + "_2") ($proxyName + "_3") ($proxyName + "_4");
	makeIdentity -apply true -t 1 -r 1 -s 1 $proxyName;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" $proxyName;
	setAttr -e -k 1 ($proxyName + ".core");
	
	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" $proxyName;
	setAttr -e -k 1 ($proxyName + ".ext");

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" $proxyName;
	setAttr -e -k 1 ($proxyName + ".clone");

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" $proxyName;
	setAttr -e -k 1 ($proxyName + ".modName");
	
	setAttr -l 1 -k 0 ($proxyName + ".v");

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}
global proc RRM_CreateProxySplineModuleProxy(string $crntUnit, string $proxyName)
{
	RRM_CreateProxyModuleProxy($crntUnit, $proxyName);

	circle -n ($proxyName + "_5") -nr 0 0 1 -r 0.605 -sw 90 -ch 0;
	move -r -os 0.605 0.605 0 ($proxyName + "_5");
	rotate -r 0 0 90 ($proxyName + "_5");
	
	circle -n ($proxyName + "_6") -nr 0 0 1 -r 0.605 -sw 90 -ch 0;
	move -r -os -0.605 0.605 0 ($proxyName + "_6");
	rotate -r 0 0 180 ($proxyName + "_6");
	
	circle -n ($proxyName + "_7") -nr 1 0 0 -r 0.605 -sw 45 -ch 0;
	move -r -os 0 0.605 -0.605 ($proxyName + "_7");
	rotate -r 45 0 180 ($proxyName + "_7");
		
 circle -n ($proxyName + "_8") -nr 0 1 0 -r 0.605 -sw 45 -ch 0;
	move -r -os 0.605 0 -0.605 ($proxyName + "_8");
	rotate -r 0 135 0 ($proxyName + "_8");
	
 circle -n ($proxyName + "_9") -nr 0 1 0 -r 0.605 -sw 45 -ch 0;
	move -r -os -0.605 0 -0.605 ($proxyName + "_9");
	rotate -r 0 180 0 ($proxyName + "_9");
	
	curve -n ($proxyName + "_10") -d 1 -p -0.605 0 0 -p 0.605 0 0 -k 0 -k 1 ;
	rename `listRelatives -c ($proxyName + "_10")` ($proxyName + "_10Shape");
	
	makeIdentity -apply true -t 1 -r 1 ($proxyName + "_5") ($proxyName + "_6") ($proxyName + "_7") ($proxyName + "_8") ($proxyName + "_9") ($proxyName + "_10");

	parent -r -s ($proxyName + "_5Shape") ($proxyName + "_6Shape") ($proxyName + "_7Shape") ($proxyName + "_8Shape") ($proxyName + "_9Shape") ($proxyName + "_10Shape") $proxyName;
	delete ($proxyName + "_5") ($proxyName + "_6") ($proxyName + "_7") ($proxyName + "_8") ($proxyName + "_9") ($proxyName + "_10");
}

global proc RRM_CreateProxyBaseUpProxy(string $crntUnit, string $proxyName)
{
	////SET UNITS TO CENTIMETERS
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	RRM_CreateProxyModuleProxy($crntUnit, $proxyName);
	
	curve -n ($proxyName + "_5") -d 1 -p 0 -0.25 0 -p 0 0.85 0 -k 0 -k 1 ;
	rename `listRelatives -c ($proxyName + "_5")` ($proxyName + "_5Shape");
	curve -n ($proxyName + "_6") -d 1 -p 0 0.675 0.175 -p 0 0.85 0 -p 0 0.675 -0.175 -k 0 -k 1 -k 2 ;
	rename `listRelatives -c ($proxyName + "_6")` ($proxyName + "_6Shape");
	curve -n ($proxyName + "_7") -d 1 -p -0.175 0.675 0 -p 0 0.85 0 -p 0.175 0.675 0 -k 0 -k 1 -k 2 ;
	rename `listRelatives -c ($proxyName + "_7")` ($proxyName + "_7Shape");
	circle -n ($proxyName + "_8") -c 0 0.675 0 -nr 0 1 0 -r 0.175 -ch 0;

	parent -r -s ($proxyName + "_5Shape") ($proxyName + "_6Shape") ($proxyName + "_7Shape") ($proxyName + "_8Shape") $proxyName;
	delete ($proxyName + "_5") ($proxyName + "_6") ($proxyName + "_7") ($proxyName + "_8");
}

global proc RRM_CreateProxyRootProxy(string $crntUnit, string $proxyName)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
		
	//CREATE PROXY BASE
	RRM_CreateProxyModuleProxy($crntUnit, $proxyName);
	
	curve -n ($proxyName + "_5") -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5
	-p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	rename `listRelatives -c ($proxyName + "_5")` ($proxyName + "_5Shape");
	parent -r -s ($proxyName + "_5Shape") $proxyName;
	delete ($proxyName + "_5");
	makeIdentity -apply true -t 1 -r 1 -s 1 $proxyName;

	setAttr -l 1 -k 0 ($proxyName + ".v");
}

global proc RRM_CreateProxyCOG_C(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	
	circle -n RRM_OuterCOG_Ctrl -r 6 -nr 0 1 0 -ch 0;
	circle -n RRM_InnerCOG_Ctrl -r 3 -nr 0 1 0 -ch 0;
	rotate -r -os 0 -18 0 RRM_InnerCOG_Ctrl;
	curve -n RRM_XConnectorCOG_Ctrl -d 1 -p 6 0 0 -p -6 0 0 -k 0 -k 1 ;
	rename `listRelatives -c RRM_XConnectorCOG_Ctrl` RRM_XConnectorCOG_CtrlShape;
	curve -n RRM_YConnectorCOG_Ctrl -d 1 -p 0 0 -6 -p 0 0 6 -k 0 -k 1 ;
	rename `listRelatives -c RRM_YConnectorCOG_Ctrl` RRM_YConnectorCOG_CtrlShape;
	
	$transforms = `ls RRM_InnerCOG_Ctrl RRM_XConnectorCOG_Ctrl RRM_YConnectorCOG_Ctrl`;
	//pickWalk -d down;
	$curves = `listRelatives -c $transforms`;
	parent -r -s $curves RRM_OuterCOG_Ctrl;
	delete $transforms;
	rename RRM_OuterCOG_Ctrl RRM_COG;
	
	setAttr -l 1 -k 0 "RRM_COG.v";

	setAttr -l 1 -k 0 "RRM_COG.v";
}


global proc RRM_CreateProxyParentProxy(string $crntUnit, string $crntSide, string $proxyName)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
		
	//CREATE PROXY PARENT
	curve -n $proxyName -d 1 -p 0.5 1 0.5 -p 0.5 1 -0.5 -p -0.5 1 -0.5 -p -0.5 1 0.5 -p -0.5 0.1 0.5 -p 0.5 0.1 0.5 -p 0.5 1 0.5 -p -0.5 1 0.5
	-p -0.5 1 -0.5 -p -0.5 0.1 -0.5 -p 0.5 0.1 -0.5 -p 0.5 1 -0.5 -p 0.5 1 0.5 -p 0.5 0.1 0.5 -p 0.5 0.1 -0.5 -p -0.5 0.1 -0.5 -p -0.5 0.1 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	rename `listRelatives -c ($proxyName)` ($proxyName + "Shape");
	scale -r 0.8 1.25 0.8 ($proxyName);
	makeIdentity -apply true -s 1 ($proxyName);
	
	curve -n ($proxyName + "_1") -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5
	-p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	rename `listRelatives -c ($proxyName + "_1")` ($proxyName + "_1Shape");
	scale -r 0.25 0.75 0.25 ($proxyName);
	scale -r 0.5 0.5 0.5 ($proxyName + "_1");
	makeIdentity -apply true -t 1 -r 1 -s 1 $proxyName ($proxyName + "_1");		

	spaceLocator -n ($proxyName + "C");
	setAttr (($proxyName + "CShape.localScale"), .25, .25, .25);
	if ($crntUnit == "m")
	{
		setAttr (($proxyName + "CShape.localScale"), 0.0025, 0.0025, 0.0025);
	}
	
	parent -r -s ($proxyName + "_1Shape") ($proxyName + "CShape") ($proxyName);
	delete ($proxyName + "_1") ($proxyName + "C");
	makeIdentity -apply true -t 1 -r 1 -s 1 ($proxyName);

	//ADD PARENT ATTRIBUTE
	addAttr -ln "parent" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".parent");

	addAttr -ln "attachNode" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".attachNode");
	
	if ($crntSide == "right")
	{
		//ADD MIRROR BEHAVIOR ATTRIBUTE
		addAttr -ln "mirrorType" -at "enum" -en "Behavior:Orientation:" ($proxyName);
		setAttr -e -k 1 ($proxyName + ".mirrorType");
	}

	//ADD PINNED ATTRIBUTE
	addAttr -ln "pinned" -at bool ($proxyName);
	setAttr -e -k 1 ($proxyName + ".pinned");
	setAttr ($proxyName + ".pinned") 0;
	setAttr -l 1 ($proxyName + ".pinned");
	
	//ADD CONNECTOR VIZ ATTRIBUTE
	addAttr -ln "connectors" -at bool ($proxyName);
	setAttr -e -k 1 ($proxyName + ".connectors");
	setAttr ($proxyName + ".connectors") 1;
	
	//SET SO CAN'T ATTACH TO PARENT OBJECT
	addAttr -ln "noAttach" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".noAttach");
	

	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".core");

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".ext");

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".clone");

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" ($proxyName);
	setAttr -e -k 1 ($proxyName + ".modName");

	setAttr -l 1 -k 0 ($proxyName + ".v");

}

global proc RRM_CreateProxyEndProxy(string $crntUnit, string $proxyName)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
		
	RRM_CreateProxyModuleProxy($crntUnit, $proxyName);

	//CREATE PROXY END
	curve -n ($proxyName + "_5") -d 1 -p 0.375 -0.25 -0.375 -p 0 0.5 0 -p 0.375 -0.25 0.375 -p 0.375 -0.25 -0.375 -p -0.375 -0.25 -0.375 -p 0 0.5 0 -p -0.375 -0.25 0.375
	-p -0.375 -0.25 -0.375 -p -0.375 -0.25 0.375 -p 0.375 -0.25 0.375 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 ;
	rename `listRelatives -c ($proxyName + "_5")` ($proxyName + "_5Shape");
	
	parent -r -s ($proxyName + "_5Shape") $proxyName;
	delete ($proxyName + "_5");
}


global proc RRM_ProxyLockNodes(string $modNodes[])
{
	lockNode $modNodes;
}

global proc RRM_ProxyLimits(string $xforms[])
{
	for ($each in $xforms)
	{
		transformLimits -sx 0.01 1 -esx 1 0 $each;
		transformLimits -sy 0.01 1 -esy 1 0 $each;
		transformLimits -sz 0.01 1 -esz 1 0 $each;
	}
}
	

global proc RRM_ProxyConnectors(string $modName, string $prfx, string $node1, string $node2)
{
	//$selection = `ls -sl`;
	$node1Loc = `xform -q -ws -rp $node1`;
	$node2Loc = `xform -q -ws -rp $node2`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	if ($prfx == $rPrfx)
	{
		if (`objExists ($node1 + ".pair")`&&`objExists ($node2 + ".parent")`)
		{
			$rightAttachPoint = `getAttr ($node1 + ".opposite")`;
			$node1 = ("RRM_" + $rightAttachPoint);
			$node1Loc = `xform -q -ws -rp $node1`;
		}
		else if (`objExists ($node1 + ".pair")`&&`objExists ($node2 + ".modType")`)
		{
			$rightAttachPoint = `getAttr ($node1 + ".opposite")`;
			$node1 = ("RRM_" + $rightAttachPoint);
			$node1Loc = `xform -q -ws -rp $node1`;
		}
		
	}
	
	
	//NEW
	curve -n ($node1 + "_" + $node2 + "Connector") -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 ;
	rename `listRelatives ($node1 + "_" + $node2 + "Connector")` ($node1 + "_" + $node2 + "ConnectorShape");
	spaceLocator -n ($node1 + "_" + $node2 + "_AimLctr");
	spaceLocator -n ($node1 + "_" + $node2 + "_TargetLctr");
	parent ($node1 + "_" + $node2 + "_TargetLctr") ($node1 + "_" + $node2 + "_AimLctr");
	pointConstraint $node1 ($node1 + "_" + $node2 + "_AimLctr");
	aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $node2 ($node1 + "_" + $node2 + "_AimLctr");
	pointConstraint $node2 ($node1 + "_" + $node2 + "_TargetLctr");
	connectAttr -f ($node1 + "_" + $node2 + "_AimLctr.translate") ($node1 + "_" + $node2 + "Connector.translate");
	connectAttr -f ($node1 + "_" + $node2 + "_AimLctr.rotate") ($node1 + "_" + $node2 + "Connector.rotate");
	connectAttr -f ($node1 + "_" + $node2 + "_TargetLctr.tx") ($node1 + "_" + $node2 + "Connector.sx");
	setAttr ($node1 + "_" + $node2 + "_AimLctr.v") 0;
	
	//ONLY TEMPLATE IF IT IS NOT A PARENT NODE
	if (!`objExists ($node2 + ".parent")` && !`objExists ($node2 + ".modType")`)
	{
		setAttr ($node1 + "_" + $node2 + "Connector.template") 1;
	}
	else
	{
		setAttr ($node1 + "_" + $node2 + "Connector.overrideEnabled") 1;
		setAttr ($node1 + "_" + $node2 + "Connector.overrideColor") 6;
	}
	
	if (!`objExists ("RRM_" + $prfx + $modName + "_ConnectorGrp")`)
	{
		group -em -n ("RRM_" + $prfx + $modName + "_ConnectorGrp"); xform -os -piv 0 0 0;
		setAttr ("RRM_" + $prfx + $modName + "_ConnectorGrp.inheritsTransform") 0;
		parent ("RRM_" + $prfx + $modName + "_ConnectorGrp") ("RRM_" + $prfx + $modName);
		
		if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
		{
			connectAttr -f ("RRM_" + $prfx + $modName + "_Parent.connectors") ("RRM_" + $prfx + $modName + "_ConnectorGrp.v");
		}
		else
		{
			connectAttr -f ("RRM_" + $prfx + $modName + "_Aux.connectors") ("RRM_" + $prfx + $modName + "_ConnectorGrp.v");
		}
	}
	parent ($node1 + "_" + $node2 + "Connector") ($node1 + "_" + $node2 + "_AimLctr") ("RRM_" + $prfx + $modName + "_ConnectorGrp");
	setAttr (($node1 + "_" + $node2 + "_AimLctr.scale"), 1,1,1);
	
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.tx");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.ty");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.tz");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.rx");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.ry");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.rz");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.sx");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.sy");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.sz");
	setAttr -l 1 -k 0 ($node1 + "_" + $node2 + "Connector.v");	
	
	
	$modNodes = `ls -sl`;
	RRM_ProxyLockNodes($modNodes);
	//select $selection;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;	
}
	

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////MAIN & ROOT/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_PrefixPrompt(int $checkTemplate)
{
	if (`objExists "RRM_MAIN"`)
	{
		string $selectControl = `confirmDialog
			-title "A Proxy Rig Already Exists In This Scene"
			-message "You must either delete the existing Proxy rig before creating a new Proxy rig."
			-button "OK"
			-defaultButton "OK"
			-icon "information"`;
	}
	else
	{
		if (`window -exists RRM_PrefixPromptWindow`)
		{
			deleteUI RRM_PrefixPromptWindow;
		}
		window -title "Set Left and Right Prefixes" RRM_PrefixPromptWindow;
		
		// Get the dialog's formLayout.
		string $form = `formLayout -numberOfDivisions 100`;

		formLayout -e -width 300 $form;

		$directions = `text -l "Define left and right prefixes for each side of your rig."`;
		
		$intField = `intField -vis 0 -v $checkTemplate RRM_intField`;
		$lPrfxLabel = `text -l "Left Prefix:"`;
		$rPrfxLabel = `text -l "Right Prefix:"`;
		string $lPrfx = `textField -text "l_" -w 80 RRM_lPrfxTextField`;
		string $rPrfx = `textField -text "r_" -w 80 RRM_rPrfxTextField`;
		button -label "Set Prefixes" -w 142
		-c "RRM_CreateProxyMainProxy(`intField -q -v RRM_intField`, `textField -q -text RRM_lPrfxTextField`,\
		`textField -q -text RRM_rPrfxTextField`); deleteUI RRM_PrefixPromptWindow;" RRM_prfxOkButton;

		button -label "Cancel" -w 142 -c "deleteUI RRM_PrefixPromptWindow" RRM_prfxCancelButton;
		

		int $spacer = 10;
		int $top = 5;
		int $edge = 5;

		formLayout -edit
			-attachForm				$directions "top" $top
			-attachForm				$directions "left" ($edge = 10)
			
			-attachControl 			$lPrfxLabel "top" $spacer $directions
			-attachForm 			$lPrfxLabel "left" $edge
			
			-attachControl 			$lPrfx "top" ($spacer -1) $directions
			-attachForm 			$lPrfx "left" 85

			-attachControl 			$rPrfxLabel "top" $spacer $lPrfxLabel
			-attachForm 			$rPrfxLabel "left" $edge
			
			-attachControl 			$rPrfx "top" ($spacer -1) $lPrfxLabel
			-attachForm 			$rPrfx "left" 85
			
			-attachControl 			RRM_prfxOkButton "top" $spacer $rPrfxLabel
			-attachForm 			RRM_prfxOkButton "left" 4
			
			-attachControl 			RRM_prfxCancelButton "top" $spacer $rPrfxLabel
			-attachForm 			RRM_prfxCancelButton "left" 154
			
			//-attachControl 			$prfxOK "top" $spacer $rPrfxLabel
			//-attachForm 			$prfxOK "left" 4
			//
			//-attachControl 			$prfxCancel "top" $spacer $rPrfxLabel
			//-attachForm 			$prfxCancel "left" 154

			$form;
			showWindow RRM_PrefixPromptWindow;
	}
}

global proc RRM_CreateProxyMainProxy(int $checkTemplate, string $lPrfx, string $rPrfx)
{
	//print $lPrfx;
	//print $rPrfx;
	
	if (`objExists "RRM_MAIN"`)
	{
		string $selectControl = `confirmDialog
			-title "A Proxy Rig Already Exists In This Scene"
			-message "You must either delete the existing Proxy rig or RRM_Generate a final rig before creating a new Proxy rig."
			-button "OK"
			-defaultButton "OK"
			-icon "information"`;
	}
	else
	{
		//SET UNITS TO CENTIMETERS
		string $crntUnit = `currentUnit -query -linear`;

		//if ($crntUnit != "cm")
		//{
		//	//changeLinearUnit "centimeter"
		//}
		
		curve -n RRM_MAIN -d 1 -p 0 0 11 -p 2 0 9 -p 2 0 7 -p 7 0 7 -p 7 0 2 -p 9 0 2 -p 10 0 0 -p 9 0 -2 -p 7 0 -2 -p 7 0 -7 -p 2 0 -7 -p 2 0 -9 -p 0 0 -10 -p -2 0 -9 -p -2 0 -7 -p -7 0 -7 -p -7 0 -2 -p -9 0 -2 -p -10 0 0 -p -9 0 2 -p -7 0 2 -p -7 0 7 -p -2 0 7 -p -2 0 9 -p 0 0 11 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 ;
		rename `listRelatives -c RRM_MAIN` RRM_MAINShape;
		
		curve -n RRM_MAIN2 -d 1 -p 6.5 0 6.5 -p 6.5 0 -6.5 -p -6.5 0 -6.5 -p -6.5 0 6.5 -p 6.5 0 6.5 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c RRM_MAIN2` RRM_MAIN2Shape;
		parent -r -s RRM_MAIN2Shape RRM_MAIN;
		delete RRM_MAIN2;
		
		setAttr -l 1 -k 0 "RRM_MAIN.translate";
		setAttr -l 1 -k 0 "RRM_MAIN.rotate";
		setAttr -l 1 -k 0 "RRM_MAIN.v";
		
		transformLimits -sx 0.01 1 -esx 1 0 RRM_MAIN;
		transformLimits -sy 0.01 1 -esy 1 0 RRM_MAIN;
		transformLimits -sz 0.01 1 -esz 1 0 RRM_MAIN;
		
		RRM_CreateProxyRootProxy($crntUnit, "RRM_ROOT");
		
		transformLimits -sx 0.01 1 -esx 1 0 RRM_ROOT;
		transformLimits -sy 0.01 1 -esy 1 0 RRM_ROOT;
		transformLimits -sz 0.01 1 -esz 1 0 RRM_ROOT;

		setAttr -l 1 -k 0 "RRM_ROOT.v";
		
		setAttr "RRM_ROOT.overrideEnabled" 1;
		setAttr "RRM_ROOT.overrideColor" 17;
		
		parent RRM_ROOT RRM_MAIN;
		
		addAttr -ln "core" -dt "string" RRM_MAIN;
		setAttr -e -k 1 RRM_MAIN.core;
		setAttr -type "string" RRM_MAIN.core "MAIN";
		setAttr -l true "RRM_MAIN.core";	

		addAttr -ln "lPrfx" -dt "string" RRM_MAIN;
		setAttr -e -k 1 RRM_MAIN.lPrfx;
		setAttr -type "string" RRM_MAIN.lPrfx $lPrfx;
		setAttr -l true "RRM_MAIN.lPrfx";	

		addAttr -ln "rPrfx" -dt "string" RRM_MAIN;
		setAttr -e -k 1 RRM_MAIN.rPrfx;
		setAttr -type "string" RRM_MAIN.rPrfx $rPrfx;
		setAttr -l true "RRM_MAIN.rPrfx";

		
		setAttr -type "string" RRM_ROOT.core "ROOT";
		setAttr -l true "RRM_ROOT.core";
		
		RRM_CreateProxyCOG_C($crntUnit);
		//ADD CORE ATTRIBUTE
		addAttr -ln "core" -dt "string" RRM_COG;
		setAttr -e -k 1 RRM_COG.core;
		
		//ADD EXT ATTRIBUTE
		addAttr -ln "ext" -dt "string" RRM_COG;
		setAttr -e -k 1 RRM_COG.ext;
	
		//ADD CLONE ATTRIBUTE
		addAttr -ln "clone" -dt "string" RRM_COG;
		setAttr -e -k 1 RRM_COG.clone;
	
		//ADD MODNAME ATTRIBUTE
		addAttr -ln "modName" -dt "string" RRM_COG;
		setAttr -e -k 1 RRM_COG.modName;

		setAttr -type "string" RRM_COG.core "COG_Ctrl";
		setAttr -l true "RRM_COG.core";

		parent RRM_COG RRM_ROOT;
		
		addAttr -ln "twistAxis" -at "enum" -en "X-axis:Y-axis:" "RRM_ROOT";
		setAttr -e -k 1 "RRM_ROOT.twistAxis";
		setAttr "RRM_ROOT.twistAxis" 1;
		
		addAttr -ln "template_COG_Ctrl" -at bool RRM_ROOT;
		setAttr -e -k 1 RRM_ROOT.template_COG_Ctrl;
		setAttr RRM_ROOT.template_COG_Ctrl 1;
		connectAttr -f RRM_ROOT.template_COG_Ctrl RRM_COG.template;	
		
		setAttr -l 1 -k 0 RRM_ROOT.v;
		
		
		//LAYER
		if (!`objExists RRM_ProxiesLayer`)
		{
			select RRM_MAIN;
			createDisplayLayer -n RRM_ProxiesLayer -number 1 -nr;
		}
		
		//PRESETS
		if ($checkTemplate == 1)
		{
			$RRM_TemplateType = `optionMenu -q -sl RRM_TemplateType`;
			if ($RRM_TemplateType == 1)
			{//HUMAN BIPED
				move -r -os -wd 0 16 0 RRM_ROOT;
				select RRM_ROOT;
				RRM_CreateProxySpline("Spine", 4, 2, 0, $lPrfx, $rPrfx);
				move -r -os -wd 0 4 0 RRM_Spine_Top;
				//ARMS
				select RRM_Spine_Top;
				RRM_CreateProxyArm("Arm", 0, 0, 0, 1, 1, 2, $lPrfx, $rPrfx);
				//HANDS
				select ("RRM_" + $lPrfx + "Arm_Wrist");
				RRM_CreateProxyFkChain("Finger", 4, 4, 1, 0, 1, 1, $lPrfx, $rPrfx);
				select ("RRM_" + $lPrfx + "Arm_Wrist");
				RRM_CreateProxyFkChain("Thumb", 1, 4, 3, 0, 1, 1, $lPrfx, $rPrfx);
				move -r -os -wd -2 0 -1 ("RRM_" + $lPrfx + "Thumb_01_01");
				move -r -os -wd -2 0 1 ("RRM_" + $rPrfx + "Thumb_01_01");
				//HEAD
				select RRM_Spine_Top;
				RRM_CreateProxySpline("Neck", 2, 2, 0, $lPrfx, $rPrfx);
				move -r -os -wd 0 -4.5 0 RRM_Neck_Top;
				select RRM_Neck_Top;
				RRM_CreateProxyHead("Head", 1, 0, $lPrfx, $rPrfx);
				select RRM_Head_Top;
				RRM_CreateProxyLookAt("Eye", 1, 3, 0, 1, $lPrfx, $rPrfx);
				move -r -os -wd 0 -1 0 ("RRM_" + $lPrfx + "Eye_Parent") ("RRM_" + $rPrfx + "Eye_Parent");
				//LEGS
				select RRM_ROOT;
				RRM_CreateProxyLeg("Leg", 0, 0, 0, 1, 1, 2, $lPrfx, $rPrfx);
			}
			else if ($RRM_TemplateType == 2)
			{//QUADRUPED
				move -r -os -wd 0 10 -7 RRM_ROOT;
				rotate -r 0 0 0 RRM_ROOT;
				select RRM_ROOT;
				RRM_CreateProxySpline("Spine", 4, 2, 0, $lPrfx, $rPrfx);
				rotate -r -os 90 0 0 RRM_Spine_Parent;
				move -r -os -wd 0 4 0 RRM_Spine_Top;
				//HIND LEGS
				select RRM_ROOT;
				RRM_CreateProxyLeg("HindLeg", 0, 0, 0, 2, 1, 2, $lPrfx, $rPrfx);
				//FRONT LEGS
				select RRM_Spine_Top;
				RRM_CreateProxyAuxiliary("Clavicle", 1, $lPrfx, $rPrfx);
				select ("RRM_" + $lPrfx + "Clavicle_Aux");
				rotate -r -os -90 0 0 ("RRM_" + $lPrfx + "Clavicle_Aux");
				select ("RRM_" + $lPrfx + "Clavicle_Aux");
				RRM_CreateProxyLeg("FrontLeg", 0, 0, 0, 1, 1, 2, $lPrfx, $rPrfx);
				//rotate -r -os -90 0 0 ("RRM_" + $lPrfx + "FrontLeg_Parent");
				move -r -os -wd -1 0 0 ("RRM_" + $lPrfx + "FrontLeg_Hip");
				//HEAD
				select RRM_Spine_Top;
				RRM_CreateProxySpline("Neck", 2, 2, 0, $lPrfx, $rPrfx);
				rotate -r -90 0 0 RRM_Neck_Parent;
				move -r 0 -4 0 RRM_Neck_Top;
				select RRM_Neck_Top;
				RRM_CreateProxyHead("Head", 1, 0, $lPrfx, $rPrfx);
				select RRM_Head_Top;
				RRM_CreateProxyLookAt("Eye", 1, 3, 0, 1, $lPrfx, $rPrfx);
				move -r -os -wd 0 -1 0 ("RRM_" + $lPrfx + "Eye_Parent") ("RRM_" + $rPrfx + "Eye_Parent");	
				RRM_TransferProxies("left", 4);
			}
			else if ($RRM_TemplateType == 3)
			{//ARACHNID
				setAttr RRM_ROOT.ty 2;
				//FRONT LEG
				select RRM_ROOT;
				RRM_CreateProxyArm("FrontLeg", 0, 0, 0, 2, 1, 2, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "FrontLeg_Parent.translate"), 0.625, 0, 1.06);
				setAttr (("RRM_" + $lPrfx + "FrontLeg_Clavicle.translate"), -0.673, 0, 0.063);
				setAttr ("RRM_" + $lPrfx +  "FrontLeg_Clavicle.ry") -48;
				setAttr (("RRM_" + $lPrfx + "FrontLeg_Shoulder.translate"), -1.932, 0.16, 0.574);
				setAttr ("RRM_" + $lPrfx +  "FrontLeg_Shoulder.ry") -48;
				setAttr (("RRM_" + $lPrfx + "FrontLeg_Wrist.translate"), 0, -2, 12.473);
				setAttr (("RRM_" + $lPrfx + "FrontLeg_Elbow2.translate"), 0.798, 3.706, 0.01);
				setAttr ("RRM_" + $lPrfx +  "FrontLeg_Elbow2.rx") 90;
				setAttr (("RRM_" + $lPrfx + "FrontLeg_Elbow1.translate"), -2.458, 3.282, 0.002);
				//MIDFRONT LEG
				select RRM_ROOT;
				RRM_CreateProxyArm("MidFrontLeg", 0, 0, 0, 2, 1, 2, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "MidFrontLeg_Parent.translate"), 0.86, 0, 0.36);
				setAttr (("RRM_" + $lPrfx + "MidFrontLeg_Clavicle.translate"), -0.589, 0, -0.075);
				setAttr ("RRM_" + $lPrfx +  "MidFrontLeg_Clavicle.ry") -32;
				setAttr (("RRM_" + $lPrfx + "MidFrontLeg_Shoulder.translate"), -1.619, 0.16, 0.344);
				setAttr ("RRM_" + $lPrfx +  "MidFrontLeg_Shoulder.ry") -32;
				setAttr (("RRM_" + $lPrfx + "MidFrontLeg_Wrist.translate"), 4.276, -2, 7.86);
				setAttr (("RRM_" + $lPrfx + "MidFrontLeg_Elbow2.translate"), 0.749, 3.696, 0.028);
				setAttr ("RRM_" + $lPrfx +  "MidFrontLeg_Elbow2.rx") 90;
				setAttr (("RRM_" + $lPrfx + "MidFrontLeg_Elbow1.translate"), -2.458, 3.282, 0.002);
				//MID BACK LEG
				select RRM_ROOT;
				RRM_CreateProxyArm("MidBackLeg", 0, 0, 0, 2, 1, 2, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "MidBackLeg_Parent.translate"), 0.86, 0, -0.471);
				setAttr (("RRM_" + $lPrfx + "MidBackLeg_Clavicle.translate"), -0.599, 0, -0.026);
				setAttr ("RRM_" + $lPrfx +  "MidBackLeg_Clavicle.ry") 10;
				setAttr (("RRM_" + $lPrfx + "MidBackLeg_Shoulder.translate"), -1.603, 0.16, -0.157);
				setAttr ("RRM_" + $lPrfx +  "MidBackLeg_Shoulder.ry") 10;
				setAttr (("RRM_" + $lPrfx + "MidBackLeg_Wrist.translate"), 6.09, -2, -2.513);
				setAttr (("RRM_" + $lPrfx + "MidBackLeg_Elbow2.translate"), 0.749, 3.696, 0.005);
				setAttr ("RRM_" + $lPrfx +  "MidBackLeg_Elbow2.rx") 90;
				setAttr (("RRM_" + $lPrfx + "MidBackLeg_Elbow1.translate"), -2.458, 3.282, 0.002);
				//BACK LEG
				select RRM_ROOT;
				RRM_CreateProxyArm("BackLeg", 0, 0, 0, 2, 1, 2, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "BackLeg_Parent.translate"), 0.418, 0, -1.152);
				setAttr (("RRM_" + $lPrfx + "BackLeg_Clavicle.translate"), -0.626, 0, -0.048);
				setAttr ("RRM_" + $lPrfx +  "BackLeg_Clavicle.ry") 60;
				setAttr (("RRM_" + $lPrfx + "BackLeg_Shoulder.translate"), -1.963, 0.16, -0.677);
				setAttr ("RRM_" + $lPrfx +  "BackLeg_Shoulder.ry") 60;
				setAttr (("RRM_" + $lPrfx + "BackLeg_Wrist.translate"), -2.112, -2, -13.918);
				setAttr (("RRM_" + $lPrfx + "BackLeg_Elbow2.translate"),  0.749, 3.696, 0.005);
				setAttr ("RRM_" + $lPrfx +  "BackLeg_Elbow2.rx") 90;
				setAttr (("RRM_" + $lPrfx + "BackLeg_Elbow1.translate"), -2.458, 3.282, 0.002);
				//ABDOMEN
				select RRM_ROOT;
				RRM_CreateProxyFkChain("Abdomen", 1, 5, 0, 3, 0, 1, $lPrfx, $rPrfx);
				setAttr "RRM_Abdomen_Parent.tx" 0.73;
				setAttr ("RRM_Abdomen_Parent.scale", 0.76, 0.76, 0.76);
				setAttr ("RRM_Abdomen_01_01.translate", -2.44, 0.1, 0);
				setAttr "RRM_Abdomen_01_01.rz" 26.7;
				setAttr "RRM_Abdomen_01_02.rz" -9.45;
				setAttr "RRM_Abdomen_01_03.rz" -9.45;
				setAttr "RRM_Abdomen_01_04.rz" -9.45;
				setAttr "RRM_Abdomen_01_05.rz" -9.45;
				//EYES
				select RRM_ROOT;
				RRM_CreateProxyLookAt("Eye", 1, 3, 0, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Eye_Parent.scale"), 0.6, 0.6, 0.6);
				setAttr (("RRM_" + $lPrfx + "Eye_Parent.translate"), 0.41, 0.77, 0.84);
				setAttr ("RRM_" + $lPrfx + "Eye_01.tz") -.315;
				//PEDIPALPS
				select RRM_ROOT;
				RRM_CreateProxyFkChain("Pedipalp", 1, 6, 0, 0, 1, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Pedipalp_Parent.translate"), 1.27, -.025, -0.72);
				setAttr ("RRM_" + $lPrfx + "Pedipalp_Parent.ry") 24;
				setAttr (("RRM_" + $lPrfx + "Pedipalp_Parent.scale"), 0.6, 0.6, 0.6);
				setAttr ("RRM_" + $lPrfx + "Pedipalp_01_01.tx") -2.869;
				setAttr (("RRM_" + $lPrfx + "Pedipalp_01_02.translate"), -0.637, 0, 0);
				setAttr ("RRM_" + $lPrfx + "Pedipalp_01_02.rz") -3.225;
				setAttr (("RRM_" + $lPrfx + "Pedipalp_01_03.translate"), -0.4, -0.05, 0);
				setAttr (("RRM_" + $lPrfx + "Pedipalp_01_03.rotate"), 0, -5, -6);
				setAttr (("RRM_" + $lPrfx + "Pedipalp_01_04.translate"), -0.125, -0.67, 0);
				setAttr ("RRM_" + $lPrfx + "Pedipalp_01_04.rz") -42;
				setAttr (("RRM_" + $lPrfx + "Pedipalp_01_05.translate"), -0.46, -0.2, 0);
				setAttr ("RRM_" + $lPrfx + "Pedipalp_01_05.rz") -37;
				setAttr (("RRM_" + $lPrfx + "Pedipalp_01_06.translate"), -0.25, -0.17, 0);
				setAttr ("RRM_" + $lPrfx + "Pedipalp_01_06.rz") -15;
				//CHELICERAE
				select RRM_ROOT;
				RRM_CreateProxyFkChain("Chelicera", 1, 3, 0, 0, 1, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Chelicera_Parent.translate"), 1.5, -0.13, -0.33);
				setAttr (("RRM_" + $lPrfx + "Chelicera_Parent.scale"), 0.4, 0.4, 0.4);
				setAttr ("RRM_" + $lPrfx + "Chelicera_01_01.tx") -2.34;
				setAttr ("RRM_" + $lPrfx + "Chelicera_01_01.rz") -70;
				setAttr (("RRM_" + $lPrfx + "Chelicera_01_02.translate"), -0.15, -0.05, 0);
				setAttr ("RRM_" + $lPrfx + "Chelicera_01_02.rz") -24;
				setAttr (("RRM_" + $lPrfx + "Chelicera_01_03.translate"), -0.15, -0.24, 0.095);
				setAttr ("RRM_" + $lPrfx + "Chelicera_01_03.rz") -12;
				RRM_TransferProxies("left", 4);
			}
			else if ($RRM_TemplateType == 4)
			{//BIRD
				move -r -os -wd 0 10 -3 RRM_ROOT;
				rotate -r 90 0 0 RRM_ROOT;
				setAttr "RRM_ROOT.template_COG_Ctrl" 0;
				setAttr ("RRM_COG.translate", 0, 5, 0);
				setAttr ("RRM_COG.scale", 0.5, 0.5, 0.5);
				setAttr "RRM_ROOT.template_COG_Ctrl" 1;
				
				select RRM_ROOT;
				//LEGS
				RRM_CreateProxyLeg("Leg", 0, 0, 0, 1, 1, 2, $lPrfx, $rPrfx);
				rotate -r -90 0 0 ("RRM_" + $lPrfx + "Leg_Parent");
				move -r -os -wd 0 0.5 1 ("RRM_" + $lPrfx + "Leg_Knee");
				move -r -os -wd 0 0.75 0 ("RRM_" + $lPrfx + "Leg_Ankle");
				move -r -os -wd 0 0.5 -1.5 ("RRM_" + $lPrfx + "Leg_Ball");
				move -r -os -wd 0 0 -2.5 ("RRM_" + $lPrfx + "Leg_Toe");
				//TOES
				select ("RRM_" + $lPrfx + "Leg_Toe");
				RRM_CreateProxyFkChain("InnerToe", 3, 4, 3, 0, 1, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "InnerToe_Parent.translate"), 0.0, 0.2, 0.0);
				//setAttr (("RRM_" + $lPrfx + "InnerToe_Parent.rotate"), 0, -25, 0);
				setAttr (("RRM_" + $lPrfx + "InnerToe_Parent.scale"), 0.6, 0.6, 0.6);
				setAttr (("RRM_" + $lPrfx + "InnerToe_01_01.translate"), -2, 0, 0);
				setAttr (("RRM_" + $lPrfx + "InnerToe_01_01.rotate"), 0, -25, 0);
				setAttr (("RRM_" + $lPrfx + "InnerToe_02_01.translate"), -2, 0, 0);
				setAttr (("RRM_" + $lPrfx + "InnerToe_03_01.translate"), -2, 0, 0);
				setAttr (("RRM_" + $lPrfx + "InnerToe_03_01.rotate"), 0, 25, 0);
				
				//select ("RRM_" + $lPrfx + "Leg_Toe");
				//RRM_CreateProxyFkChain("MiddleToe", 1, 5, 3, 0, 1, 1, $lPrfx, $rPrfx);
				//setAttr (("RRM_" + $lPrfx + "MiddleToe_Parent.translate"), 0.2, 0.2, 0);
				//setAttr (("RRM_" + $lPrfx + "MiddleToe_Parent.scale"), 0.5, 0.5, 0.5);
				//setAttr (("RRM_" + $lPrfx + "MiddleToe_01_01.translate"), -3, 0, 0);
				
				//select ("RRM_" + $lPrfx + "Leg_Toe");
				//RRM_CreateProxyFkChain("OuterToe", 1, 6, 3, 0, 1, 1, $lPrfx, $rPrfx);
				//setAttr (("RRM_" + $lPrfx + "OuterToe_Parent.translate"), .25, 0.2, -0.4);
				//setAttr (("RRM_" + $lPrfx + "OuterToe_Parent.rotate"), 0, 25, 0);
				//setAttr (("RRM_" + $lPrfx + "OuterToe_Parent.scale"), 0.5, 0.5, 0.5);
				//setAttr (("RRM_" + $lPrfx + "OuterToe_01_01.translate"), -3, 0, 0);

				select ("RRM_" + $lPrfx + "Leg_Toe");
				RRM_CreateProxyFkChain("HindToe", 1, 4, 0, 3, 1, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "HindToe_Parent.translate"), 0, 0.2, 0);
				setAttr (("RRM_" + $lPrfx + "HindToe_Parent.scale"), 0.5, 0.5, 0.5);
				setAttr (("RRM_" + $lPrfx + "HindToe_01_01.translate"), -2, 0, 0);

				//TAIL
				select RRM_ROOT;
				RRM_CreateProxyFkChain("Tail", 1, 4, 0, 2, 0, 1, $lPrfx, $rPrfx);
				setAttr ("RRM_Tail_Parent.scale", 0.75, 0.75, 0.75);
				setAttr ("RRM_Tail_Parent.translate", 0, 2, 0);
				
				//SPINE
				select RRM_ROOT;
				RRM_CreateProxySpline("Spine", 4, 2, 0, $lPrfx, $rPrfx);
				setAttr ("RRM_Spine_Top.translate", 0, -1, 0); 
				
				//WINGS
				select "RRM_Spine_Top";
				RRM_CreateProxyArm("Wing", 0, 0, 0, 2, 1, 2, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Wing_Parent.translate"), 0, 0, 1.75);

				setAttr (("RRM_" + $lPrfx + "Wing_Clavicle.translate"), -.85, 0, 0.6);
				
				setAttr (("RRM_" + $lPrfx + "Wing_Shoulder.translate"), -1.5, 0, -2.5);
				setAttr (("RRM_" + $lPrfx + "Wing_Shoulder.rotate"), 90, 0, 0);
				
				setAttr (("RRM_" + $lPrfx + "Wing_Shoulder.translate"), -1.5, 0, -2.5);
				setAttr (("RRM_" + $lPrfx + "Wing_Shoulder.rotate"), 90, 0, 0);
				
				setAttr (("RRM_" + $lPrfx + "Wing_Elbow1.translate"), 0, 0, 0.1);
				setAttr (("RRM_" + $lPrfx + "Wing_Elbow2.translate"), 0.6, 0, 0);
				
				setAttr (("RRM_" + $lPrfx + "Wing_Wrist.translate"), -1.5, 0, -2.5);
				
				//DIGITS
				select ("RRM_" + $lPrfx + "Wing_Elbow2");
				RRM_CreateProxyFkChain("Alula", 1, 2, 1, 0, 1, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Alula_Parent.translate"), 0.5, 0, -0.5);
				setAttr (("RRM_" + $lPrfx + "Alula_Parent.rotate"), 90, 0, 0);
				setAttr (("RRM_" + $lPrfx + "Alula_Parent.scale"), 0.5, 0.5, 0.5);
				
				setAttr (("RRM_" + $lPrfx + "Alula_01_01.translate"), -3, 0, 0);
				
				select ("RRM_" + $lPrfx + "Wing_Wrist");
				RRM_CreateProxyFkChain("Digit", 1, 2, 1, 0, 1, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Digit_01_01.translate"), -2.5, 0, 0);
				
				//NECK
				select "RRM_Spine_Top";
				RRM_CreateProxySpline("Neck", 6, 2, 0, $lPrfx, $rPrfx);
				setAttr ("RRM_Neck_Top.translate", 0, -5.5, -5.5);
				setAttr ("RRM_Neck_Top.rotate", -90, 0, 0);
				
				setAttr ("RRM_Neck_01.translate", 0, 0.845, 0.563);
				setAttr ("RRM_Neck_01.rotate", -20, 0, 0);

				setAttr ("RRM_Neck_02.translate", 0, 1.314, 0.77);
				setAttr ("RRM_Neck_02.rotate", -57, 0, 0);

				setAttr ("RRM_Neck_03.translate", 0, 1.352, 0.582);
				setAttr ("RRM_Neck_03.rotate", -90, 0, 0);

				setAttr ("RRM_Neck_04.translate", 0, 1.014, 0.376);
				setAttr ("RRM_Neck_04.rotate", -100, 0, 0);

				setAttr ("RRM_Neck_05.translate", 0, 0.563, 0.207);
				setAttr ("RRM_Neck_05.rotate", -101, 0, 0);

				setAttr ("RRM_Neck_06.translate", 0, 0.225, 0.075);
				setAttr ("RRM_Neck_06.rotate", -90, 0, 0);
				
				//HEAD
				select "RRM_Neck_Top";
				RRM_CreateProxyHead("Head", 1, 0, $lPrfx, $rPrfx);
				setAttr ("RRM_Head_Top.translate", 0, 2, 0);
				setAttr ("RRM_Head_Jaw.translate", 0, 0.5, 0.4);
				setAttr ("RRM_Head_JawEnd.translate", 0, 0, 2.5);
				setAttr ("RRM_Head_JawEnd.rotate", 90, 0, 0);
				
				select "RRM_Head_Top";
				RRM_CreateProxyLookAt("Eye", 1, 1, 0, 1, $lPrfx, $rPrfx);
				setAttr (("RRM_" + $lPrfx + "Eye_Parent.translate"), 0.2, -0.6, 1);
				setAttr (("RRM_" + $lPrfx + "Eye_Parent.scale"), 0.75, 0.75, 0.75);
				setAttr (("RRM_" + $lPrfx + "Eye_01.translate"), -1, 0, 0);

				RRM_TransferProxies("left", 4);
			}
		}
		
		//if ($crntUnit == "m")
		//{
		//	setAttr ("RRM_MAIN.scale", 10,10,10);
		//}
		
		$modNodes = `ls RRM_ROOT RRM_MAIN`;
		RRM_ProxyLockNodes($modNodes);
		select RRM_ROOT;
		
		//REVERT UNITS
		//if ($crntUnit != "cm")
		//{
		//	//changeLinearUnit "centimeter"
		//}
		//changeLinearUnit $crntUnit;
	}
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

//ATTACH TO RIG
global proc RRM_AttachToRig(string $modName, string $attachMod, string $prfx, string $crntSide, string $oppSide, string $attachModCore, int $mirrorMod, int $mirrorCheck)
{

	if ($mirrorMod == $mirrorCheck)
	{
		if (`objExists ($attachMod + ".pair")`)
		{
			string $side = `getAttr ($attachMod + ".pair")`;
			if ($side == $crntSide)
			{
				parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
				scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
				setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;
				
				//ADD ATTACH NODE NAME
				if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
				}
				else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
				}
			}
			else if ($side == $oppSide)
			{
				$sideCheck = `getAttr ($attachMod + ".opposite")`;
				parentConstraint ("RRM_" + $sideCheck) "RRM_MAIN" ("RRM_" + $prfx + $modName);
				scaleConstraint ("RRM_" + $sideCheck) "RRM_MAIN" ("RRM_" + $prfx + $modName);
				setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;

				//ADD ATTACH NODE NAME
				if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $sideCheck;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
				}
				else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $sideCheck;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
				}
			}
		}
		else
		{
			parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
			scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
			setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
			setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;			

			//ADD ATTACH NODE NAME
			if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
			{
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
			}
			else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
			{
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
			}
		}
	
	}
	else
	{
		parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
		scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
		setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
		setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;

		//ADD ATTACH NODE NAME
		if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
		}
		else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
		}
	}

	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////SPLINE////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxySpline2(string $modName, int $mirrorMod, string $prfx, string $oppPrfx, int $splineNum, int $twistAxis, string $crntUnit)
{
	$i1 = 1;
	$i2 = $splineNum;
	string $nPd = "_0";
	string $nPdPrev = "_0";

	while ($i1 <= $splineNum)
	{
		if ($i1 >= 10)
		{$nPd = "_";}
		if ($i1 >= 11)
		{$nPdPrev = "_";}
	
		//SET SPLINE NUM IN PARENT NODE
		lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.splineNum");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.splineNum") $splineNum;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.splineNum");
		
		//SET TWIST AXIS IN PARENT NODE
		//lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");
		if (!`objExists ("RRM_" + $prfx + $modName + "_Parent.twistAxis")`)
		{
			addAttr -ln "twistAxis" -at "enum" -en "X-axis:Y-axis:" -k 1 ("RRM_" + $prfx + $modName + "_Parent");
		}
		setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.twistAxis");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.twistAxis") $twistAxis;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.twistAxis");
		
		//SET SPLINE NUM IN TOP NODE
		lockNode -l off ("RRM_" + $modName);
		setAttr -l false ("RRM_" + $modName + ".jointsNum");
		setAttr ("RRM_" + $modName + ".jointsNum") $splineNum;
		setAttr -l true ("RRM_" + $modName + ".jointsNum");
		
		//SET TWIST AXIS IN TOP NODE
		if (!`objExists ("RRM_" + $modName + ".twistAxis")`)
		{
			addAttr -ln "twistAxis" -at "enum" -en "X-axis:Y-axis:" ("RRM_" + $modName);
		}
		setAttr -l false ("RRM_" + $modName + ".twistAxis");
		setAttr ("RRM_" + $modName + ".twistAxis") $twistAxis;
		setAttr -l true ("RRM_" + $modName + ".twistAxis");
		
		RRM_CreateProxySplineModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + $nPd + $i1));
		group -n ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp") ("RRM_" + $prfx + $modName + $nPd + $i1); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".core") ($prfx + $modName + $nPd + $i1);
		setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".ext") ($nPd + $i1);
		setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".ext");

		if ($mirrorMod == 1)
		{
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + $nPd + $i1);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite") ($oppPrfx + $modName + $nPd + $i1);
			setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite");
		}
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp");
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ParentW0") $i2;
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_TopW1") $i1;		
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + ".overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + ".overrideColor") 29;
		
		//CONNECTORS
		int $prev = ($i1 -1);
		if ($i1 == 1){
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + $nPd + $i1));
		}
		else {
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + $nPdPrev + $prev), ("RRM_" + $prfx + $modName + $nPd + $i1));
		}
		if ($i1 == $splineNum){
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + $nPd + $i1), ("RRM_" + $prfx + $modName + "_Top"));
		}
		$i1++;
		$i2--;
		
	}
}
		
global proc RRM_CreateProxySpline(string $modName, int $splineNum, int $twistAxis, int $mirrorMod, string $lPrfx, string $rPrfx)
{
	string $crntUnit = `currentUnit -query -linear`;

	//CONVERT RADIO BUTTON TO ENUM VALUE
	$twistAxis = ($twistAxis - 1);

	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$posOffset = 0;
		}
		
		if (`objExists ($attachMod[0] + (".opposite"))`)
		{
			$posOffset = 0;
		}
		
		//CREATE JOINT BASE
		RRM_CreateProxyParentProxy($crntUnit, $crntSide, ("RRM_" + $prfx + $modName + "_Parent"));
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		move -r $posOffset 0 0 ("RRM_" + $prfx + $modName + "_Parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "spline";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 29;
		
		//ADD SPINE NUMBERS TO PARENT
		addAttr -ln "splineNum" -at long -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		//ADD TWIST AXIS TO PARENT
		addAttr -ln "twistAxis" -at "enum" -en "X-axis:Y-axis:" -k 1 ("RRM_" + $prfx + $modName + "_Parent");

		
		RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Top"));
		parent ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Top");
		move -r 0 7 0 ("RRM_" + $prfx + $modName + "_Top");
		makeIdentity -apply true -t 1 ("RRM_" + $prfx + $modName + "_Top");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.core") ($prfx + $modName + "_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.core");
			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.ext") ("_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Top.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Top.overrideColor") 29;
	
		if ($mirrorMod == 1)
		{
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");
	
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Top.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.opposite") ($oppPrfx + $modName + "_Top");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.opposite");

			//ADD EXTRA ATTRIBUTES
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
		}	
	
		//ADD SPINE NUMBERS TO TOP GROUP
		if ($i == 0)
		{
			addAttr -ln "jointsNum" -at long -dv 1 ("RRM_" + $modName);
			addAttr -ln "twistAxis" -at "enum" -en "X-axis:Y-axis:" ("RRM_" + $modName);
		}

		RRM_CreateProxySpline2($modName, $mirrorMod, $prfx, $oppPrfx, $splineNum, $twistAxis, $crntUnit);
	
		//ADD EXTRA ATTRIBUTES
		if ($mirrorMod == 1)
		{
			select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top")
			("RRM_" + $prfx + $modName + "_??");
			
			$RRM_Splines = `ls -sl`;
			string $crntMod;
			for ($crntMod in $RRM_Splines)
			{
				//PAIR AND TYPE
				addAttr -ln "pair" -dt "string" $crntMod;
				setAttr -e -k 1 ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
			}
		}
			

		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
	
		select ("RRM_" + $prfx + $modName + "_*Grp");
		select -d ("RRM_" + $prfx + $modName + "_ConnectorGrp");
		$modGroups = `ls-sl`;
		string $selectedModGroup;
		for ($selectedModGroup in $modGroups)
		{
		setAttr -l 1 -k 0 ($selectedModGroup + ".tx");
		setAttr -l 1 -k 0 ($selectedModGroup + ".ty");
		setAttr -l 1 -k 0 ($selectedModGroup + ".tz");
		setAttr -l 1 -k 0 ($selectedModGroup + ".rx");
		setAttr -l 1 -k 0 ($selectedModGroup + ".ry");
		setAttr -l 1 -k 0 ($selectedModGroup + ".rz");
		setAttr -l 1 -k 0 ($selectedModGroup + ".sx");
		setAttr -l 1 -k 0 ($selectedModGroup + ".sy");
		setAttr -l 1 -k 0 ($selectedModGroup + ".sz");
		setAttr -l 1 -k 0 ($selectedModGroup + ".v");
		setAttr -l 1 -k 0 ($selectedModGroup + "_pointConstraint1.nds");
		setAttr -l 1 -k 0 ($selectedModGroup + "_pointConstraint1.ox");
		setAttr -l 1 -k 0 ($selectedModGroup + "_pointConstraint1.oy");
		setAttr -l 1 -k 0 ($selectedModGroup + "_pointConstraint1.oz");
		setAttr -l 1 -k 0 ($selectedModGroup + "_pointConstraint1.w0");
		setAttr -l 1 -k 0 ($selectedModGroup + "_pointConstraint1.w1");
		}

		if (!`objExists ("RRM_" + $modName + ".top")`)
		{
			//ADD TOP ATTRIBUTE
			addAttr -ln "top" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".top");
			setAttr -type "string" ("RRM_" + $modName + ".top") "spline";
			setAttr -l true ("RRM_" + $modName + ".top");
			
			//ADD PARENT ATTRIBUTE
			$parentCore = `getAttr ($attachMod[0] + ".core")`;
			addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".parent");
			setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
			setAttr -l true ("RRM_" + $modName + ".parent");
			
			//ADD CORE NAME ATTRIBUTE
			addAttr -ln "core" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".core");
			setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
			setAttr -l true ("RRM_" + $modName + ".core");


			parent ("RRM_" + $modName) $attachMod[0];
		}
		select ("RRM_" + $prfx + $modName + "_Parent");
		
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}
		
	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	
	RRM_ProxyLimits($xforms);
	
	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);
		
	select -cl;
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Parent")`)
		{select ("RRM_" + $lPrfx + $modName + "_Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modName + "_Parent")`)
		{select -add ("RRM_" + $rPrfx + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_SplinePrompts(string $modName, int $splineNum, int $twistAxis, int $mirrorMod)
{
	string $lPrfx;
	string $rPrfx;
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldSplineName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "A module already exists with this name. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxySpline($modName, $splineNum, $twistAxis, $mirrorMod, $lPrfx, $rPrfx);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					$lPrfx = "l_";
					$rPrfx = "r_";
					if (`objExists RRM_MAIN.lPrfx`)
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
					}
					RRM_CreateProxySpline($modName, $splineNum, $twistAxis, $mirrorMod, $lPrfx, $rPrfx);
				}
			}
		}
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////ARMS////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyArm2(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $toon, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit)
{
	//SET ARM NUM'S IN PARENT NODE
	lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.upperTwistNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.upperTwistNum") $upperArmNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.upperTwistNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.lowerTwistNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.lowerTwistNum") $lowerArmNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.lowerTwistNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.elbowNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.elbowNum") $elbowJoints;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.elbowNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.midTwistNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.midTwistNum") $elbowNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.midTwistNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.toonArms");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.toonArms") $toon;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.toonArms");
	
	
	
	//ELBOW
	if ($elbowJoints == 1)
	{
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Elbow"));
		curve -n ("RRM_" + $prfx + $modName + "_ElbowAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_ElbowAim")` ("RRM_" + $prfx + $modName + "_ElbowAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_ElbowAimShape") ("RRM_" + $prfx + $modName + "_Elbow");
		delete ("RRM_" + $prfx + $modName + "_ElbowAim");
		group -n ("RRM_" + $prfx + $modName + "_ElbowGrp") ("RRM_" + $prfx + $modName + "_Elbow"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ElbowGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ElbowGrp");		
		move -r ($multiplier * 6.45) 0 0 ("RRM_" + $prfx + $modName + "_ElbowGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ElbowGrp");	
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.core") ($prfx + $modName + "_Elbow");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow.core");
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.ext") ("_Elbow");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Elbow.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow.overrideColor") 7;
	}
	else
	{
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Elbow1"));
		curve -n ("RRM_" + $prfx + $modName + "_Elbow1Aim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Elbow1Aim")` ("RRM_" + $prfx + $modName + "_Elbow1AimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_Elbow1AimShape") ("RRM_" + $prfx + $modName + "_Elbow1");
		delete ("RRM_" + $prfx + $modName + "_Elbow1Aim");
		group -n ("RRM_" + $prfx + $modName + "_Elbow1Grp") ("RRM_" + $prfx + $modName + "_Elbow1"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_Elbow1Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow1Grp");		
		move -r ($multiplier * 6.45) 0 0 ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow1Grp");	
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.core") ($prfx + $modName + "_Elbow1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow1.core");
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.ext") ("_Elbow1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow1.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1.overrideColor") 7;
		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Elbow2"));
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow2");
		curve -n ("RRM_" + $prfx + $modName + "_Elbow2Aim") -d 1 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 1 -p 0.5 0 1 -p 0 0 1.5 -p -0.5 0 1 -p -0.25 0 1 -p -0.25 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Elbow2Aim")` ("RRM_" + $prfx + $modName + "_Elbow2AimShape");
		rotate -r 0 0 ($multiplier * 90) ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		parent -r -s ("RRM_" + $prfx + $modName + "_Elbow2AimShape") ("RRM_" + $prfx + $modName + "_Elbow2");
		delete ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		group -n ("RRM_" + $prfx + $modName + "_Elbow2Grp") ("RRM_" + $prfx + $modName + "_Elbow2"); xform -os -piv 0 0 0;
		parent ("RRM_" + $prfx + $modName + "_Elbow2Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow2Grp");
  
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.core") ($prfx + $modName + "_Elbow2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow2.core");
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.ext") ("_Elbow2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow2.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Elbow2.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2.overrideColor") 7;
	}
	
	//ARM CONSTRAINTS
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_ElbowGrp");
		setAttr ("RRM_" + $prfx + $modName + "_ElbowGrp_pointConstraint1.offsetZ") -.0001;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		parent ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp");
		aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_ElbowGrp");
		
		pointConstraint -skip y -skip z ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		aimConstraint -aimVector 0 0 1 -upVector -1 0 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector -1 0 0
		-skip y -skip z ("RRM_" + $prfx + $modName + "_ElbowAimLctr") ("RRM_" + $prfx + $modName + "_Elbow");
		
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Clavicle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Clavicle"), ("RRM_" + $prfx + $modName + "_Shoulder"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Shoulder"), ("RRM_" + $prfx + $modName + "_Elbow"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow"), ("RRM_" + $prfx + $modName + "_Wrist"));
	}
	else
	{
		//CONNECT ELBOW 2
		aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2Grp_pointConstraint1." + "RRM_" + $prfx + $modName + "_WristW1") 2;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
 
		aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
		parent ("RRM_" + $prfx + $modName + "_Elbow2AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_Elbow2AimLctr") ("RRM_" + $prfx + $modName + "_Elbow2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2AimLctr.v") 0;
  
		//CONNECT ELBOW 1
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1Grp_pointConstraint1.offsetZ") -.0001;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		parent ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp");
		aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		
		pointConstraint -skip y -skip z ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		aimConstraint -aimVector 0 0 1 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 1 0 0
		-skip y -skip z ("RRM_" + $prfx + $modName + "_ElbowAimLctr") ("RRM_" + $prfx + $modName + "_Elbow1");

		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Clavicle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Clavicle"), ("RRM_" + $prfx + $modName + "_Shoulder"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Shoulder"), ("RRM_" + $prfx + $modName + "_Elbow1"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow1"), ("RRM_" + $prfx + $modName + "_Elbow2"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow2"), ("RRM_" + $prfx + $modName + "_Wrist"));
	}	
	
	//UPPER ARM JOINTS
	if ($upperArmNum > 0)
	{
		$shoulderInf = $upperArmNum;
		$elbowInf = 1;
		$crntInt = 1;
		while ($crntInt <= $upperArmNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Upper" + $crntInt));
			group -n ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core") ($prfx + $modName + "_Upper" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext") ("_Upper" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Upper" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "_4Shape.localScale"), .125, .125, .125); 
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "_4Shape.localScale"), .00125, .00125, .00125);
			}
			
			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ShoulderW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ElbowW1") $elbowInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ShoulderW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow1W1") $elbowInf;
			}

			//LOCK ATTRIBUTES
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sz");

			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ty");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sz");

			$shoulderInf--;
			$elbowInf++;
			$crntInt++;
		}
	}
		
	//LOWER ARM JOINTS
	if ($lowerArmNum > 0)               
	{
		$elbowInf = $lowerArmNum;
		$wristInf = 1;
		$crntInt = 1;
		while ($crntInt <= $lowerArmNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Lower" + $crntInt));
			group -n ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core") ($prfx + $modName + "_Lower" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext") ("_Lower" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Lower" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "_4Shape.localScale"), .125, .125, .125);
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "_4Shape.localScale"), .00125, .00125, .00125);
			}

			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ElbowW0") $elbowInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_WristW1") $wristInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow2W0") $elbowInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_WristW1") $wristInf;
			}

			//LOCK ATTRIBUTES
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sz");

			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ty");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sz");

			$elbowInf--;
			$wristInf++;
			$crntInt++;
		}
	}
	
	//ELBOW JOINTS
	if ($elbowJoints == 2)
	{
		if ($elbowNum > 0)
		{
			$elbow1Inf = $elbowNum;
			$elbow2Inf = 1;
			$crntInt = 1;
			while ($crntInt <= $elbowNum)
			{
				RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Middle" + $crntInt));
				group -n ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				parent ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
				scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");

				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core") ($prfx + $modName + "_Middle" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext") ("_Middle" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext");
				if ($mirrorMod == 2)
				{
					addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair") ($crntSide);
					addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Middle" + $crntInt);
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair");
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite");
				}
				//SCALE LOCATOR
				setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "_4Shape.localScale"), .125, .125, .125);
				if ($crntUnit == "m")
				{
					setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "_4Shape.localScale"), .00125, .00125, .00125);
				}
				connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".template");
				
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow1W0") $elbow1Inf;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow2W1") $elbow2Inf;
				
				//LOCK ATTRIBUTES
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ry");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rz");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sy");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sz");

				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ty");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tz");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ry");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rz");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sy");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sz");
				
				$elbow1Inf--;
				$elbow2Inf++;
				$crntInt++;
			}
		}
	}
	
	//LOCK CHANNELS
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow.rx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow.ry");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow.rz");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow.sx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow.sy");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow.sz");
	}
	else
	{
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow1.rx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow1.ry");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow1.rz");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow1.sx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow1.sy");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow1.sz");
 
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow2.ry");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow2.rz");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow2.sx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow2.sy");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Elbow2.sz");
	}

	//ADD EXTRA ATTRIBUTES
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
		{
			select ("RRM_" + $prfx + $modName + "_Elbow");
		}
		else
		{
			select ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Elbow2");
		}
		
		$armMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $armMods)
		{
			//PAIR AND TYPE
			addAttr -ln "pair" -dt "string" $crntMod;
			setAttr -e -k 1 ($crntMod + ".pair");
			setAttr -type "string" ($crntMod + ".pair") $crntSide;
			setAttr -l true ($crntMod + ".pair");
			//OPPOSITE NAME
			addAttr -ln "opposite" -dt "string" $crntMod;
			setAttr -e -k 1 ($crntMod + ".opposite");
		}
		if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.opposite") ($oppPrfx + $modName + "_Elbow");
		}
		else
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.opposite") ($oppPrfx + $modName + "_Elbow1");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.opposite") ($oppPrfx + $modName + "_Elbow2");
		}
		
		for ($crntMod in $armMods)
		{
			setAttr -l true ($crntMod + ".opposite");
		}
	}

	setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v")  0;
	setAttr ("RRM_" + $prfx + $modName + "_ElbowAimLctr.v") 0;
}

global proc RRM_CreateProxyArm(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $toon, int $mirrorMod, string $lPrfx, string $rPrfx)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	//ARM
	while ($i !=2)
	{	
		if ($mirrorMod != 2)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		if ($mirrorMod == 3)
		{
			$crntSide = "right";
			$oppSide = "left"; 
			$multiplier = -1;
		}
			
			
		//ATTACH NODE
		RRM_CreateProxyParentProxy($crntUnit, $crntSide, ("RRM_" + $prfx + $modName + "_Parent"));
		rotate -r 0 0 ($multiplier * -90) ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "arm";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 7;
		
		addAttr -ln "upperTwistNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "lowerTwistNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "elbowNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "midTwistNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		
		//TEMPLATE ROLL JOINTS
		addAttr -ln "templateTwistJoints" -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints");
		
		//TOON ARMS
		addAttr -ln "toonArms" -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -k 1 -l 1 ("RRM_" + $prfx + $modName + "_Parent.toonArms");
		
		//CLAVICLE		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Clavicle"));
		group -n ("RRM_" + $prfx + $modName + "_ClavicleGrp") ("RRM_" + $prfx + $modName + "_Clavicle"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ClavicleGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		move -r ($multiplier * 1.25) 0 0 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.core") ($prfx + $modName + "_Clavicle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Clavicle.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.ext") ("_Clavicle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Clavicle.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Clavicle.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Clavicle.overrideColor") 7;
		
		//SHOULDER		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Shoulder"));
		group -n ("RRM_" + $prfx + $modName + "_ShoulderGrp") ("RRM_" + $prfx + $modName + "_Shoulder"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ShoulderGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ShoulderGrp");		
		move -r ($multiplier * 2.95) 0 0 ("RRM_" + $prfx + $modName + "_ShoulderGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ShoulderGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.core") ($prfx + $modName + "_Shoulder");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Shoulder.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.ext") ("_Shoulder");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Shoulder.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Shoulder.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Shoulder.overrideColor") 7;

		//WRIST
		RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Wrist"));		
		rotate -r 0 0 ($multiplier * -90) ("RRM_" + $prfx + $modName + "_Wrist");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Wrist");
		group -n ("RRM_" + $prfx + $modName + "_WristGrp") ("RRM_" + $prfx + $modName + "_Wrist"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_WristGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_WristGrp");		
		move -r ($multiplier * 9.95) 0 0 ("RRM_" + $prfx + $modName + "_WristGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_WristGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.core") ($prfx + $modName + "_Wrist");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Wrist.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.ext") ("_Wrist");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Wrist.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Wrist.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Wrist.overrideColor") 7;

		RRM_CreateProxyArm2($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

		//ADD EXTRA ATTRIBUTES
		if ($mirrorMod == 2)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
				
			}
			
			select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Clavicle")
			("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist");
			
			$armMods = `ls -sl`;
			string $crntMod;
			for ($crntMod in $armMods)
			{
				//PAIR AND TYPE
				addAttr -ln "pair" -dt "string" $crntMod;
				setAttr -e -k 1 ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
				//OPPOSITE NAME
				addAttr -ln "opposite" -dt "string" $crntMod;
				setAttr -e -k 1 ($crntMod + ".opposite");
			}
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.opposite") ($oppPrfx + $modName + "_Clavicle");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.opposite") ($oppPrfx + $modName + "_Shoulder");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.opposite") ($oppPrfx + $modName + "_Wrist");
			
			for ($crntMod in $armMods)
			{
				setAttr -l true ($crntMod + ".opposite");
			}
		}
		else
		{
			//ADD LEFT OR RIGHT ATTRIBUTE
			addAttr -ln "single" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".single");
			setAttr -type "string" ("RRM_" + $modName + ".single") $crntSide;
			setAttr -l true ("RRM_" + $modName + ".single");
		}

		//ATTACH TO RIG
		int $mirrorCheck = 2;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
	
		if (!`objExists ("RRM_" + $modName + ".top")`)
		{	
			//ADD TOP ATTRIBUTE
			addAttr -ln "top" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".top");
			setAttr -type "string" ("RRM_" + $modName + ".top") "arm";
			setAttr -l true ("RRM_" + $modName + ".top");
			
			//ADD PARENT ATTRIBUTE
			$parentCore = `getAttr ($attachMod[0] + ".core")`;
			addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".parent");
			setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
			setAttr -l true ("RRM_" + $modName + ".parent");

			//ADD CORE NAME ATTRIBUTE
			addAttr -ln "core" -dt "string" ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".core");
			setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
			setAttr -l true ("RRM_" + $modName + ".core");
			
			//ADD UPPER ARM NUM ATTRIBUTE
			addAttr -ln "upperArmNum" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".upperArmNum");
			setAttr ("RRM_" + $modName + ".upperArmNum") $upperArmNum;
			setAttr -l true ("RRM_" + $modName + ".upperArmNum");
			
			//ADD LOWER ARM NUM ATTRIBUTE
			addAttr -ln "lowerArmNum" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".lowerArmNum");
			setAttr ("RRM_" + $modName + ".lowerArmNum") $lowerArmNum;
			setAttr -l true ("RRM_" + $modName + ".lowerArmNum");

			//ADD ELBOW NUM ATTRIBUTE
			addAttr -ln "elbowNum" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".elbowNum");
			setAttr ("RRM_" + $modName + ".elbowNum") $elbowNum;
			setAttr -l true ("RRM_" + $modName + ".elbowNum");

			//ADD UPPER ARM NUM ATTRIBUTE
			addAttr -ln "elbowJoints" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".elbowJoints");
			setAttr ("RRM_" + $modName + ".elbowJoints") $elbowJoints;
			setAttr -l true ("RRM_" + $modName + ".elbowJoints");
			
			//ADD TOON ARM ATTRIBUTE
			addAttr -ln "toonArms" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".toonArms");
			setAttr ("RRM_" + $modName + ".toonArms") $toon;
			setAttr -l true ("RRM_" + $modName + ".toonArms");
			
			
			parent ("RRM_" + $modName) $attachMod[0];
		}
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	
		if ($mirrorMod != 2)
		{
			$i = 2;
		}
	}

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Parent")`)
		{select ("RRM_" + $lPrfx + $modName + "_Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modName + "_Parent")`)
		{select -add ("RRM_" + $rPrfx + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_ArmPrompts(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $toon, int $mirrorMod)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldArmName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyArm($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $lPrfx, $rPrfx);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
					RRM_CreateProxyArm($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $lPrfx, $rPrfx);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////LEGS////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyLeg2(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $toon, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $posOffset, string $crntUnit)
{
	//SET ARM NUM'S IN PARENT NODE
	lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.upperTwistNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.upperTwistNum") $upperLegNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.upperTwistNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.lowerTwistNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.lowerTwistNum") $lowerLegNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.lowerTwistNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.kneeNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.kneeNum") $kneeJoints;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.kneeNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.midTwistNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.midTwistNum") $kneeNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.midTwistNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.toonLegs");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.toonLegs") $toon;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.toonLegs");

	//KNEE
	if ($kneeJoints == 1)
	{
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Knee"));
		curve -n ("RRM_" + $prfx + $modName + "_KneeAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_KneeAim")` ("RRM_" + $prfx + $modName + "_KneeAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_KneeAimShape") ("RRM_" + $prfx + $modName + "_Knee");
		delete ("RRM_" + $prfx + $modName + "_KneeAim");
		group -n ("RRM_" + $prfx + $modName + "_KneeGrp") ("RRM_" + $prfx + $modName + "_Knee"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_KneeGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_KneeGrp");		
		rotate -r 0 -180 90 ("RRM_" + $prfx + $modName + "_Knee");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_KneeGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_KneeGrp");	
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.core") ($prfx + $modName + "_Knee");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee.core");
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.ext") ("_Knee");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Knee.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee.overrideColor") 31;
	}
	else
	{
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Knee1"));
		curve -n ("RRM_" + $prfx + $modName + "_Knee1Aim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Knee1Aim")` ("RRM_" + $prfx + $modName + "_Knee1AimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_Knee1AimShape") ("RRM_" + $prfx + $modName + "_Knee1");
		delete ("RRM_" + $prfx + $modName + "_Knee1Aim");
		group -n ("RRM_" + $prfx + $modName + "_Knee1Grp") ("RRM_" + $prfx + $modName + "_Knee1"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_Knee1Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee1Grp");		
		rotate -r 0 -180 90 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee1Grp");	
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.core") ($prfx + $modName + "_Knee1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee1.core");
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.ext") ("_Knee1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee1.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Knee1.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee1.overrideColor") 31;
		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Knee2"));
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee2");
		curve -n ("RRM_" + $prfx + $modName + "_Knee2Aim") -d 1 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 1 -p 0.5 0 1 -p 0 0 1.5 -p -0.5 0 1 -p -0.25 0 1 -p -0.25 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Knee2Aim")` ("RRM_" + $prfx + $modName + "_Knee2AimShape");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Knee2Aim");
		parent -r -s ("RRM_" + $prfx + $modName + "_Knee2AimShape") ("RRM_" + $prfx + $modName + "_Knee2");
		delete ("RRM_" + $prfx + $modName + "_Knee2Aim");
		group -n ("RRM_" + $prfx + $modName + "_Knee2Grp") ("RRM_" + $prfx + $modName + "_Knee2"); xform -os -piv 0 0 0;
		parent ("RRM_" + $prfx + $modName + "_Knee2Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee2Grp");
		
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.rotateOrder") 1;
  
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.core") ($prfx + $modName + "_Knee2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee2.core");
 
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.ext") ("_Knee2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee2.ext");
  
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.overrideColor") 31;
	}
	
	//LEG CONSTRAINTS
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_KneeGrp");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		parent ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp");
		aimConstraint -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_KneeGrp");
		
		pointConstraint -skip x -skip z ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 0 1 0
		-skip x -skip z ("RRM_" + $prfx + $modName + "_KneeAimLctr") ("RRM_" + $prfx + $modName + "_Knee");
		
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Hip"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Hip"), ("RRM_" + $prfx + $modName + "_Knee"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee"), ("RRM_" + $prfx + $modName + "_Ankle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ankle"), ("RRM_" + $prfx + $modName + "_Ball"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ball"), ("RRM_" + $prfx + $modName + "_Toe"));
	}
	else
	{
		//CONNECT KNEE 2
		aimConstraint -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" -skip y ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Knee2Grp_pointConstraint1." + "RRM_" + $prfx + $modName + "_AnkleW1") 2;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
 
		aimConstraint -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
		parent ("RRM_" + $prfx + $modName + "_Knee2AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_Knee2AimLctr") ("RRM_" + $prfx + $modName + "_Knee2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Knee2AimLctr.v") 0;
  
		//CONNECT KNEE 1
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Knee1Grp");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		parent ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp");
		aimConstraint -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Knee1Grp");
		
		pointConstraint -skip x -skip z ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 0 1 0
		-skip x -skip z ("RRM_" + $prfx + $modName + "_KneeAimLctr") ("RRM_" + $prfx + $modName + "_Knee1");

		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Hip"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Hip"), ("RRM_" + $prfx + $modName + "_Knee1"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee1"), ("RRM_" + $prfx + $modName + "_Knee2"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee2"), ("RRM_" + $prfx + $modName + "_Ankle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ankle"), ("RRM_" + $prfx + $modName + "_Ball"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ball"), ("RRM_" + $prfx + $modName + "_Toe"));
	}	
	
	//UPPER LEG JOINTS
	if ($upperLegNum > 0)
	{
		$shoulderInf = $upperLegNum;
		$kneeInf = 1;
		$crntInt = 1;
		while ($crntInt <= $upperLegNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Upper" + $crntInt));
			group -n ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core") ($prfx + $modName + "_Upper" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext") ("_Upper" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Upper" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "_4Shape.localScale"), .125, .125, .125);
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "_4Shape.localScale"), .00125, .00125, .00125);
			}

			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".template");
			
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_HipW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_KneeW1") $kneeInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_HipW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee1W1") $kneeInf;
			}
			//LOCK ATTRIBUTES
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sz");

			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ty");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sz");

			$shoulderInf--;
			$kneeInf++;
			$crntInt++;
		}
	}

	//LOWER LEG JOINTS
	if ($lowerLegNum > 0)               
	{
		$kneeInf = $lowerLegNum;
		$wristInf = 1;
		$crntInt = 1;
		while ($crntInt <= $lowerLegNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Lower" + $crntInt));
			group -n ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core") ($prfx + $modName + "_Lower" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext") ("_Lower" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Lower" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "_4Shape.localScale"), .125, .125, .125);
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "_4Shape.localScale"), .00125, .00125, .00125);
			}
			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_KneeW0") $kneeInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_AnkleW1") $wristInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee2W0") $kneeInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_AnkleW1") $wristInf;
			}
			//LOCK ATTRIBUTES
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sz");

			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ty");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ry");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rz");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sx");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sy");
			setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sz");

			$kneeInf--;
			$wristInf++;
			$crntInt++;
		}
	}
	
	//KNEE JOINTS
	if ($kneeJoints == 2)
	{
		if ($kneeNum > 0)
		{
			$knee1Inf = $kneeNum;
			$knee2Inf = 1;
			$crntInt = 1;
			while ($crntInt <= $kneeNum)
			{
				RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Middle" + $crntInt));
				group -n ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				parent ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
				scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");

				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core") ($prfx + $modName + "_Middle" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext") ("_Middle" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext");
				if ($mirrorMod == 2)
				{
					addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair") ($crntSide);
					addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Middle" + $crntInt);
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair");
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite");
				}
				//SCALE LOCATOR
				setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "_4Shape.localScale"), .125, .125, .125);
				if ($crntUnit == "m")
				{
					setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "_4Shape.localScale"), .00125, .00125, .00125);
				}
				connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".template");
				
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee1W0") $knee1Inf;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee2W1") $knee2Inf;
				
				//LOCK ATTRIBUTES
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ry");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rz");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sy");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sz");
				
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ty");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tz");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ry");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rz");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sx");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sy");
				setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sz");

				$knee1Inf--;
				$knee2Inf++;
				$crntInt++;
			}
		}
	}
	
	//LOCK CHANNELS
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee.rx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee.ry");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee.rz");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee.sx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee.sy");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee.sz");
	}
	else
	{
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee1.rx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee1.ry");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee1.rz");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee1.sx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee1.sy");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee1.sz");
 
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee2.rx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee2.ry");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee2.rz");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee2.sx");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee2.sy");
		setAttr -l 1 -k 0 ("RRM_" + $prfx + $modName + "_Knee2.sz");
	}
 
	//ADD EXTRA ATTRIBUTES
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
		{
			select ("RRM_" + $prfx + $modName + "_Knee");
		}
		else
		{
			select ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Knee2");
		}
		
		$legMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $legMods)
		{
			//PAIR AND TYPE
			addAttr -ln "pair" -dt "string" $crntMod;
			setAttr -e -k 1 ($crntMod + ".pair");
			setAttr -type "string" ($crntMod + ".pair") $crntSide;
			setAttr -l true ($crntMod + ".pair");
			//OPPOSITE NAME
			addAttr -ln "opposite" -dt "string" $crntMod;
			setAttr -e -k 1 ($crntMod + ".opposite");
		}
		if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.opposite") ($oppPrfx + $modName + "_Knee");
		}
		else
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.opposite") ($oppPrfx + $modName + "_Knee1");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.opposite") ($oppPrfx + $modName + "_Knee2");
		}
		
		for ($crntMod in $legMods)
		{
			setAttr -l true ($crntMod + ".opposite");
		}
		
		//COLORS
		setAttr ($crntMod + ".overrideEnabled") 1;
		setAttr ($crntMod + ".overrideColor") 31;
	}

	setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v")  0;
	setAttr ("RRM_" + $prfx + $modName + "_KneeAimLctr.v") 0;
}

global proc RRM_CreateProxyLeg(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $toon, int $mirrorMod, string $lPrfx, string $rPrfx)
{
	string $crntUnit = `currentUnit -query -linear`;

	
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	float $posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	float $rotOffset = -90;

	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 1;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 1)
		{
			$prfx = "";
			$prfx = "";
			$posOffset = 0;
			$rotOffset = 180; 
		}
			
		//ATTACH NODE
		RRM_CreateProxyParentProxy($crntUnit, $crntSide, ("RRM_" + $prfx + $modName + "_Parent"));
		rotate -r 0 0 $rotOffset ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "leg";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		addAttr -ln "upperTwistNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "lowerTwistNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "kneeNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "midTwistNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");

		//TEMPLATE ROLL JOINTS
		addAttr -ln "templateTwistJoints" -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.templateTwistJoints");

		//TOON ARMS
		addAttr -ln "toonLegs" -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -k 1 -l 1 ("RRM_" + $prfx + $modName + "_Parent.toonLegs");

		//HIP		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Hip"));
		curve -n ("RRM_" + $prfx + $modName + "_HipAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rotate -r 180 0 -90	("RRM_" + $prfx + $modName + "_HipAim");
		makeIdentity -apply true ("RRM_" + $prfx + $modName + "_HipAim");
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_HipAim")` ("RRM_" + $prfx + $modName + "_HipAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_HipAimShape") ("RRM_" + $prfx + $modName + "_Hip");
		delete ("RRM_" + $prfx + $modName + "_HipAim");
		group -n ("RRM_" + $prfx + $modName + "_HipGrp") ("RRM_" + $prfx + $modName + "_Hip"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_HipGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HipGrp");		
		move -r $posOffset -1 0 ("RRM_" + $prfx + $modName + "_HipGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HipGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.core") ($prfx + $modName + "_Hip");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Hip.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.ext") ("_Hip");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Hip.ext");

		//ANKLE
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Ankle"));		
		group -n ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Ankle"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_AnkleGrp");		
		move -r 0 1.5 0 ("RRM_" + $prfx + $modName + "_AnkleGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_AnkleGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.core") ($prfx + $modName + "_Ankle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ankle.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.ext") ("_Ankle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ankle.ext");

		//FOOT
		//FOOT GROUND
		circle -n ("RRM_" + $prfx + $modName + "_Ground") -nr 0 1 0 -r 3.25 -ch 0;
		group -n ("RRM_" + $prfx + $modName + "_GroundGrp") ("RRM_" + $prfx + $modName + "_Ground"); xform -os -piv 0 0 0; 
		scale -r .8 1 1 ("RRM_" + $prfx + $modName + "_GroundGrp");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_GroundGrp");
		move -r 0 0 2 ("RRM_" + $prfx + $modName + "_Ground.cv[0:7]");
		
		group -n ("RRM_" + $prfx + $modName + "_GroundGrp2") ("RRM_" + $prfx + $modName + "_GroundGrp"); xform -os -piv 0 0 0; 
		
		addAttr -ln "core" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Ground.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.core") ($prfx + $modName + "_Ground");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ground.core");
		
		addAttr -ln "ext" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Ground.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.ext") ("_Ground");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ground.ext");
		
		addAttr -ln "clone" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Ground.clone");

		addAttr -ln "modName" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Ground.modName");
		
		move -r 1.3 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[3]") ;
		move -r 0.2 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[2]") ("RRM_" + $prfx + $modName + "_GroundShape.cv[4]");
		move -r -1.3 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[7]") ;
		move -r -0.2 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[2]") ("RRM_" + $prfx + $modName + "_GroundShape.cv[4]");
		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Ball"));
		parent ("RRM_" + $prfx + $modName + "_Ball") ("RRM_" + $prfx + $modName + "_Ground");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Ball");		
		move -r 0 0 2.5 ("RRM_" + $prfx + $modName + "_Ball");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Ball");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.core") ($prfx + $modName + "_Ball");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ball.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.ext") ("_Ball");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ball.ext");

		RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Toe"));
		parent ("RRM_" + $prfx + $modName + "_Toe") ("RRM_" + $prfx + $modName + "_Ground");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Toe");		
		move -r 0 0 4 ("RRM_" + $prfx + $modName + "_Toe");
		rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_Toe");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Toe");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.core") ($prfx + $modName + "_Toe");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Toe.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.ext") ("_Toe");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Toe.ext");

		//FOOT CONTROLS
		curve -n ("RRM_" + $prfx + $modName + "_FootBankIn") -d 1 -p 0 0 -1 -p 0 0 1 -p 0 0 0 -p 1 0 0 -p -1 0 0 -p 0 0 0 -p 0 1 0 -p 0 -1 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_FootBankIn")` ("RRM_" + $prfx + $modName + "_FootBankInShape");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootBankInB");
		setAttr (("RRM_" + $prfx + $modName + "_FootBankInBShape.localScale"), .25, .25, .25);
		if ($crntUnit == "m")
		{
			setAttr (("RRM_" + $prfx + $modName + "_FootBankInBShape.localScale"), 0.0025, 0.0025, 0.0025);
		}
		
		parent -r -s ("RRM_" + $prfx + $modName + "_FootBankInBShape") ("RRM_" + $prfx + $modName + "_FootBankIn");
		delete ("RRM_" + $prfx + $modName + "_FootBankInB");

		parent ("RRM_" + $prfx + $modName + "_FootBankIn") ("RRM_" + $prfx + $modName + "_Ground");
		move -r ($multiplier * -1) 0 2.5 ("RRM_" + $prfx + $modName + "_FootBankIn");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_FootBankIn");
		
		addAttr -ln "core" -dt "string" ("RRM_" + $prfx + $modName + "_FootBankIn");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_FootBankIn.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankIn.core") ($prfx + $modName + "_FootBankIn");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootBankIn.core");
		
		addAttr -ln "ext" -dt "string" ("RRM_" + $prfx + $modName + "_FootBankIn");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_FootBankIn.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankIn.ext") ("_FootBankIn");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootBankIn.ext");
		
		addAttr -ln "clone" -dt "string" ("RRM_" + $prfx + $modName + "_FootBankIn");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_FootBankIn.clone");

		addAttr -ln "modName" -dt "string" ("RRM_" + $prfx + $modName + "_FootBankIn");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Ground.modName");

		duplicate -n ("RRM_" + $prfx + $modName + "_FootBankOut") ("RRM_" + $prfx + $modName + "_FootBankIn");
		select ("RRM_" + $prfx + $modName + "_FootBankOut");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_FootBankOutShape");
		move -r ($multiplier * 2) 0 0 ("RRM_" + $prfx + $modName + "_FootBankOut");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_FootBankOut");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_FootBankOut.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankOut.core") ($prfx + $modName + "_FootBankOut");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootBankOut.core");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_FootBankOut.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankOut.ext") ("_FootBankOut");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootBankOut.ext");

		duplicate -n ("RRM_" + $prfx + $modName + "_HeelPivot") ("RRM_" + $prfx + $modName + "_FootBankIn"); 
		select ("RRM_" + $prfx + $modName + "_HeelPivot");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_HeelPivotShape");
		move -r ($multiplier * 1) 0 -3 ("RRM_" + $prfx + $modName + "_HeelPivot");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HeelPivot");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_HeelPivot.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.core") ($prfx + $modName + "_HeelPivot");
		setAttr -l true ("RRM_" + $prfx + $modName + "_HeelPivot.core");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_HeelPivot.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.ext") ("_HeelPivot");
		setAttr -l true ("RRM_" + $prfx + $modName + "_HeelPivot.ext");

		//LOCK CHANNELS
		$footPivots = `ls ("RRM_" + $prfx + $modName + "_FootBankIn") ("RRM_" + $prfx + $modName + "_FootBankOut") ("RRM_" + $prfx + $modName + "_HeelPivot")`;
		string $crntControl;
		for ($crntControl in $footPivots)
		{
			setAttr -l 1 -k 0 ($crntControl + ".ty");
			setAttr -l 1 -k 0 ($crntControl + ".rx");
			setAttr -l 1 -k 0 ($crntControl + ".ry");
			setAttr -l 1 -k 0 ($crntControl + ".rz");
			setAttr -l 1 -k 0 ($crntControl + ".sx");
			setAttr -l 1 -k 0 ($crntControl + ".sy");
			setAttr -l 1 -k 0 ($crntControl + ".sz");
		}
		//CONNECT FOOT
		parent ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Ground");
		setAttr ("RRM_" + $prfx + $modName + "_AnkleGrp.ty") 0;
		
		RRM_CreateProxyLeg2($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $posOffset, $crntUnit);

		//ADD EXTRA ATTRIBUTES, CHANGE COLORS
		select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Hip")
		("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Ball")
		("RRM_" + $prfx + $modName + "_Toe") ("RRM_" + $prfx + $modName + "_FootBankIn")
		("RRM_" + $prfx + $modName + "_FootBankOut") ("RRM_" + $prfx + $modName + "_HeelPivot")
		("RRM_" + $prfx + $modName + "_Ground") ;

			
		$legMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $legMods)
		{
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair" -dt "string" $crntMod;
				setAttr -e -k 1 ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
				
				addAttr -ln "opposite" -dt "string" $crntMod;
				setAttr -e -k 1 ($crntMod + ".opposite");
			}

			//COLORS
			setAttr ($crntMod + ".overrideEnabled") 1;
			setAttr ($crntMod + ".overrideColor") 31;
		}
		
		if ($mirrorMod == 2)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.opposite") ($oppPrfx + $modName + "_Hip");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.opposite") ($oppPrfx + $modName + "_Ankle");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.opposite") ($oppPrfx + $modName + "_Ball");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.opposite") ($oppPrfx + $modName + "_Toe");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.opposite") ($oppPrfx + $modName + "_Ground");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankOut.opposite") ($oppPrfx + $modName + "_FootBankOut");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankIn.opposite") ($oppPrfx + $modName + "_FootBankIn");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.opposite") ($oppPrfx + $modName + "_HeelPivot");
	
			for ($crntMod in $legMods)
			{
				setAttr -l true ($crntMod + ".opposite");
			}
		}
		setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v") 0;
		setAttr ("RRM_" + $prfx + $modName + "_KneeAimLctr.v") 0;
		
		//ATTACH TO RIG
		int $mirrorCheck = 2;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		pointConstraint -skip y ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_GroundGrp");
		parentConstraint -mo RRM_MAIN ("RRM_" + $prfx + $modName + "_GroundGrp2");
		parent ("RRM_" + $prfx + $modName + "_GroundGrp2") ("RRM_" + $prfx + $modName + "_Parent");
		scale 1 1 1 ("RRM_" + $prfx + $modName + "_GroundGrp") ("RRM_" + $prfx + $modName + "_GroundGrp2");


		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$rotOffset = 90;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "leg";
	setAttr -l true ("RRM_" + $modName + ".top");
	
	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");
	
	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD UPPER LEG NUM ATTRIBUTE
	addAttr -ln "upperLegNum" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".upperLegNum");
	setAttr ("RRM_" + $modName + ".upperLegNum") $upperLegNum;
	setAttr -l true ("RRM_" + $modName + ".upperLegNum");
	
	//ADD LOWER LEG NUM ATTRIBUTE
	addAttr -ln "lowerLegNum" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".lowerLegNum");
	setAttr ("RRM_" + $modName + ".lowerLegNum") $lowerLegNum;
	setAttr -l true ("RRM_" + $modName + ".lowerLegNum");

	//ADD KNEE NUM ATTRIBUTE
	addAttr -ln "kneeNum" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".kneeNum");
	setAttr ("RRM_" + $modName + ".kneeNum") $kneeNum;
	setAttr -l true ("RRM_" + $modName + ".kneeNum");

	//ADD UPPER LEG NUM ATTRIBUTE
	addAttr -ln "kneeJoints" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".kneeJoints");
	setAttr ("RRM_" + $modName + ".kneeJoints") $kneeJoints;
	setAttr -l true ("RRM_" + $modName + ".kneeJoints");	

	//ADD TOON LEG ATTRIBUTE
	addAttr -ln "toonLegs" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".toonLegs");
	setAttr ("RRM_" + $modName + ".toonLegs") $toon;
	setAttr -l true ("RRM_" + $modName + ".toonLegs");
			
	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Parent")`)
		{select ("RRM_" + $lPrfx + $modName + "_Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modName + "_Parent")`)
		{select -add ("RRM_" + $rPrfx + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_LegPrompts(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $toon, int $mirrorMod)
{
	string $modName = `textField -q -text RRM_TextFieldLegName`;
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldLegName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this name. Please use a unique name\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyLeg($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $lPrfx, $rPrfx);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
					RRM_CreateProxyLeg($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $lPrfx, $rPrfx);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////Fk CHAINS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyFkChain2(string $modName, int $chainsNum, int $jointsNum, int $direction, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, int $enableIk, string $crntUnit, int $create)
{
	//SET Fk NUM'S IN PARENT NODE
	lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.chainNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.chainNum") $chainsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.chainNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jointNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.jointNum") $jointsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jointNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.direction");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.direction") $direction;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.direction");
	

	//SET Fk NUM'S IN TOP NODE
	lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $modName + ".chainsNum");
	setAttr ("RRM_" + $modName + ".chainsNum") $chainsNum;
	setAttr -l true ("RRM_" + $modName + ".chainsNum");

	setAttr -l false ("RRM_" + $modName + ".jointsNum");
	setAttr ("RRM_" + $modName + ".jointsNum") $jointsNum;
	setAttr -l true ("RRM_" + $modName + ".jointsNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.direction");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.direction") $direction;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.direction");
	
	//SET Ik ENABLED 
	setAttr -l false ("RRM_" + $modName + ".ikEnabled");
	setAttr ("RRM_" + $modName + ".ikEnabled") $enableIk;
	setAttr -l true ("RRM_" + $modName + ".ikEnabled");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.ikEnabled") $enableIk;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");	

	//CREATE ATTACH LOCATION
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[1]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[2]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[3]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_targetLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_targetLctr");
	
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[5]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[10]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[9]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[4]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_AimLctr");

	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[3]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[4]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[5]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_UpLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_UpLctr");

	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
	-worldUpObject ("RRM_" + $prfx + $modName + "_UpLctr") ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr")`;
	parent ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr");
	makeIdentity -apply false -r 1 -s 1 ("RRM_" + $prfx + $modName + "_targetLctr");
	$targetLoc = `getAttr ("RRM_" + $prfx + $modName + "_targetLctr.translate")`;
	setAttr ("RRM_" + $prfx + $modName + "_targetLctr.tx") ($targetLoc[0] * 3.1304347826087);
	parentConstraint -mo ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_AimLctr");
	
	//CREATE FIRST NODE
	if ($jointsNum != 1)
	{
		RRM_CreateProxyBaseUpProxy($crntUnit, ("RRM_" + $prfx + $modName + "_01_"));
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideColor") 9;
	}
	else
	{
		RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_01_"));
		rotate -r -os -90 0 0 ("RRM_" + $prfx + $modName + "_01_");
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideColor") 9;
	}
	parent ("RRM_" + $prfx + $modName + "_01_") ("RRM_" + $prfx + $modName + "_Grp");
	makeIdentity -apply 0 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_01_");
	delete `parentConstraint ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_Grp")`;
	//if ($crntSide == "right")
	//{
	//	$rY = `getAttr ("RRM_" + $prfx + $modName + "_Grp.ry")`;
	//	setAttr ("RRM_" + $prfx + $modName + "_Grp.ry") (180 + $rY);
	//}
	
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.core") ($prfx + $modName + "_01_");
	
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.ext") ("_01_");

	delete ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_UpLctr");

	RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_01_"));

	if ($mirrorMod ==1)
	{
		addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_01_");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_01_.pair");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.pair") $crntSide;
		setAttr -l true ("RRM_" + $prfx + $modName + "_01_.pair");
		
		addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_01_");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_01_.opposite");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.opposite") ($oppPrfx + $modName + "_01_");
	}
 
	//CHAINS
	int $crntChNum = 2;
	while ($crntChNum <= $chainsNum)
	{
		$previousMod = ($crntChNum -1);
		string $namePadding = "";
		if ($crntChNum < 10)
		{
			$namePadding = "0";
		}
		string $namePaddingPrev = "";
		if ($crntChNum < 11)
		{
			$namePaddingPrev = "0";
		}
		duplicate -n ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_") ("RRM_" + $prfx + $modName + "_" + $namePaddingPrev + $previousMod + "_");
		move -r -ls 0 0 ($multiplier * -0.75) ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_");
		
		if ($mirrorMod ==1)
		{
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.opposite") ($oppPrfx + $modName + "_" + $namePadding + $crntChNum + "_");			
		}
 
		setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.core");			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.core") ($prfx + $modName + "_" + $namePadding + $crntChNum + "_");
 
		setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.ext");			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.ext") ("_" + $namePadding + $crntChNum + "_");
		
		//CONNECTORS
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_"));

		$crntChNum++;
	}
	
	//FIX JOINT OFFSET
	spaceLocator -n ("RRM_" + $prfx + $modName + "_chainCenterLctr");
	$chainStart = `ls ("RRM_" + $prfx + $modName + "_??_")`;
	delete `pointConstraint $chainStart ("RRM_" + $prfx + $modName + "_chainCenterLctr")`;
	parent $chainStart ("RRM_" + $prfx + $modName + "_chainCenterLctr");
	delete `pointConstraint ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_chainCenterLctr")`;
	parent $chainStart ("RRM_" + $prfx + $modName + "_Grp");
	delete ("RRM_" + $prfx + $modName + "_chainCenterLctr");
	makeIdentity -apply 0 -s 1 $chainStart;
	makeIdentity -apply 1 -t 1 -r 1 -s 1 $chainStart;

 
	//JOINTS
	$chains = `listRelatives -ad -type "transform" ("RRM_" + $prfx + $modName + "_Grp")`;
	int $crntJntNum = 2;
 
	for ($crntJnt in $chains)
	{
		$crntJntNum = 2;
		while ($crntJntNum <= $jointsNum)
		{
			string $namePadding = "";
			string $prevPadding = "";
			$prevJntNum = ($crntJntNum - 1);
			//CHECK IF END NODE OR NOT
			if ($crntJntNum < 10)
			{
				$namePadding = "0";
			}
			if ($crntJntNum <= 10)
			{
				$prevPadding = "0";
			}
			if ($crntJntNum != $jointsNum)
			{
				if ($crntJntNum ==2)
				{
					duplicate -n ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
					move -r -ls 1 0 0 ($crntJnt + $namePadding + $crntJntNum);
					parent ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
				}
				else
				{
					duplicate -n ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
					move -r -ls 1 0 0 ($crntJnt + $namePadding + $crntJntNum);
					parent ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
				}
			}
			else
			{
				RRM_CreateProxyEndProxy($crntUnit, ($crntJnt + $namePadding + $crntJntNum));
				if ($crntSide == "left")
				{
					rotate -r 0 0 -90 ($crntJnt + $namePadding + $crntJntNum);
					makeIdentity -apply 1 -r 1 ($crntJnt + $namePadding + $crntJntNum);
				}
				else
				{
					rotate -r 0 0 -90 ($crntJnt + $namePadding + $crntJntNum);					
					makeIdentity -apply 1 -r 1 ($crntJnt + $namePadding + $crntJntNum);
				}
				if ($crntJntNum ==2)
				{
					parent ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
					delete `parentConstraint $crntJnt ($crntJnt + $namePadding + $crntJntNum)`;
				}
				else
				{
					parent ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
					delete `parentConstraint ($crntJnt + $prevPadding + $prevJntNum) ($crntJnt + $namePadding + $crntJntNum)`;
				}
				makeIdentity -apply 0 -s 1 ($crntJnt + $namePadding + $crntJntNum);
				if ($mirrorMod ==1)
				{
					addAttr -ln "pair" -dt "string" ($crntJnt + $namePadding + $crntJntNum);
					setAttr -e -k 1 ($crntJnt + $namePadding + $crntJntNum + ".pair");
					setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".pair") $crntSide;
					setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".pair");
					
					
					addAttr -ln "opposite" -dt "string" ($crntJnt + $namePadding + $crntJntNum);
					setAttr -e -k 1 ($crntJnt + $namePadding + $crntJntNum + ".opposite");
				}
				move -r -ls 1 0 0 ($crntJnt + $namePadding + $crntJntNum);
			}
			//ATTRIBUTES
			$coreName = `getAttr ($crntJnt + ".core")`;
			setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".core");
			setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".core") ($coreName + $namePadding + $crntJntNum);
			setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".core");

			$extName = `getAttr ($crntJnt + ".ext")`;
			setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".ext");
			setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".ext") ($extName + $namePadding + $crntJntNum);
			setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".ext");

			if ($mirrorMod == 1)
			{
				$oppositeName = `getAttr ($crntJnt + ".opposite")`;
				setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".opposite");
				setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".opposite") ($oppositeName + $namePadding + $crntJntNum);
				setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".opposite");
			}
			//CONNECTORS
			if ($crntJntNum == 2)
			{
				RRM_ProxyConnectors($modName, $prfx, $crntJnt, ($crntJnt + $namePadding + $crntJntNum));
			}
			else
			{
				RRM_ProxyConnectors($modName, $prfx, ($crntJnt + $prevPadding + $prevJntNum), ($crntJnt + $namePadding + $crntJntNum));
			}
			makeIdentity -apply 1 -t 1 -r 1 -s 1 ($crntJnt + $namePadding + $crntJntNum);
			
			$crntJntNum++;
		}
	}
 
	//RENAME 01 JOINTS
	$topJoints = `ls ("RRM_" + $prfx + $modName + "_??_")`;
	$previousJnt = ("RRM_" + $prfx + $modName + "_Parent_");
	$i =0;
	for ($crntJnt in $topJoints)
	{
		rename $crntJnt ($crntJnt + "01");

		$coreName = `getAttr ($crntJnt + "01.core")`;
		setAttr -type "string" ($crntJnt + "01.core") ($coreName + "01");
		setAttr -l true ($crntJnt + "01.core");

		$extName = `getAttr ($crntJnt + "01.ext")`;
		setAttr -type "string" ($crntJnt + "01.ext") ($extName + "01");
		setAttr -l true ($crntJnt + "01.ext");
		
		if ($mirrorMod == 1)
		{
			$oppositeName = `getAttr ($crntJnt + "01.opposite")`;
			setAttr -type "string" ($crntJnt + "01.opposite") ($oppositeName + "01");		
			setAttr -l true ($crntJnt + "01.opposite");
		}
	}
}

global proc RRM_CreateProxyFkChain(string $modName, int $chainsNum, int $jointsNum, int $modDirection, int $modDirection2, int $mirrorMod, int $enableIk, string $lPrfx, string $rPrfx)
{
	//SET UNITS TO CENTIMETERS
	string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//}
	if ($modDirection == 0)
	{
		$modDirection = ($modDirection2 + 3);
	}
	
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$rotOffset = 0;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	$create = 1;

	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	//Fk CHAIN
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppSide = "";
		}
		
		RRM_CreateProxyParentProxy($crntUnit, $crntSide, ("RRM_" + $prfx + $modName + "_Parent"));
		group -n ("RRM_" + $prfx + $modName + "_ParentGrp") ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_ParentGrp"); xform -os -piv 0 0 0;

		addAttr -ln "ikEnabled" -at bool ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.ikEnabled") $enableIk;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");
			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "fkChain";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		addAttr -ln "chainNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "jointNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "direction" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
	
		//CHECK IF MIRRORED
		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
	
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName);
			}
			
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");			
		}

		if (!`objExists ("RRM_" + $modName + ".chainsNum")`)
		{
			//ADD CHAIN NUM ATTRIBUTE	
			addAttr -ln "chainsNum" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".chainsNum");
			setAttr ("RRM_" + $modName + ".chainsNum") $chainsNum;
			setAttr -l true ("RRM_" + $modName + ".chainsNum");
		
			//ADD JOINT NUM ATTRIBUTE	
			addAttr -ln "jointsNum" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".jointsNum");
			setAttr ("RRM_" + $modName + ".jointsNum") $jointsNum;
			setAttr -l true ("RRM_" + $modName + ".jointsNum");
			
			//ADD Ik ENABLED ATTR
			addAttr -ln "ikEnabled" -at bool ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".ikEnabled");
			setAttr ("RRM_" + $modName + ".ikEnabled") $enableIk;
			setAttr -l true ("RRM_" + $modName + ".ikEnabled");
		}

		//X
		string $selectedMod;
		float $xValue = 0;
		rotate -r -90 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		
		//CREATE GROUPS
		group -em -n ("RRM_" + $prfx + $modName + "_Grp");
		parent ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_Parent");
		
		if ($crntSide == "left")
		{
			if ($modDirection == 1 || $modDirection == 4)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					if ($xValue < 0)
					{
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_ParentGrp");
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}
			}
			if ($modDirection == 4)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					
					if ($xValue >= 0)
					{
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_ParentGrp");
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}
			}
		}
		else if ($crntSide == "right")
		{
			if ($modDirection == 1)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					if ($xValue >= 0)
					{
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_ParentGrp");
						//rotate -r 0 -180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}

			}
			if ($modDirection == 4)
			{
				//CHECK LOCATION
				$xValue = 0;
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					
					if ($xValue < 0)
					{
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_ParentGrp");
						//rotate -r 0 -180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}
			}
		}
		//Y
		if ($modDirection == 2)
		{
			//setAttr (("RRM_" + $prfx + $modName + "_Parent.rotate"), -90, 0, 90);
			setAttr (("RRM_" + $prfx + $modName + "_ParentGrp.rotate"), -90, 0, 90);
			//setAttr (("RRM_" + $prfx + $modName + "_Grp.rotate"), -90, 0, 90);
		}
		if ($modDirection == 5)
		{
			//setAttr (("RRM_" + $prfx + $modName + "_Parent.rotate"), -90, 0, -90);
			setAttr (("RRM_" + $prfx + $modName + "_ParentGrp.rotate"), -90, 0, -90);
			//setAttr (("RRM_" + $prfx + $modName + "_Grp.rotate"), -90, 0, -90);
		}		
		//Z
		if ($modDirection == 3)
		{
			//rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
			rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_ParentGrp");
			//rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Grp");
		}
		if ($modDirection == 6)
		{
			//rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Parent");
			rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_ParentGrp");
			//rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Grp");
		}
		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			if ($mirrorMod == 1)
			{
				move -r ($multiplier * 1) 0 0 ("RRM_" + $prfx + $modName + "_Parent");
			}
		}

		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 9;
		
			
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		RRM_CreateProxyFkChain2($modName, $chainsNum, $jointsNum, $modDirection, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $enableIk, $crntUnit, $create);

		//PARENT CONNECTOR

		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");

		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$rotOffset = 180;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "fkChain";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE	
	addAttr -ln "core" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD DIRECTION ATTRIBUTE	
	addAttr -ln "direction" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".direction");
	setAttr ("RRM_" + $modName + ".direction") $modDirection;
	setAttr -l true ("RRM_" + $modName + ".direction");

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);
	

	select -cl;
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Parent")`)
		{
			select ("RRM_" + $lPrfx + $modName + "_Parent") ("RRM_" + $rPrfx + $modName + "_Parent");
		}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}


}

global proc RRM_FkChainPrompts(string $modName, int $chainsNum, int $jointsNum, int $enableIk, int $mirrorMod, int $modDirection, int $modDirection2)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	//else if (`objExists ($modName)`)
	//{
	//	string $returnVal_Generate = `confirmDialog
	//		-title "The Module's Name is not Unique"
	//		-message "A module already exists with that name.\nYou must create a unique name.\n"
	//		-button "OK"
	//		-defaultButton "OK"
	//		-cancelButton "OK"
	//		-icon "critical"`;
	//}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldFkChainName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this name. Please use a unique name\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$chainSize = ($chainsNum * $jointsNum * $mirrorMod);
						if ($chainSize <= 100)
						{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyFkChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIk, $lPrfx, $rPrfx);
						}
						else
						{
							string $returnVal_Generate2 = `confirmDialog
							-title "Large Number of proxies in module"
							-message "The Fk Chain you are about to create has over 100 proxies. This could take several minutes to generate. Proceed?\n"
							-button "OK" -button "Cancel"
							-defaultButton "OK"
							-cancelButton "Cancel"
							-icon "warning"`;
							
							if ($returnVal_Generate2 == "OK")
							{
								$lPrfx = `getAttr RRM_MAIN.lPrfx`;
								$rPrfx = `getAttr RRM_MAIN.rPrfx`;
								RRM_CreateProxyFkChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIk, $lPrfx, $rPrfx);
							}
						}
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					$chainSize = ($chainsNum * $jointsNum * $mirrorMod);
					if ($chainSize <= 100)
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyFkChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIk, $lPrfx, $rPrfx);
					}
					else
					{
						string $returnVal_Generate2 = `confirmDialog
						-title "Large Number of proxies in module"
						-message "The Fk Chain you are about to create has over 100 proxies. This could take several minutes to generate. Proceed?\n"
						-button "OK" -button "Cancel"
						-defaultButton "OK"
						-cancelButton "Cancel"
						-icon "warning"`;
						
						if ($returnVal_Generate2 == "OK")
						{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
							RRM_CreateProxyFkChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIk, $lPrfx, $rPrfx);
						}
					}
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////HEAD///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyHead(string $modName, int $RRM_Jaw, int $mirrorMod, string $lPrfx, string $rPrfx)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 1;
	$crntSide = "left";
	$oppSide = "right";
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$posOffset = 0;
		}
		
		if (`objExists ($attachMod[0] + (".opposite"))`)
		{
			$posOffset = 0;
		}
		
		RRM_CreateProxyParentProxy($crntUnit, $crntSide, ("RRM_" + $prfx + $modName + "_Parent"));
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "head";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		addAttr -ln "jaw" -at bool -dv $RRM_Jaw ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
		
		

		RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Top"));
		move -r 0 3 0 ("RRM_" + $prfx + $modName + "_Top");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.core") ($prfx + $modName + "_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.ext") ("_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.ext");
		
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Top"));
		
		if ($RRM_Jaw == 1)
		{
			RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Jaw"));
			move -r 0 1.5 0.25 ("RRM_" + $prfx + $modName + "_Jaw");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.core") ($prfx + $modName + "_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.core");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.ext") ("_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.ext");
		
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Jaw"));
			
			RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_JawEnd"));
			move -r 0 1 1.5 ("RRM_" + $prfx + $modName + "_JawEnd");
			rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_JawEnd");
			parent ("RRM_" + $prfx + $modName + "_JawEnd") ("RRM_" + $prfx + $modName + "_Jaw");
			parent ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_Parent");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.core") ($prfx + $modName + "_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.core");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.ext") ("_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.ext");

			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Jaw"), ("RRM_" + $prfx + $modName + "_JawEnd"));
		}
		
		parent ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
			
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			//MIRROR ATTRIBUTES
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");
				
			if ($RRM_Jaw == 1)
			{
				addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Jaw");
				setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Jaw.pair");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.pair") $crntSide;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.pair");
				
				addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Jaw");
				setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Jaw.opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.opposite") ($oppPrfx + $modName + "_Jaw");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.opposite");
  	
				addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_JawEnd");
				setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_JawEnd.pair");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.pair") $crntSide;
				setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.pair");
				
				addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_JawEnd");
				setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_JawEnd.opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.opposite") ($oppPrfx + $modName + "_JawEnd");
				setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.opposite");
			}
				
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Top.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.pair");
			
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Top.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.opposite") ($oppPrfx + $modName + "_Top");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.opposite");
		}
		//OFFSET FROM CENTER IF NOT ATTACHED TO PAIR		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			move -r $posOffset 0 0 ("RRM_" + $prfx + $modName + "_Parent");
		}
				
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		//ASSIGN COLORS
		select ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");
		if ($RRM_Jaw == 1)
		{
			select -add ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_JawEnd");
		}
		$headProxies = `ls -sl`;
		string $crntHead;
		for ($crntHead in $headProxies)
		{
			setAttr ($crntHead + ".overrideEnabled") 1;
			setAttr ($crntHead + ".overrideColor") 4;
		}
		select ("RRM_" + $prfx + $modName + "_Parent");
		
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -1;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "head";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD JAW ATTRIBUTE
	addAttr -ln "jaw" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".jaw");
	setAttr ("RRM_" + $modName + ".jaw") $RRM_Jaw;
	setAttr -l true ("RRM_" + $modName + ".jaw");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Parent")`)
		{select ("RRM_" + $lPrfx + $modName + "_Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modName + "_Parent")`)
		{select -add ("RRM_" + $rPrfx + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_HeadPrompts(string $modName, int $RRM_Jaw, int $mirrorMod)
{
	string $modName = `textField -q -text RRM_TextFieldHeadName`;
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
		
		-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldHeadName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyHead($modName, $RRM_Jaw, $mirrorMod, $lPrfx, $rPrfx);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
					RRM_CreateProxyHead($modName, $RRM_Jaw, $mirrorMod, $lPrfx, $rPrfx);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////LOOK AT///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyLookAt2(string $modName, int $jointsNum, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit)
{
	//SET EYE NUM IN PARENT NODE
	lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.eyeNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.eyeNum") $jointsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.eyeNum");

	lockNode -l off ("RRM_" + $modName);

	setAttr -l false ("RRM_" + $modName + ".eyeNum");
	setAttr ("RRM_" + $modName + ".eyeNum") $jointsNum;
	setAttr -l true ("RRM_" + $modName + ".eyeNum");
	

	//CREATE ATTACH LOCATION
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[1]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[2]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[3]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_targetLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_targetLctr");
	
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[5]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[10]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[9]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_Parent_1Shape.cv[4]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_AimLctr");
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
	-worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr")`;
	parent ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr");
	makeIdentity -apply false -r 1 ("RRM_" + $prfx + $modName + "_targetLctr");
	$targetLoc = `getAttr ("RRM_" + $prfx + $modName + "_targetLctr.translate")`;
	setAttr ("RRM_" + $prfx + $modName + "_targetLctr.tx") ($targetLoc[0] * 1.65);
	parentConstraint -mo ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_AimLctr");
	
	//CREATE FIRST NODE
	RRM_CreateProxyBaseUpProxy($crntUnit, ("RRM_" + $prfx + $modName + "_01"));
	scale -r 3 3.2 3 ("RRM_" + $prfx + $modName + "_01_5Shape.cv[1]") ("RRM_" + $prfx + $modName + "_01_6Shape.cv[0:2]")
	("RRM_" + $prfx + $modName + "_01_7Shape.cv[0:2]") ("RRM_" + $prfx + $modName + "_01_8Shape.cv[0:7]");
	
	move -r -os -wd 0 8 0 ("RRM_" + $prfx + $modName + "_01_5Shape.cv[1]") ("RRM_" + $prfx + $modName + "_01_6Shape.cv[0:2]")
	("RRM_" + $prfx + $modName + "_01_7Shape.cv[0:2]") ("RRM_" + $prfx + $modName + "_01_8Shape.cv[0:7]");
	move -r 0 1 0 ("RRM_" + $prfx + $modName + "_01");
	rotate -r -os 0 0 -90 ("RRM_" + $prfx + $modName + "_01");
	makeIdentity -apply true -t 1-r 1 ("RRM_" + $prfx + $modName + "_01");
 
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.core") ($prfx + $modName + "_01");
	setAttr -l true ("RRM_" + $prfx + $modName + "_01.core");
 
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.ext") ("_01");
	setAttr -l true ("RRM_" + $prfx + $modName + "_01.ext");
	
	RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_01"));

	if ($mirrorMod ==1)
	{
		//MIRROR ATTRIBUTES
		addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_01");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_01.pair");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.pair") $crntSide;
		setAttr -l true ("RRM_" + $prfx + $modName + "_01.pair");
		
		addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_01");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_01.opposite");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.opposite") ($oppPrfx + $modName + "_01");
		setAttr -l true ("RRM_" + $prfx + $modName + "_01.opposite");
	}
	group -n ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_01"); xform -os -piv 0 0 0;
	
	if ($jointsNum > 1)
	{
		//JOINTS
		int $crntjointNum = 2;
		while ($crntjointNum <= $jointsNum)
		{
			$previousMod = ($crntjointNum -1);
			string $namePadding = "";
			if ($crntjointNum < 10)
			{
				$namePadding = "0";
			}
			string $namePaddingPrev = "";
			if ($crntjointNum < 11)
			{
				$namePaddingPrev = "0";
			}
			duplicate -n ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum) ("RRM_" + $prfx + $modName + "_" + $namePaddingPrev + $previousMod);
			move -r -ls 0 0 -0.75 ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum);
			
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core") ($prfx + $modName + "_" + $namePadding + $crntjointNum);
			setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core");
			
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext") ("_" + $namePadding + $crntjointNum);
			setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext");
		
			if ($mirrorMod ==1)
			{
				setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite") ($oppPrfx + $modName + "_" + $namePadding + $crntjointNum);			
				setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite");
			}
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum));

			$crntjointNum++;
		}
	}
	//FIX JOINT OFFSET
	spaceLocator -n ("RRM_" + $prfx + $modName + "_CenterLctr");
	$lookAts = `ls ("RRM_" + $prfx + $modName + "_??")`;
	delete `pointConstraint $lookAts ("RRM_" + $prfx + $modName + "_CenterLctr")`;
	parent $lookAts ("RRM_" + $prfx + $modName + "_CenterLctr");
	delete `pointConstraint ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_CenterLctr")`;
	parent $lookAts ("RRM_" + $prfx + $modName + "_Grp");
	delete `parentConstraint ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_Grp")`;
	parent ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_Parent");
	makeIdentity -apply true -t 1 -r 1 ("RRM_" + $prfx + $modName + "_Grp");
	setAttr (("RRM_" + $prfx + $modName + "_Grp.scale"), 1, 1, 1);

	delete ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_CenterLctr");
}


global proc RRM_CreateProxyLookAt(string $modName, int $jointsNum, int $modDirection, int $modDirection2, int $mirrorMod, string $lPrfx, string $rPrfx)
{
	string $crntUnit = `currentUnit -query -linear`;


	if ($modDirection == 0)
	{
		$modDirection = ($modDirection2 + 3);
	}

	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		
		RRM_CreateProxyParentProxy($crntUnit, $crntSide, ("RRM_" + $prfx + $modName + "_Parent"));
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "lookAt";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		addAttr -ln "eyeNum" -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");

			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			
			//MIRROR ATTRIBUTES
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");		
		}
			
		if (!`objExists ("RRM_" + $modName + ".eyeNum")`)
		{
			//ADD EYE NUM ATTRIBUTE
			addAttr -ln "eyeNum" -at long ("RRM_" + $modName);
			setAttr -e -k 1 ("RRM_" + $modName + ".eyeNum");
			setAttr ("RRM_" + $modName + ".eyeNum") $jointsNum;
			setAttr -l true ("RRM_" + $modName + ".eyeNum");
		}

		//X
		string $selectedMod;
		float $xValue = 0;
		rotate -r ($multiplier * -90) -90 0 ("RRM_" + $prfx + $modName);
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName);
		if ($modDirection == 1)
		{
			//CHECK LOCATION
			for ($selectedMod in $attachMod)
			{
			 $modTX = `xform -q -ws -rp $selectedMod`;
			 $xValue = ($xValue + $modTX[0]);
			}
			if ($xValue < 0)
			{
				rotate -r 0 ($multiplier * 180) 0 ("RRM_" + $prfx + $modName);
			}
		}
		if ($modDirection == 4)
		{
			//CHECK LOCATION
			$xValue = 0;
			for ($selectedMod in $attachMod)
			{
			 $modTX = `xform -q -ws -rp $selectedMod`;
			 $xValue = ($xValue + $modTX[0]);
			}
			if ($xValue >= 0)
			{
				rotate -r 0 ($multiplier * 180) 0 ("RRM_" + $prfx + $modName);
			}
		}
		//Y
		if ($modDirection == 2)
		{
			rotate -r -90 0 ($multiplier * 90) ("RRM_" + $prfx + $modName);
		}
		if ($modDirection == 5)
		{
			rotate -r 90 0 ($multiplier * -90) ("RRM_" + $prfx + $modName);
		}		
		//Z
		if ($modDirection == 3)
		{
			rotate -r 0 ($multiplier * -90) 0 ("RRM_" + $prfx + $modName);
		}
		if ($modDirection == 6)
		{
			rotate -r 0 ($multiplier * 90) 0 ("RRM_" + $prfx + $modName);
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName);
		
		//OFFSET FROM CENTER IF NOT ATTACHED TO PAIR		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			if ($mirrorMod == 1)
			{
				move -r ($multiplier * 1) 0 0 ("RRM_" + $prfx + $modName + "_Parent");
			}
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
				
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 30;
		
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
		
		RRM_CreateProxyLookAt2($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

	
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "lookAt";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");

	//ADD DIRECTION ATTRIBUTE	
	addAttr -ln "direction" -at long ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".direction");
	setAttr ("RRM_" + $modName + ".direction") $modDirection;
	setAttr -l true ("RRM_" + $modName + ".direction");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Parent")`)
		{select ("RRM_" + $lPrfx + $modName + "_Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modName + "_Parent")`)
		{select -add ("RRM_" + $rPrfx + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_LookAtPrompts(string $modName, int $jointsNum, int $mirrorMod, int $modDirection, int $modDirection2)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text textFieldLookAtModName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyLookAt($modName, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $lPrfx, $rPrfx);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
					RRM_CreateProxyLookAt($modName, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $lPrfx, $rPrfx);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////Auxiliary///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyAuxiliary(string $modName, int $mirrorMod, string $lPrfx, string $rPrfx)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		
		//GET OPPOSITE ATTACHMENT
		//if ($i == 1)
		//{
		//	if (`objExists ($attachMod[0] + ".opposite")`)
		//	{
		//		$oppAttach = `getAttr ($attachMod[0] + ".opposite")`;
		//		$attachMod[0] = ("RRM_" + $oppAttach);
		//		$attachModCore = `getAttr ($attachMod[0] + ".core")`;
		//	}
		//}
		
		RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Aux"));
		scale -r 1.5 1.5 1.5 ("RRM_" + $prfx + $modName + "_Aux");
		makeIdentity -apply true -s 1 ("RRM_" + $prfx + $modName + "_Aux");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Aux"); xform -os -piv 0 0 0;
		
		addAttr -ln "modType" -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.modType") "auxiliary";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.modType");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.core") ($prfx + $modName + "_Aux");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.core");

		addAttr -ln "attachNode" -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Aux.attachNode");
		
		//CREATE COLORED AXES CURVES
		curve -n ("RRM_" + $prfx + $modName + "_Aux_X") -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Aux_XShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_XShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_XShape.overrideColor") 13;
		
		curve -n ("RRM_" + $prfx + $modName + "_Aux_Y") -d 1 -p 0 0 0 -p 0 1 0 -k 0 -k 1 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Aux_Y")` ("RRM_" + $prfx + $modName + "_Aux_YShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_YShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_YShape.overrideColor") 14;
		
		curve -n ("RRM_" + $prfx + $modName + "_Aux_Z") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Aux_Z")` ("RRM_" + $prfx + $modName + "_Aux_ZShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_ZShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_ZShape.overrideColor") 6;
		
		parent -r -s ("RRM_" + $prfx + $modName + "_Aux_XShape") ("RRM_" + $prfx + $modName + "_Aux_YShape") ("RRM_" + $prfx + $modName + "_Aux_ZShape")("RRM_" + $prfx + $modName + "_Aux");
		delete ("RRM_" + $prfx + $modName + "_Aux_X") ("RRM_" + $prfx + $modName + "_Aux_Y") ("RRM_" + $prfx + $modName + "_Aux_Z");

		if ($crntSide == "right")
		{
			//ADD MIRROR BEHAVIOR ATTRIBUTE
			addAttr -ln "mirrorType" -at "enum" -en "Behavior:Orientation:" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Aux.mirrorType");
		}

		//ADD PINNED ATTRIBUTE
		addAttr -ln "pinned" -at bool ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
		setAttr ("RRM_" + $prfx + $modName + "_Aux.pinned") 0;
		setAttr -l 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
		
		//ADD CONNECTOR VIZ ATTRIBUTE
		addAttr -ln "connectors" -at bool ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Aux.connectors");
		setAttr ("RRM_" + $prfx + $modName + "_Aux.connectors") 1;

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair" -dt "string" ("RRM_" + $modName);
				setAttr -e -k 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");

			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			
			//MIRROR ATTRIBUTES
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair" -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Aux.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.pair");
			
			addAttr -ln "opposite" -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e -k 1 ("RRM_" + $prfx + $modName + "_Aux.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.opposite") ($oppPrfx + $modName + "_Aux");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.opposite");		
		}
		
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($modName, $attachMod[0], $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
		
		
		//makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
				
		setAttr ("RRM_" + $prfx + $modName + "_Aux.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux.overrideColor") 24;
		
		//RRM_CreateProxyLookAt2($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

	
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Aux"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "auxiliary";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core" -dt "string" ("RRM_" + $modName);
	setAttr -e -k 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	
	if (`objExists ("RRM_" + $lPrfx + $modName + "_Aux")`)
	{
		move -r 1 0 0 ("RRM_" + $lPrfx + $modName + "_Aux");
		move -r -1 0 0 ("RRM_" + $rPrfx + $modName + "_Aux");
		select ("RRM_" + $lPrfx + $modName + "_Aux") ("RRM_" + $rPrfx + $modName + "_Aux");
	}
	else if (`objExists ("RRM_" + $modName + "_Aux")`)
		{select ("RRM_" + $modName + "_Aux");}
}

global proc RRM_AuxiliaryPrompts(string $modName, int $mirrorMod)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text textFieldAuxiliaryModName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
						RRM_CreateProxyAuxiliary($modName, $mirrorMod, $lPrfx, $rPrfx);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
						$lPrfx = "l_";
						$rPrfx = "r_";
						if (`objExists RRM_MAIN.lPrfx`)
						{
							$lPrfx = `getAttr RRM_MAIN.lPrfx`;
							$rPrfx = `getAttr RRM_MAIN.rPrfx`;
						}
					RRM_CreateProxyAuxiliary($modName, $mirrorMod, $lPrfx, $rPrfx);
				}
			}
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////TAB 2 FUNCTIONALITY///////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLoadParent(string $parent)
{
	$crnt = `ls -sl`;
	if (`size $crnt` == 1)
	{
		$each = $crnt[0];
		if (`objExists ($each + ".modName")`)
		{
			string $modName = `getAttr ($each + ".modName")`;
			string $modType = `getAttr ("RRM_" + $modName + ".top")`;
			if ($modType == $parent)
			{
				textFieldButtonGrp -e -text $modName ("RRM_EditLoad" + $parent + "TextField");
				select $crnt[0];
			}
			else
			{
				warning ("Selected proxy node is not a \"" + $parent + "\"");
			}
		}
		else
		{
			warning "Please select a valid proxy node to load";
		}
	}
	else if (`size $crnt` == 0)
	{
		warning "Please select a proxy node to load";
	}
	else
	{
		warning "Please select only one node. Mirrored parents will automatically be connected properly";
	}
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY SPLINE MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditSpline()
{
	string $crntUnit = `currentUnit -query -linear`;

	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//VERIFY VALID PARENT NODE
	$modName = `textFieldButtonGrp -q -text RRM_EditLoadsplineTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "Invalid module name in text field";
	}
		
	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $splineNum = `intSliderGrp -q -v RRM_SplineEditNum`;
	int $twistAxis = `radioButtonGrp -q -select RRM_SplineEditTwistAxis`;
	$twistAxis = ($twistAxis - 1);
	$mirrorMod = 0;
	$prfx = "";
	$oppPrfx = "";
	$i = 0;
	
	
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 1;


		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $lPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $lPrfx + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_" + $rPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $rPrfx + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;
		
		select $connectors ("RRM_?_" + $modName + "_??Grp");
	}
	else
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentConnector") ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;
		
		select $connectors ("RRM_" + $modName + "_??Grp");
	}
	
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	float $tmpPos[];
	float $tmpRot[];
	vector $tmpPosVec;
	vector $tmpRotVec;
	
	vector $lPos[];
	vector $lRot[];
	vector $rPos[];
	vector $rRot[];
	int $proxCount = 1;
	for ($prox in `ls ("RRM_" + $prfx + $modName + "_??")`)
	{
		$tmpPos = `getAttr ($prox + ".translate")`;
		$tmpRot = `getAttr ($prox + ".rotate")`;
		$lPos[$proxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
		$lRot[$proxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
		$proxCount++;
	}
	
	$mirrorProxCount = 1;
	if ($mirrorMod == 1)
	{
		for ($prox in `ls ("RRM_" + $oppPrfx + $modName + "_??")`)
		{
			$tmpPos = `getAttr ($prox + ".translate")`;
			$tmpRot = `getAttr ($prox + ".rotate")`;
			$rPos[$mirrorProxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
			$rRot[$mirrorProxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
			$mirrorProxCount++;
		}
	}

	//DELETE OLD SPLINE NODES
	$splineJntGrp = `ls -sl`;
	select -hi $splineJntGrp;
	$allSplineJntGrp = `ls -sl`;
	lockNode -l off $allSplineJntGrp;
	delete $splineJntGrp;
	
	//REBUILD SPLINE NODES
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxySpline2($modName, $mirrorMod, $prfx, $oppPrfx, $splineNum, $twistAxis, $crntUnit);
		
		
		//REAPPLY TRANSFORMS TO NEW PROXIES
		$proxCount2 = 1;
		$nPad = "_0";
		while ($proxCount2 <= $proxCount)
		{
			if ($proxCount2 == 10)
			{
				$nPad = "_";
			}
			if (`objExists ("RRM_" + $prfx + $modName + $nPad + $proxCount2)`)
			{
				$tmpPosVec = $lPos[$proxCount2];
				$tmpRotVec = $lRot[$proxCount2];
				if ($mirrorMod == 1 && $i == 1)
				{
					$tmpPosVec = $rPos[$proxCount2];
					$tmpRotVec = $rRot[$proxCount2];
				}
				
				setAttr (("RRM_" + $prfx + $modName + $nPad + $proxCount2 + ".translate"), $tmpPosVec.x, $tmpPosVec.y, $tmpPosVec.z);
				setAttr (("RRM_" + $prfx + $modName + $nPad + $proxCount2 + ".rotate"), $tmpRotVec.x, $tmpRotVec.y, $tmpRotVec.z); 
			}
			$proxCount2++;
		}
		
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$i++;
	}

	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l on $lockNodes;

	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditArm()
{
	string $crntUnit = `currentUnit -query -linear`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadarmTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "Invalid module name in text field";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $upperArmNum = `intSliderGrp -q -v upperArmModEditNum`;
	int $lowerArmNum = `intSliderGrp -q -v forearmModEditNum`;
	int $elbowNum = `intSliderGrp -q -v RRM_ElbowEditNum`;
	int $elbowJoints = `radioButtonGrp -q -select RRM_ElbowEditJoints`;
	int $toon = `checkBox -q -v RRM_ToonArmEditCheckBox`;
	int $mirrorMod = 1;
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	//CHANGE ATTRIBUTES
	lockNode -l 0 ("RRM_" + $modName);
	setAttr -l 0 ("RRM_" + $modName + ".upperArmNum");
	setAttr ("RRM_" + $modName + ".upperArmNum") $upperArmNum;
	setAttr -l 1 ("RRM_" + $modName + ".upperArmNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".lowerArmNum");
	setAttr ("RRM_" + $modName + ".lowerArmNum") $lowerArmNum;
	setAttr -l 1 ("RRM_" + $modName + ".lowerArmNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".elbowNum");
	setAttr ("RRM_" + $modName + ".elbowNum") $elbowNum;
	setAttr -l 1 ("RRM_" + $modName + ".elbowNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".elbowJoints");
	setAttr ("RRM_" + $modName + ".elbowJoints") $elbowJoints;
	setAttr -l 1 ("RRM_" + $modName + ".elbowJoints");
	
	setAttr -l 0 ("RRM_" + $modName + ".toonArms");
	setAttr ("RRM_" + $modName + ".toonArms") $toon;
	setAttr -l 1 ("RRM_" + $modName + ".toonArms");
	
	lockNode -l 1 ("RRM_" + $modName);

	$i = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $lPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $lPrfx + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_" + $rPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $rPrfx + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $lPrfx + $modName + "_ElbowGrp")`)
		{
			select ("RRM_" + $lPrfx + $modName + "_ElbowGrp") ("RRM_" + $rPrfx + $modName + "_ElbowGrp")
			("RRM_" + $lPrfx + $modName + "_AimLctr") ("RRM_" + $rPrfx + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $lPrfx + $modName + "_Elbow1Grp") ("RRM_" + $lPrfx + $modName + "_Elbow2Grp")
			("RRM_" + $lPrfx + $modName + "_Elbow2AimLctr") ("RRM_" + $lPrfx + $modName + "_AimLctr")
			("RRM_" + $rPrfx + $modName + "_Elbow1Grp") ("RRM_" + $rPrfx + $modName + "_Elbow2Grp")
			("RRM_" + $rPrfx + $modName + "_Elbow2AimLctr") ("RRM_" + $rPrfx + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $lPrfx + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $lPrfx + $modName + "_Upper*") ("RRM_" + $rPrfx + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $lPrfx + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $lPrfx + $modName + "_Middle*") ("RRM_" + $rPrfx + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $lPrfx + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $lPrfx + $modName + "_Lower*") ("RRM_" + $rPrfx + $modName + "_Lower*");
		}
		select -add $connectors;		
		$mirrorMod = 2;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentConnector") ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $modName + "_ElbowGrp")`)
		{
			select ("RRM_" + $modName + "_ElbowGrp") ("RRM_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $modName + "_Elbow1Grp") ("RRM_" + $modName + "_Elbow2Grp")
			("RRM_" + $modName + "_Elbow2AimLctr") ("RRM_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $modName + "_Lower*");
		}
		select -add $connectors;
	}
	
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	//ELBOW
	float $lElbowPos[];
	float $rElbowPos[];
	
	float $lElbow1Pos[];
	float $lElbow2Pos[];
	
	float $rElbow1Pos[];
	float $rElbow2Pos[];
	
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		$lElbowPos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.translate")`;
	}
	else
	{
		$lElbow1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.translate")`;
		$lElbow2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.translate")`;
	}
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $oppPrfx + $modName + "_Elbow")`)
		{
			$rElbowPos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Elbow.translate")`;
		}
		else
		{
			$rElbow1Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Elbow1.translate")`;
			$rElbow2Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Elbow2.translate")`;
		}
	}
	

	//DELETE OLD ARM NODES
	$elbowNodes = `ls -sl`;
	select -hi $elbowNodes;
	$allElbowNodes = `ls -sl`;
	lockNode -l off $allElbowNodes;
	delete $allElbowNodes;
	
	//REBUILD ARM NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyArm2($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);
		
		//REAPPLY TRANSFORMS TO NEW PROXIES
		if ($i == 1)
		{
			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow.translate"), $lElbowPos[0], $lElbowPos[1], $lElbowPos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow1.translate"), $lElbow1Pos[0], $lElbow1Pos[1], $lElbow1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Elbow2.translate"), $lElbow2Pos[0], $lElbow2Pos[1], $lElbow2Pos[2]);
			}
		}
		else if ($mirrorMod == 2 && $i == 2)
		{
			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow.translate"), $rElbowPos[0], $rElbowPos[1], $rElbowPos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow1.translate"), $rElbow1Pos[0], $rElbow1Pos[1], $rElbow1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Elbow2.translate"), $rElbow2Pos[0], $rElbow2Pos[1], $rElbow2Pos[2]);
			}		
		}
		

		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$i++;
	}
	
	
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY LEG MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLeg()
{
	string $crntUnit = `currentUnit -query -linear`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadlegTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "Invalid module name in text field";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $upperLegNum = `intSliderGrp -q -v upperLegModEditNum`;
	int $lowerLegNum = `intSliderGrp -q -v lowerLegModEditNum`;
	int $kneeNum = `intSliderGrp -q -v RRM_KneeEditNum`;
	int $kneeJoints = `radioButtonGrp -q -select RRM_KneeEditJoints`;
	int $toon = `checkBox -q -v RRM_ToonLegEditCheckBox`;
	int $mirrorMod = 1;
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$posOffset = 2;
	
	$i = 1;
	
	//CHANGE ATTRIBUTES
	lockNode -l 0 ("RRM_" + $modName);
	setAttr -l 0 ("RRM_" + $modName + ".upperLegNum");
	setAttr ("RRM_" + $modName + ".upperLegNum") $upperLegNum;
	setAttr -l 1 ("RRM_" + $modName + ".upperLegNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".lowerLegNum");
	setAttr ("RRM_" + $modName + ".lowerLegNum") $lowerLegNum;
	setAttr -l 1 ("RRM_" + $modName + ".lowerLegNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".kneeNum");
	setAttr ("RRM_" + $modName + ".kneeNum") $kneeNum;
	setAttr -l 1 ("RRM_" + $modName + ".kneeNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".kneeJoints");
	setAttr ("RRM_" + $modName + ".kneeJoints") $kneeJoints;
	setAttr -l 1 ("RRM_" + $modName + ".kneeJoints");
	lockNode -l 1 ("RRM_" + $modName);
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $lPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $lPrfx + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_" + $rPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $rPrfx + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $lPrfx + $modName + "_KneeGrp")`)
		{
			select ("RRM_" + $lPrfx + $modName + "_KneeGrp") ("RRM_" + $rPrfx + $modName + "_KneeGrp")
			("RRM_" + $lPrfx + $modName + "_AimLctr") ("RRM_" + $rPrfx + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $lPrfx + $modName + "_Knee1Grp") ("RRM_" + $lPrfx + $modName + "_Knee2Grp")
			("RRM_" + $lPrfx + $modName + "_Knee2AimLctr") ("RRM_" + $lPrfx + $modName + "_AimLctr")
			("RRM_" + $rPrfx + $modName + "_Knee1Grp") ("RRM_" + $rPrfx + $modName + "_Knee2Grp")
			("RRM_" + $rPrfx + $modName + "_Knee2AimLctr") ("RRM_" + $rPrfx + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $lPrfx + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $lPrfx + $modName + "_Upper*") ("RRM_" + $rPrfx + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $lPrfx + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $lPrfx + $modName + "_Middle*") ("RRM_" + $rPrfx + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $lPrfx + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $lPrfx + $modName + "_Lower*") ("RRM_" + $rPrfx + $modName + "_Lower*");
		}
		select -add $connectors;
		$mirrorMod = 2;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentConnector") ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $modName + "_KneeGrp")`)
		{
			select ("RRM_" + $modName + "_KneeGrp") ("RRM_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $modName + "_Knee1Grp") ("RRM_" + $modName + "_Knee2Grp")
			("RRM_" + $modName + "_Knee2AimLctr") ("RRM_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $modName + "_Lower*");
		}
		select -add $connectors;
	}
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	//KNEE
	float $lKneePos[];
	float $rKneePos[];
	
	float $lKnee1Pos[];
	float $lKnee2Pos[];
	
	float $rKnee1Pos[];
	float $rKnee2Pos[];
	
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		$lKneePos = `getAttr ("RRM_" + $prfx + $modName + "_Knee.translate")`;
	}
	else
	{
		$lKnee1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.translate")`;
		$lKnee2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.translate")`;
	}
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $oppPrfx + $modName + "_Knee")`)
		{
			$rKneePos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Knee.translate")`;
		}
		else
		{
			$rKnee1Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Knee1.translate")`;
			$rKnee2Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Knee2.translate")`;
		}
	}

	//DELETE OLD LEG NODES
	$kneeNodes = `ls -sl`;
	select -hi $kneeNodes;
	$allKneeNodes = `ls -sl`;
	lockNode -l off $allKneeNodes;
	delete $kneeNodes;
		
	//REBUILD LEG NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyLeg2($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $posOffset, $crntUnit);
		
		//REAPPLY TRANSFORMS TO NEW PROXIES
		if ($i == 1)
		{
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee.translate"), $lKneePos[0], $lKneePos[1], $lKneePos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee1.translate"), $lKnee1Pos[0], $lKnee1Pos[1], $lKnee1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Knee2.translate"), $lKnee2Pos[0], $lKnee2Pos[1], $lKnee2Pos[2]);
			}
		}
		else if ($mirrorMod == 2 && $i == 2)
		{
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee.translate"), $rKneePos[0], $rKneePos[1], $rKneePos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee1.translate"), $rKnee1Pos[0], $rKnee1Pos[1], $rKnee1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Knee2.translate"), $rKnee2Pos[0], $rKnee2Pos[1], $rKnee2Pos[2]);
			}		
		}


		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$posOffset = -2;
		$i++;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				select $finalSelect $each;
				$finalSelect = `ls -sl`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY Fk CHAIN MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditFkChain()
{
	string $crntUnit = `currentUnit -query -linear`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadfkChainTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "Invalid module name in text field";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $chainsNum = `intSliderGrp -q -v fkChainModEditChains`;
	int $jointsNum = `intSliderGrp -q -v fkChainModEditJointsPerChain`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $mirrorMod = 0;
	int $enableIk = `checkBox -q -v fkChainModEditIk`;
	
	
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$rotOffset = 0;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	$i=0;
	int $create = 0;

	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $lPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $lPrfx + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_" + $rPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $rPrfx + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select `listRelatives -ad ("RRM_" + $lPrfx + $modName + "_Grp") ("RRM_" + $rPrfx + $modName + "_Grp")` $connectors;
		$mirrorMod = 1;
	}
	else
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentConnector") ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		$prfx = "";
		$oppPrfx = "";
		select `listRelatives -ad ("RRM_" + $modName + "_Grp")` $connectors;
	}
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	string $fkProx[];
	float $tmpPos[];
	float $tmpRot[];
	float $tmpScl[];
	vector $tmpPosVec;
	vector $tmpRotVec;
	vector $tmpSclVec;
	
	vector $pos[];
	vector $rot[];
	vector $scl[];
	int $proxCount = 0;
	for ($prox in `ls ("RRM_" + $prfx + $modName + "_??_??")`)
	{
		$fkProx[$proxCount] = $prox;
		$tmpPos = `getAttr ($prox + ".translate")`;
		$tmpRot = `getAttr ($prox + ".rotate")`;
		$tmpScl = `getAttr ($prox + ".scale")`;
		$pos[$proxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
		$rot[$proxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
		$scl[$proxCount] = <<$tmpScl[0], $tmpScl[1], $tmpScl[2]>>;
		
		$proxCount++;
	}
	
	if ($mirrorMod == 1)
	{
		for ($prox in `ls ("RRM_" + $oppPrfx + $modName + "_??_??")`)
		{
			$fkProx[$proxCount] = $prox;
			$tmpPos = `getAttr ($prox + ".translate")`;
			$tmpRot = `getAttr ($prox + ".rotate")`;
			$tmpScl = `getAttr ($prox + ".scale")`;
			$pos[$proxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
			$rot[$proxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
			$scl[$proxCount] = <<$tmpScl[0], $tmpScl[1], $tmpScl[2]>>;
			$proxCount++;
		}
	}
	
	
	//DELETE OLD Fk NODES
	$fkNodes = `ls -sl`;
	select -hi $fkNodes;
	$allFkNodes = `ls -sl`;
	lockNode -l off $allFkNodes;
	delete $allFkNodes;
	
	//UNLOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l off $lockNodes;



	//REBUILD Fk NODES
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyFkChain2($modName, $chainsNum, $jointsNum, $direction, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $enableIk, $crntUnit, $create);
		
		$i++;
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//REAPPLY TRANSFORMS TO NEW PROXIES
	$proxCount2 = 0;
	for ($prox in $fkProx)
	{
		if (`objExists $prox`)
		{
			$tmpPosVec = $pos[$proxCount2];
			$tmpRotVec = $rot[$proxCount2];
			$tmpSclVec = $scl[$proxCount2];
			
			setAttr (($prox + ".translate"), $tmpPosVec.x, $tmpPosVec.y, $tmpPosVec.z);
			setAttr (($prox + ".rotate"), $tmpRotVec.x, $tmpRotVec.y, $tmpRotVec.z);
			setAttr (($prox + ".scale"), $tmpSclVec.x, $tmpSclVec.y, $tmpSclVec.z);
		}
		$proxCount2++;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY HEAD MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditHead()
{
	string $crntUnit = `currentUnit -query -linear`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadheadTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "Invalid module name in text field";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $mirrorMod = 1;
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	int $i;
	
	//CHECK FOR PAIRING
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$prfx = "";
		$oppPrfx = "";
		$mirrorMod = 0;
	}
	while ($i <= $mirrorMod)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Jaw")`)
		{
			//SET JAW ON IN PARENT NODE
			lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");
		
			setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jaw");
			setAttr ("RRM_" + $prfx + $modName + "_Parent.jaw") 0;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
			lockNode -l on ("RRM_" + $prfx + $modName + "_Parent");
		
			lockNode -l off ("RRM_" + $modName);
			setAttr -l false ("RRM_" + $modName + ".jaw");
			setAttr ("RRM_" + $modName + ".jaw") 0;
			setAttr -l true ("RRM_" + $modName + ".jaw");
			lockNode -l on ("RRM_" + $modName);
		

			select -hi ("RRM_*_RRM_" + $prfx + $modName + "_JawConnector") ("RRM_*_RRM_" + $prfx + $modName + "_Jaw_AimLctr")
			("RRM_*_RRM_" + $prfx + $modName + "_JawEndConnector") ("RRM_*_RRM_" + $prfx + $modName + "_JawEnd_AimLctr");
			$connectors = `ls -sl`;
			
			select -hi ("RRM_" + $prfx + $modName + "_Jaw");
			select -add $connectors;
			$jawHierarchy = `ls -sl`;
			lockNode -l off $jawHierarchy;
			delete $jawHierarchy;
		}
		else
		{
			//SET JAW ON IN PARENT NODE
			lockNode -l off ("RRM_" + $prfx + $modName + "_Parent");
		
			setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jaw");
			setAttr ("RRM_" + $prfx + $modName + "_Parent.jaw") 1;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
			lockNode -l on ("RRM_" + $prfx + $modName + "_Parent");

			lockNode -l off ("RRM_" + $modName);
			setAttr -l false ("RRM_" + $modName + ".jaw");
			setAttr ("RRM_" + $modName + ".jaw") 1;
			setAttr -l true ("RRM_" + $modName + ".jaw");
			lockNode -l on ("RRM_" + $modName);

			RRM_CreateProxyModuleProxy($crntUnit, ("RRM_" + $prfx + $modName + "_Jaw"));
			delete `parentConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Jaw")`;
			parent ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply false -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			delete `pointConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Jaw")`;
			$jawLoc = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.ty")`;
			move -r -ls 0 0 ($jawLoc/6) ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.core") ($prfx + $modName + "_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.core");
		
			RRM_CreateProxyEndProxy($crntUnit, ("RRM_" + $prfx + $modName + "_JawEnd"));
			rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			delete `parentConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_JawEnd")`;
			parent ("RRM_" + $prfx + $modName + "_JawEnd") ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply false -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			move -r -ls 0 (($jawLoc/3)*2) $jawLoc ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.core") ($prfx + $modName + "_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.core");
  
			lockNode -l on ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_JawEnd");
			
			//CONNECTORS
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Jaw"));
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Jaw"), ("RRM_" + $prfx + $modName + "_JawEnd"));
		}
		$i++;
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY LOOK AT MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLookAt()
{
	string $crntUnit = `currentUnit -query -linear`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadlookAtTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "Invalid module name in text field";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $jointsNum = `intSliderGrp -q -v lookAtModEditJoints`;
	int $mirrorMod = 0;

	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $lPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $lPrfx + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_" + $rPrfx + $modName + "_ParentConnector") ("RRM_*_RRM_" + $rPrfx + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $lPrfx + $modName + "_ConnectorGrp") ("RRM_" + $rPrfx + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_" + $lPrfx + $modName + "_Grp") ("RRM_" + $rPrfx + $modName + "_Grp") $connectors;
		$mirrorMod = 1;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentConnector") ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_" + $modName + "_Grp") $connectors;
	}

	//DELETE OLD LOOK AT NODES
	$fkNodes = `ls -sl`;
	select -hi $fkNodes;
	$allFkNodes = `ls -sl`;
	lockNode -l off $allFkNodes;
	delete $allFkNodes;
	
	//UNLOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l off $lockNodes;
	
	//REBUILD LOOK AT NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyLookAt2($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);
		
		$i++;
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -l off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -l on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
				$modNameCheck = `getAttr ($each + ".modName")`;
				if ($modNameCheck == "")
				{
					lockNode -l off $each;
					setAttr -l false ($each + ".modName");
					setAttr -type "string" ($each + ".modName") $modName;
					setAttr -l true ($each + ".modName");
				}
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

//OVERRIDE COLOR
global proc RRM_ProxyOverrideColor(int $colorVal)
{
	$selection = `ls -sl -type "transform"`;
	for ($each in $selection)
	{
		//MAKE SURE EACH IN SELECTION IS A VALID PROXY
		if (`objExists ($each + ".modName")`)
		{
			$modName = `getAttr ($each + ".modName")`;
			$modNodes = `ls -type "transform" ("RRM_*" + $modName + "_*")`;
			//MAKE SURE NODE IS PART OF THE SELECTED MODULE
			for ($each2 in $modNodes)
			{
				//VALIDATE EACH IS PART OF THE MODULE OF THE INITIAL SELECTED BRANCH
				if (`objExists ($each2 + ".modName")`)
				{
					$checkModName = `getAttr ($each2 + ".modName")`;
					if ($checkModName == $modName)
					{
						//CHECK IF IT IS RESET
						if ($colorVal == 0)
						{
							string $modType =`getAttr ("RRM_" + $checkModName + ".top")`;
							if ($modType == "spline")
							{
								setAttr ($each2 + ".overrideColor") 29;
							}
							else if ($modType == "arm")
							{
								setAttr ($each2 + ".overrideColor") 7;
							}
							else if ($modType == "leg")
							{
								setAttr ($each2 + ".overrideColor") 31;
							}
							else if ($modType == "fkChain")
							{
								setAttr ($each2 + ".overrideColor") 9;
							}
							else if ($modType == "head")
							{
								setAttr ($each2 + ".overrideColor") 4;
							}
							else if ($modType == "lookAt")
							{
								setAttr ($each2 + ".overrideColor") 30;
							}
						}
						else
						{
							setAttr ($each2 + ".overrideColor") $colorVal;
						}
					}
				}
			}
		}
	}
	select $selection;
}
////////////////////////////////////////////////////////////////////////////////
//////////////////////////////RENAME MODULE/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//RENAME MODULE	
global proc RRM_Rename(string $name, string $selection, int $call)
{
	//string $crntUnit = `currentUnit -query -linear`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	string $modName;
	string $modType;
	string $attachNode;
	string $side;
	string $ext;
	
	string $eachModName;
	
	if ($call == 0)
	{
		$modName = `getAttr ($selection + ".modName")`;
		$modType = `getAttr ("RRM_" + $modName + ".top")`;
		$attachNode = `getAttr ("RRM_" + $modName + ".parent")`;
	}
	else
	{
		$modName = `getAttr ("RRM_" + $selection + ".core")`;
		$modType = `getAttr ("RRM_" + $selection + ".top")`;
		//ORIGINAL MODULE'S ATTACH NODE
		$sourceAttachNode = `getAttr ("RRM_" + $modName + ".parent")`;

		//GET ATTACH NODE'S CLONED ATTRIBUTE
		string $cloneName = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		if (`gmatch $cloneName ""`)
		{//ATTACH NODE IS NOT A CLONE
			$attachNode = ($sourceAttachNode);
		}
		else
		{//ATTACH NODE IS A CLONE
			$attachNode = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		}
	}
	string $clonedParentNodes[];	

	int $mirrorMod = 1;
	string $prfx = $lPrfx;
	string $prfxReset = $lPrfx;
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 0;
		$prfx = "";
		$prfxReset = "";
	}
	int $firstTimeThrough;

	//CHECK IF SPLINE
	if (`gmatch $modType "spline"`)
	{
		RRM_Clone_Spline($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "arm"`)
	{//CHECK IF ARM
		RRM_Clone_Arm($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "leg"`)
	{//CHECK IF LEG
		RRM_Clone_Leg($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "fkChain"`)
	{//CHECK IF FkCHAIN
		RRM_Clone_FkChain($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "head"`)
	{//CHECK IF HEAD
		RRM_Clone_Head($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "lookAt"`)
	{//CHECK IF LOOKAT
		RRM_Clone_LookAt($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "auxiliary"`)
	{//CHECK IF AUXILIARY
		RRM_Clone_Auxiliary($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
		
	if ($call <= 1)
	{
		//CHECK TO SEE IF IT IS NOT AN AUXILIARY
		if (!`objExists ("RRM_" + $name + "_Aux")` && !`objExists ("RRM_" + $lPrfx + $name + "_Aux")`)
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode" -dt "string" "RRM_Clone_Lctr";
			setAttr -e -k 1 "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Parent");
			if (!`objExists ("RRM_" + $name + "_Parent")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $lPrfx + $name + "_Parent");
			}
		}
		else
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode" -dt "string" "RRM_Clone_Lctr";
			setAttr -e -k 1 "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Aux");
			if (!`objExists ("RRM_" + $name + "_Aux")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $lPrfx + $name + "_Aux");
			}
		}			
	}
	
	//FIND CHILDREN MODULES AND ATTACH TO RENAMED DUPLICATE
	$hierarchy = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	string $prfx = "";
	int $childModCount = 0;
	for ($each in $hierarchy)
	{
		if (`objExists ($each + ".parent")` && !`objExists ($each + ".top")`)
		{//VERIFY IT IS A PARENT
			$attachNode = `getAttr ($each + ".attachNode")`;
			if (`objExists ("RRM_" + $attachNode + ".pair")`)
			{
				$prfx = `getAttr ("RRM_" + $attachNode + ".pair")`;
				if (`gmatch $prfx "left"`)
					{$prfx = $lPrfx;}
				else if (`gmatch $prfx "right"`)
					{$prfx = $rPrfx;}
			}
			if (`gmatch ($attachNode + "*") ($prfx + $modName + "_*")`)
			{//MAKE SURE IT IS A PARENT NODE ATTACHED TO THE RENAMED MODULE
				$eachModName = `getAttr ($each + ".modName")`;
				if (!`gmatch $modName $eachModName`)
				{//MAKE SURE IT IS NOT A PARENT NODE OF THE RENAMED MODULE
					string $attachNode_Ext = `getAttr ("RRM_" + $attachNode + ".ext")`;
					if (`objExists ("RRM_" + $prfx + $name + $attachNode_Ext)`)
					{//ONLY ATTACH IF IT IS A DIRECT CHILD MODULE OF THE RENAMED MODULE
						select ("RRM_" + $prfx + $name + $attachNode_Ext);
						select $each;
						RRM_AttachToNewModule(("RRM_" + $prfx + $name + $attachNode_Ext));
					}
					$childModCount++;
				}
			}
		}
	}
	//DELETE ORIGINAL MODULE
	select $selection;
	RRM_DeleteBranchPrompts();
}

global proc RRM_RenamePrompts(string $name)
{
	string $selection[] = `ls -sl`;
	string $coreCheck;
	if (`objExists ($selection[0] + ".core")`)
	{
		$coreCheck = `getAttr ($selection[0] + ".core")`;
	}
	
	if (`size $selection` == 0)
	{//CHECK THAT SOMETHING IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Nothing Selected"
			-message "You must select a node of the desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`size $selection` > 1)
	{//CHECK THAT ONLY ONE OBJECT IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Only One Module May Be Cloned At A Time"
			-message "You must select only one node of a desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (!`objExists ($selection[0] + ".core")`)
	{//CHECK TO MAKE SURE OBJECT IS A VALID MODULE
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message "You must select one node of a desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	
	else if (`gmatch $coreCheck "MAIN"` || `gmatch $coreCheck "ROOT"`)
	{//CHECK TO MAKE SURE OBJECT IS NOT MAIN OR ROOT
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message "You cannot rename the MAIN or ROOT modules.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}

	else if (`size $name` == "0")
	{//CHECK TO MAKE SURE THE USER HAS INPUT A NAME
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($name))
	{//CHECK TO MAKE SURE A VALID NAME HAS BEEN USED
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ("RRM_" + $name)`)
	{//CHECK TO MAKE SURE NAME DOES NOT CONFLICT WITH EXISTING OBJECT
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		print "renaming...\n";
		string $parentNullName = "";
		RRM_Rename($name, $selection[0], 0);
	}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////CLONE MODULE/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//CLONE SPLINE
global proc RRM_Clone_Spline(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS AND TWIST AXIS
	int $splineNum = `getAttr ("RRM_" + $modName + ".jointsNum")`;
	int $twistAxis = 2;
	string $twistString = "Y-axis";
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	if (`objExists ("RRM_" + $modName + ".twistAxis")`)
	{
		int $twistAxis = `getAttr ("RRM_" + $modName + ".twistAxis")`;
		if ($twistAxis == 1)
		{
			$twistString = "X-axis";
		}
	}
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Top_Lctr");
		$topPos = `getAttr ("RRM_" + $prfx + $modName + "_Top.translate")`;
		$topRot = `getAttr ("RRM_" + $prfx + $modName + "_Top.rotate")`;
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.scale"), $topScale[0], $topScale[1], $topScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.clone") ($prfx + $name + "_Top");

		//WHILE LOOP
		int $i2 = 1;
		while ($i2 <= $splineNum)
		{
			string $nPd = "_0";
			if ($i2 >= 10)
			{
				string $nPd = "_";
			}
			//TRANSFORMS LOCATOR
			spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr");
			$eachPos = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".translate")`;
			$eachRot = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".rotate")`;
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".scale")`;
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i2 + ".clone") ($prfx + $name + $nPd + $i2);
			
			$i2++;
		}
		$prfx = $rPrfx;
		$i++;
	}

	//GENERATE NEW SPLINE
	select ("RRM_" + $attachNode);
	RRM_CreateProxySpline($name, $splineNum, $twistAxis, $mirrorMod, $lPrfx, $rPrfx);
	
	$clonedParentNodes = `ls -sl`;
	
	
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
	
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS
	
		//MOVE NODES TO LOCATORS
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		
	
		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");
	
		$topPos = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.translate")`;
		$topRot = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.rotate")`;		
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.scale")`;		
	
		setAttr (("RRM_" + $prfx + $name + "_Top.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.scale"), $topScale[0], $topScale[1], $topScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Top_Lctr");
	
		$i3 = 1;
		while ($i3 <= $splineNum)
		{
			string $nPd = "_0";
			if ($i3 >= 10)
			{
				string $nPd = "_";
			}
			//MOVE PROXY TO LOCATOR
			$eachPos = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.translate")`;
			$eachRot = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.rotate")`;		
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			delete ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr");
			$i3++;
		}
		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_Arm(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	print "Cloning arm...\n";
	//GET NUMBER OF JOINTS
	int $upperArmNum = `getAttr ("RRM_" + $modName + ".upperArmNum")`;
	int $lowerArmNum = `getAttr ("RRM_" + $modName + ".lowerArmNum")`;
	int $elbowNum = `getAttr ("RRM_" + $modName + ".elbowNum")`;
	int $elbowJoints = `getAttr ("RRM_" + $modName + ".elbowJoints")`;
	int $toon = 0;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	if (`objExists ("RRM_" + $modName + ".toon")`)
	{
		$toon = `getAttr ("RRM_" + $modName + ".toon")`;
	}
	$mirrorMod  = 2;
	$prfx   = $lPrfx;
	$prfxReset  = $lPrfx;
	
	if (`objExists ("RRM_" + $modName + ".single")`)
	{
		$prfx = "";
		$prfxReset = "";
		$checkSide = `getAttr ("RRM_" + $modName + ".single")`;
		if ($checkSide == "left")
		{
			$mirrorMod = 1;
		}
		else if ($checkSide == "right")
		{
			$mirrorMod = 3;
		}
	}
	int $i = 1;

	string $clonedParentNodes[];	
	
	while ($prfx != "end")
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Clavicle_Lctr");
		$clavPos = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.translate")`;
		$clavRot = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.rotate")`;
		$clavScale = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.translate"), $clavPos[0], $clavPos[1], $clavPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.rotate"), $clavRot[0], $clavRot[1], $clavRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.scale"), $clavScale[0], $clavScale[1], $clavScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.clone") ($prfx + $name + "_Clavicle");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Shoulder_Lctr");
		$shldrPos = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.translate")`;
		$shldrRot = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.rotate")`;
		$shldrScale = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.translate"), $shldrPos[0], $shldrPos[1], $shldrPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.rotate"), $shldrRot[0], $shldrRot[1], $shldrRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.scale"), $shldrScale[0], $shldrScale[1], $shldrScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.clone") ($prfx + $name + "_Shoulder");
		
		if ($elbowJoints == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow_Lctr");
			$elbowPos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.translate")`;
			$elbowRot = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.rotate")`;
			$elbowScale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.translate"), $elbowPos[0], $elbowPos[1], $elbowPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.rotate"), $elbowRot[0], $elbowRot[1], $elbowRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.scale"), $elbowScale[0], $elbowScale[1], $elbowScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.clone") ($prfx + $name + "_Elbow");
		}
		else
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow1_Lctr");
			$elbow1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.translate")`;
			$elbow1Rot = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.rotate")`;
			$elbow1Scale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.translate"), $elbow1Pos[0], $elbow1Pos[1], $elbow1Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.rotate"), $elbow1Rot[0], $elbow1Rot[1], $elbow1Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.scale"), $elbow1Scale[0], $elbow1Scale[1], $elbow1Scale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.clone") ($prfx + $name + "_Elbow1");
		
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow2_Lctr");
			$elbow2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.translate")`;
			$elbow2Rot = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.rotate")`;
			$elbow2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.translate"), $elbow2Pos[0], $elbow2Pos[1], $elbow2Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.rotate"), $elbow2Rot[0], $elbow2Rot[1], $elbow2Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.scale"), $elbow2Scale[0], $elbow2Scale[1], $elbow2Scale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.clone") ($prfx + $name + "_Elbow2");
		}
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Wrist_Lctr");
		$wristPos = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.translate")`;
		$wristRot = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.rotate")`;
		$wristScale = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.translate"), $wristPos[0], $wristPos[1], $wristPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.rotate"), $wristRot[0], $wristRot[1], $wristRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.scale"), $wristScale[0], $wristScale[1], $wristScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.clone") ($prfx + $name + "_Wrist");			

		if ($prfx == $lPrfx)
		{//SWITCH TO RIGHT
			$prfx = $rPrfx;
		}
		else if ($prfx == $rPrfx|| $prfx == "")
		{//SWITCH TO END
			$prfx = "end";
		}
	}
	
	//GENERATE NEW ARM(S)
	select ("RRM_" + $attachNode);
	RRM_CreateProxyArm($name, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $lPrfx, $rPrfx);

	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$prfx = $prfxReset;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$clavPos = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.translate")`;
		$clavRot = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.rotate")`;		
		$clavScale = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Clavicle.translate"), $clavPos[0], $clavPos[1], $clavPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Clavicle.rotate"), $clavRot[0], $clavRot[1], $clavRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Clavicle.scale"), $clavScale[0], $clavScale[1], $clavScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Clavicle_Lctr");

		$shldrPos = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.translate")`;
		$shldrRot = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.rotate")`;		
		$shldrScale = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Shoulder.translate"), $shldrPos[0], $shldrPos[1], $shldrPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Shoulder.rotate"), $shldrRot[0], $shldrRot[1], $shldrRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Shoulder.scale"), $shldrScale[0], $shldrScale[1], $shldrScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Shoulder_Lctr");

			
		if ($elbowJoints == 1)
		{
			$elbowPos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.translate")`;
			$elbowRot = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.rotate")`;		
			$elbowScale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.scale")`;		

			setAttr (("RRM_" + $prfx + $name + "_Elbow.translate"), $elbowPos[0], $elbowPos[1], $elbowPos[2]);
			delete ("RRM_" + $prfx + $modName + "_Elbow_Lctr");
		}
		else
		{
			$elbow1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1_Lctr.translate")`;

			setAttr (("RRM_" + $prfx + $name + "_Elbow1.translate"), $elbow1Pos[0], $elbow1Pos[1], $elbow1Pos[2]);
			delete ("RRM_" + $prfx + $modName + "_Elbow1_Lctr");

			$elbow2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2_Lctr.translate")`;
			$elbow2Rot = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Elbow2.translate"), $elbow2Pos[0], $elbow2Pos[1], $elbow2Pos[2]);
			setAttr ("RRM_" + $prfx + $name + "_Elbow2.rotateX") $elbow2Rot[0];
			delete ("RRM_" + $prfx + $modName + "_Elbow2_Lctr");
		}

		$wristPos = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.translate")`;
		$wristRot = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.rotate")`;		
		$wristScale = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Wrist.translate"), $wristPos[0], $wristPos[1], $wristPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Wrist.rotate"), $wristRot[0], $wristRot[1], $wristRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Wrist.scale"), $wristScale[0], $wristScale[1], $wristScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Wrist_Lctr");

		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_Leg(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $upperLegNum = `getAttr ("RRM_" + $modName + ".upperLegNum")`;
	int $lowerLegNum = `getAttr ("RRM_" + $modName + ".lowerLegNum")`;
	int $kneeNum = `getAttr ("RRM_" + $modName + ".kneeNum")`;
	int $kneeJoints = `getAttr ("RRM_" + $modName + ".kneeJoints")`;
	int $toon = 0;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	if (`objExists ("RRM_" + $modName + ".toon")`)
	{
		$toon = `getAttr ("RRM_" + $modName + ".toon")`;
	}
	$mirrorMod  = 2;
	$prfx   = $lPrfx;
	$prfxReset  = $lPrfx;
	
	if (`objExists ("RRM_" + $modName + ".single")`)
	{
		$prfx = "";
		$prfxReset = "";
		$checkSide = `getAttr ("RRM_" + $modName + ".single")`;
		if ($checkSide == "left")
		{
			$mirrorMod = 1;
		}
		else if ($checkSide == "right")
		{
			$mirrorMod = 3;
		}
	}
	int $i = 1;

	string $clonedParentNodes[];	
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Hip_Lctr");
		$hipPos = `getAttr ("RRM_" + $prfx + $modName + "_Hip.translate")`;
		$hipRot = `getAttr ("RRM_" + $prfx + $modName + "_Hip.rotate")`;
		$hipScale = `getAttr ("RRM_" + $prfx + $modName + "_Hip.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.translate"), $hipPos[0], $hipPos[1], $hipPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.rotate"), $hipRot[0], $hipRot[1], $hipRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.scale"), $hipScale[0], $hipScale[1], $hipScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.clone") ($prfx + $name + "_Hip");
			
		if ($kneeJoints == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee_Lctr");
			$kneePos = `getAttr ("RRM_" + $prfx + $modName + "_Knee.translate")`;
			$kneeRot = `getAttr ("RRM_" + $prfx + $modName + "_Knee.rotate")`;
			$kneeScale = `getAttr ("RRM_" + $prfx + $modName + "_Knee.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.translate"), $kneePos[0], $kneePos[1], $kneePos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.rotate"), $kneeRot[0], $kneeRot[1], $kneeRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.scale"), $kneeScale[0], $kneeScale[1], $kneeScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.clone") ($prfx + $name + "_Knee");
		}
		else
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee1_Lctr");
			$knee1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.translate")`;
			$knee1Rot = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.rotate")`;
			$knee1Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.translate"), $knee1Pos[0], $knee1Pos[1], $knee1Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.rotate"), $knee1Rot[0], $knee1Rot[1], $knee1Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.scale"), $knee1Scale[0], $knee1Scale[1], $knee1Scale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.clone") ($prfx + $name + "_Knee1");
			
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee2_Lctr");
			$knee2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.translate")`;
			$knee2Rot = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.rotate")`;
			$knee2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.translate"), $knee2Pos[0], $knee2Pos[1], $knee2Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.rotate"), $knee2Rot[0], $knee2Rot[1], $knee2Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.scale"), $knee2Scale[0], $knee2Scale[1], $knee2Scale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.clone") ($prfx + $name + "_Knee2");
		}
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ankle_Lctr");
		$anklePos = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.translate")`;
		$ankleRot = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.rotate")`;
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.clone") ($prfx + $name + "_Ankle");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ball_Lctr");
		$ballPos = `getAttr ("RRM_" + $prfx + $modName + "_Ball.translate")`;
		$ballRot = `getAttr ("RRM_" + $prfx + $modName + "_Ball.rotate")`;
		$ballScale = `getAttr ("RRM_" + $prfx + $modName + "_Ball.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.translate"), $ballPos[0], $ballPos[1], $ballPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.rotate"), $ballRot[0], $ballRot[1], $ballRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.scale"), $ballScale[0], $ballScale[1], $ballScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.clone") ($prfx + $name + "_Ball");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Toe_Lctr");
		$toePos = `getAttr ("RRM_" + $prfx + $modName + "_Toe.translate")`;
		$toeRot = `getAttr ("RRM_" + $prfx + $modName + "_Toe.rotate")`;
		$toeScale = `getAttr ("RRM_" + $prfx + $modName + "_Toe.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.translate"), $toePos[0], $toePos[1], $toePos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.rotate"), $toeRot[0], $toeRot[1], $toeRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.scale"), $toeScale[0], $toeScale[1], $toeScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.clone") ($prfx + $name + "_Toe");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr");
		$heelPivPos = `getAttr ("RRM_" + $prfx + $modName + "_HeelPivot.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.tx") $heelPivPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.tz") $heelPivPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.clone") ($prfx + $name + "_HeelPivot");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootBankOut_Lctr");
		$lTiltPos = `getAttr ("RRM_" + $prfx + $modName + "_FootBankOut.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_FootBankOut_Lctr.tx") $lTiltPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_FootBankOut_Lctr.tz") $lTiltPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankOut.clone") ($prfx + $name + "_FootBankOut");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootBankIn_Lctr");
		$rTiltPos = `getAttr ("RRM_" + $prfx + $modName + "_FootBankIn.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_FootBankIn_Lctr.tx") $rTiltPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_FootBankIn_Lctr.tz") $rTiltPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootBankIn.clone") ($prfx + $name + "_FootBankIn");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ground_Lctr");
		$grndPos = `getAttr ("RRM_" + $prfx + $modName + "_Ground.translate")`;
		$grndRot = `getAttr ("RRM_" + $prfx + $modName + "_Ground.rotate")`;
		$grndScale = `getAttr ("RRM_" + $prfx + $modName + "_Ground.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.translate"), $grndPos[0], $grndPos[1], $grndPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.rotate"), $grndRot[0], $grndRot[1], $grndRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.scale"), $grndScale[0], $grndScale[1], $grndScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.clone") ($prfx + $name + "_Ground");
		
		
		if ($prfx == $lPrfx)
		{//SWITCH TO RIGHT
			$prfx = $rPrfx;
		}
		$i++;
	}
	
	//GENERATE NEW LEG(S)
	select ("RRM_" + $attachNode);
	RRM_CreateProxyLeg($name, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $lPrfx, $rPrfx);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$prfx = $prfxReset;
	$i = 1;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$hipPos = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.translate")`;
		$hipRot = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.rotate")`;		
		$hipScale = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Hip.translate"), $hipPos[0], $hipPos[1], $hipPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Hip.rotate"), $hipRot[0], $hipRot[1], $hipRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Hip.scale"), $hipScale[0], $hipScale[1], $hipScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Hip_Lctr");

			
		if ($kneeJoints == 1)
		{
			$kneePos = `getAttr ("RRM_" + $prfx + $modName + "_Knee_Lctr.translate")`;
			$kneeRot = `getAttr ("RRM_" + $prfx + $modName + "_Knee_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee.translate"), $kneePos[0], $kneePos[1], $kneePos[2]);
			delete ("RRM_" + $prfx + $modName + "_Knee_Lctr");
		}
		else
		{
			$knee1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee1_Lctr.translate")`;
			$knee1Rot = `getAttr ("RRM_" + $prfx + $modName + "_Knee1_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee1.translate"), $knee1Pos[0], $knee1Pos[1], $knee1Pos[2]);
			delete ("RRM_" + $prfx + $modName + "_Knee1_Lctr");

			$knee2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.translate")`;
			$knee2Rot = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.rotate")`;		
			$knee2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.scale")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee2.translate"), $knee2Pos[0], $knee2Pos[1], $knee2Pos[2]);
			setAttr ("RRM_" + $prfx + $name + "_Knee2.rotateY") $knee2Rot[1];
			delete ("RRM_" + $prfx + $modName + "_Knee2_Lctr");
		}

		$anklePos = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.translate")`;
		$ankleRot = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.rotate")`;		
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ankle.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ankle.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ankle.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ankle_Lctr");


		$ballPos = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.translate")`;
		$ballRot = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.rotate")`;		
		$ballScale = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ball.translate"), $ballPos[0], $ballPos[1], $ballPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ball.rotate"), $ballRot[0], $ballRot[1], $ballRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ball.scale"), $ballScale[0], $ballScale[1], $ballScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ball_Lctr");

		$toePos = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.translate")`;
		$toeRot = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.rotate")`;		
		$toeScale = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Toe.translate"), $toePos[0], $toePos[1], $toePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Toe.rotate"), $toeRot[0], $toeRot[1], $toeRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Toe.scale"), $toeScale[0], $toeScale[1], $toeScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Toe_Lctr");


		$heelPivPos = `getAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_HeelPivot.tx") $heelPivPos[0];
		setAttr ("RRM_" + $prfx + $name + "_HeelPivot.tz") $heelPivPos[2];
		delete ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr");


		$lTiltPos = `getAttr ("RRM_" + $prfx + $modName + "_FootBankOut_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_FootBankOut.tx") $lTiltPos[0];
		setAttr ("RRM_" + $prfx + $name + "_FootBankOut.tz") $lTiltPos[2];
		delete ("RRM_" + $prfx + $modName + "_FootBankOut_Lctr");


		$rTiltPos = `getAttr ("RRM_" + $prfx + $modName + "_FootBankIn_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_FootBankIn.tx") $rTiltPos[0];
		setAttr ("RRM_" + $prfx + $name + "_FootBankIn.tz") $rTiltPos[2];
		delete ("RRM_" + $prfx + $modName + "_FootBankIn_Lctr");


		$anklePos = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.translate")`;
		$ankleRot = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.rotate")`;		
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ground.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ground.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ground.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ground_Lctr");

		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_FkChain(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $chainsNum = `getAttr ("RRM_" + $modName + ".chainsNum")`;
	int $jointsNum = `getAttr ("RRM_" + $modName + ".jointsNum")`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $enableIk = `getAttr ("RRM_" + $modName + ".ikEnabled")`;
	int $i = 0;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
		
		//WHILE LOOP FOR CHAINS
		int $chainLoop = 1;
		while ($chainLoop <= $chainsNum)
		{
			string $nPd = "_0";
			if ($chainLoop >= 10)
			{
				string $nPd = "_";
			}
			$jointLoop = 1;
			//WHILE LOOP FOR JOINTS
			while ($jointLoop <= $jointsNum)
			{				
				string $jPad = "_0";
				if ($chainLoop >= 10)
				{
					string $jPad = "_";
				}
				//MOVE PROXY TO LOCATOR
				spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr");
				$eachPos = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".translate")`;
				$eachRot = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".rotate")`;
				$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".scale")`;
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
				//CLONE ATT
				setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".clone") ($prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop);
				$jointLoop++;		
			}
			$chainLoop++;
		}
		$prfx = $rPrfx;
		$i++;
	}
	
	//GENERATE NEW Fk CHAIN
	select ("RRM_" + $attachNode);
	RRM_CreateProxyFkChain($name, $chainsNum, $jointsNum, $direction, $direction, $mirrorMod, $enableIk, $lPrfx, $rPrfx);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		
		//WHILE LOOP FOR CHAINS
		int $chainLoop = 1;
		while ($chainLoop <= $chainsNum)
		{
			string $nPd = "_0";
			if ($chainLoop >= 10)
			{
				string $nPd = "_";
			}
			$jointLoop = 1;
			//WHILE LOOP FOR JOINTS
			while ($jointLoop <= $jointsNum)
			{			
				string $jPad = "_0";
				if ($chainLoop >= 10)
				{
					string $jPad = "_";
				}
				//MOVE PROXY TO LOCATOR
				$eachPos = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.translate")`;
				$eachRot = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.rotate")`;		
				$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.scale")`;		
				
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
				delete ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr");
				$jointLoop++;
			}
			$chainLoop++;
		}
		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_Head(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $jaw = `getAttr ("RRM_" + $modName + ".jaw")`;
	int $i = 0;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
		
		if ($jaw == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Jaw_Lctr");
			$jawPos = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.translate")`;
			$jawRot = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.rotate")`;
			$jawScale = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.translate"), $jawPos[0], $jawPos[1], $jawPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.rotate"), $jawRot[0], $jawRot[1], $jawRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.scale"), $jawScale[0], $jawScale[1], $jawScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.clone") ($prfx + $name + "_Jaw");
			
			spaceLocator -n ("RRM_" + $prfx + $modName + "_JawEnd_Lctr");
			$jawEndPos = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.translate")`;
			$jawEndRot = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.rotate")`;
			$jawEndScale = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.translate"), $jawEndPos[0], $jawEndPos[1], $jawEndPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.rotate"), $jawEndRot[0], $jawEndRot[1], $jawEndRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.scale"), $jawEndScale[0], $jawEndScale[1], $jawEndScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.clone") ($prfx + $name + "_JawEnd");
		}
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Top_Lctr");
		$topPos = `getAttr ("RRM_" + $prfx + $modName + "_Top.translate")`;
		$topRot = `getAttr ("RRM_" + $prfx + $modName + "_Top.rotate")`;
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.scale"), $topScale[0], $topScale[1], $topScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.clone") ($prfx + $name + "_Top");

		$prfx = $rPrfx;
		$i++;
	}
	
	//GENERATE NEW HEAD
	select ("RRM_" + $attachNode);
	RRM_CreateProxyHead($name, $jaw, $mirrorMod, $lPrfx, $rPrfx);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;

		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		if ($jaw == 1)
		{
			$jawPos = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.translate")`;
			$jawRot = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.rotate")`;		
			$jawScale = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + "_Jaw.translate"), $jawPos[0], $jawPos[1], $jawPos[2]);
			setAttr (("RRM_" + $prfx + $name + "_Jaw.rotate"), $jawRot[0], $jawRot[1], $jawRot[2]);
			setAttr (("RRM_" + $prfx + $name + "_Jaw.scale"), $jawScale[0], $jawScale[1], $jawScale[2]);
			delete ("RRM_" + $prfx + $modName + "_Jaw_Lctr");
			
			$jawEndPos = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.translate")`;
			$jawEndRot = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.rotate")`;		
			$jawEndScale = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.translate"), $jawEndPos[0], $jawEndPos[1], $jawEndPos[2]);
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.rotate"), $jawEndRot[0], $jawEndRot[1], $jawEndRot[2]);
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.scale"), $jawEndScale[0], $jawEndScale[1], $jawEndScale[2]);
			delete ("RRM_" + $prfx + $modName + "_JawEnd_Lctr");
		}

		$topPos = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.translate")`;
		$topRot = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.rotate")`;		
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Top.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.scale"), $topScale[0], $topScale[1], $topScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Top_Lctr");

		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_LookAt(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{//CHECK IF LOOKAT
	//GET NUMBER OF JOINTS
	int $eyeNum = `getAttr ("RRM_" + $modName + ".eyeNum")`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $i = 0;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");

		//WHILE LOOP
		int $i2 = 1;
		while ($i2 <= $eyeNum)
		{
			string $nPd = "_0";
			if ($i2 >= 10)
			{
				string $nPd = "_";
			}
			//TRANSFORMS LOCATOR
			spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr");
			$eachPos = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".translate")`;
			$eachRot = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".rotate")`;
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".scale")`;
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i2 + ".clone") ("RRM_" + $prfx + $modName + $nPd + $i2);
			$i2++;
		}
		$prfx = $rPrfx;
		$i++;
	}
	
	//GENERATE NEW LOOK AT
	select ("RRM_" + $attachNode);
	RRM_CreateProxyLookAt($name, $eyeNum, $direction, $direction, $mirrorMod, $lPrfx, $rPrfx);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;

		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$i3 = 1;
		while ($i3 <= $eyeNum)
		{
			string $nPd = "_0";
			if ($i3 >= 10)
			{
				string $nPd = "_";
			}
			//MOVE PROXY TO LOCATOR
			$eachPos = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.translate")`;
			$eachRot = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.rotate")`;		
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			delete ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr");
			$i3++;
		}
		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_Auxiliary(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	int $i = 0;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
		
	while ($i <= $mirrorMod)
	{
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.clone") ($prfx + $name + "_Aux");
		$prfx = $rPrfx;
		$i++;
	}

	//GENERATE NEW AUXILIARY
	select ("RRM_" + $attachNode);
	RRM_CreateProxyAuxiliary($name, $mirrorMod, $lPrfx, $rPrfx);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
	
	while ($i <= $mirrorMod)
	{
		delete `parentConstraint ("RRM_" + $prfx + $modName + "_Aux") ("RRM_" + $prfx + $name + "_Aux")`;
		delete `scaleConstraint ("RRM_" + $prfx + $modName + "_Aux") ("RRM_" + $prfx + $name + "_Aux")`;
		$prfx = $rPrfx;
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

	
global proc RRM_Clone(string $name, string $selection, string $attachNode, int $call)
{
	string $modName;
	string $modType;
	string $side;
	string $ext;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	if ($call == 0)
	{
		$modName = `getAttr ($selection + ".modName")`;
		$modType = `getAttr ("RRM_" + $modName + ".top")`;
		$attachNode = `getAttr ("RRM_" + $modName + ".parent")`;
	}
	else
	{
		$modName = `getAttr ("RRM_" + $selection + ".core")`;
		$modType = `getAttr ("RRM_" + $selection + ".top")`;
		//ORIGINAL MODULE'S ATTACH NODE
		$sourceAttachNode = `getAttr ("RRM_" + $modName + ".parent")`;

		//GET ATTACH NODE'S CLONED ATTRIBUTE
		string $cloneName = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		if (`gmatch $cloneName ""`)
		{//ATTACH NODE IS NOT A CLONE
			$attachNode = ($sourceAttachNode);
		}
		else
		{//ATTACH NODE IS A CLONE
			$attachNode = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		}
	}
	string $clonedParentNodes[];	

	int $mirrorMod = 1;
	string $prfx = $lPrfx;
	string $prfxReset = $lPrfx;
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 0;
		$prfx = "";
		$prfxReset = "";
	}
	int $firstTimeThrough;

		
	//CHECK IF SPLINE
	if (`gmatch $modType "spline"`)
	{
		RRM_Clone_Spline($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "arm"`)
	{//CHECK IF ARM
		RRM_Clone_Arm($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "leg"`)
	{//CHECK IF LEG
		RRM_Clone_Leg($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "fkChain"`)
	{//CHECK IF FkCHAIN
		RRM_Clone_FkChain($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "head"`)
	{//CHECK IF HEAD
		RRM_Clone_Head($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "lookAt"`)
	{//CHECK IF LOOKAT
		RRM_Clone_LookAt($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "auxiliary"`)
	{//CHECK IF AUXILIARY
		RRM_Clone_Auxiliary($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
		
	if ($call <= 1)
	{
		//CHECK TO SEE IF IT IS NOT AN AUXILIARY
		if (!`objExists ("RRM_" + $name + "_Aux")` && !`objExists ("RRM_" + $lPrfx + $name + "_Aux")`)
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode" -dt "string" "RRM_Clone_Lctr";
			setAttr -e -k 1 "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Parent");
			if (!`objExists ("RRM_" + $name + "_Parent")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $lPrfx + $name + "_Parent");
			}
		}
		else
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode" -dt "string" "RRM_Clone_Lctr";
			setAttr -e -k 1 "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Aux");
			if (!`objExists ("RRM_" + $name + "_Aux")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $lPrfx + $name + "_Aux");
			}
		}			
	}
}

global proc RRM_CheckCloneFields(int $cloneCheck[], string $textFields[], string $cloneSource[], string $cloneParent[])
{
	int $i;
	string $each;
	for ($each in $textFields)
	{
		$name = `textField -q -text $each`;
		if (`objExists ("RRM_" + $name)`)
		{
		string $returnVal_Generate = `confirmDialog
			-title "Module Already Exists"
			-message ("A module named \"" + $name + "\" already exists. You need to use a unique name.\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
			error "Please provide unique names for all cloned modules.";
		}
		else if (`size $name` == 0)
		{
		string $returnVal_Generate = `confirmDialog
			-title "Missing Name"
			-message "You need to provide a name for each module.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
			error "Please provide unique names for all cloned modules.";
		}
		$i++;
	}
	$i = 0;
	for ($each in $textFields)
	{
		$name = `textField -q -text $each`;
		RRM_Clone($name, $cloneSource[$i], $cloneParent[$i], ($i + 1));
		$i++;
	}
}

global proc RRM_CloneHierarchyUI()
{
	$name = `textField -q -text textFieldCloneName`;
	string $selection[] = `ls -sl`;
	string $modName = `getAttr ($selection[0] + ".modName")`;
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	$topModules[0] = ("RRM_" + $modName);
	for ($each in $nodes)
	{
		if (`objExists ($each + ".top")` && `nodeType $each` != "constraint")
		{
			$topModules = `ls $topModules $each`;
		}
	}
	//GET DIALOG'S FORMLAYOUT
	string $form = `setParent -q`;
	
	formLayout -e -width 300 $form;
	string $instructions = `text -l "Rename Branches"`;
	string $original = `text -l "SOURCE NAME:"`;
	string $clone = `text -l "CLONE NAME:"`;
	formLayout -edit
		-attachForm				$instructions 	"top" 5
		-attachForm				$instructions 	"left" 90
		
		-attachForm				$original 	"top" 30
		-attachForm				$original 	"left" 4
		
		-attachForm				$clone 	"top" 30
		-attachForm				$clone 	"right" 75
	$form;
	int $i;
	string $checkBoxes[];
	global int $cloneCheck[];
	global string $cloneTextFields[];
	global string $cloneSource[];
	global string $cloneParent[];
	int $spacer = 10;
	int $top = 50;
	for ($eachBranch in $topModules)
	{
		//GET CORE NAME
		$coreName = `getAttr ($eachBranch + ".core")`;
		
		//GET PLACE IN HIERARCHY
		$left = 20;
		string $parentModule = $eachBranch;
		while (!`gmatch $parentModule ("RRM_" + $modName)`)
		{
			$parentNode = `getAttr ($parentModule + ".parent")`;
			$parentModule = `getAttr ("RRM_" + $parentNode + ".modName")`;
			$parentModule = ("RRM_" + $parentModule); 
			$left = ($left + 16);
		}
			
		string $checkBox = `checkBox -en 0 -vis 0 -v 0 -l "" ("checkBox_" + $eachBranch)`;
		string $label = `text -l ("-" + $coreName)`;
		string $textField = `textField -w 150 ("textField" + $eachBranch)`;
		
		formLayout -edit
			-attachForm			$checkBox		"top" $top
			-attachForm			$checkBox		"left" 4

			-attachForm			$label			"top" $top
			-attachForm			$label			"left" $left
			
			-attachForm			$textField		"top" $top
			-attachForm			$textField		"right" 5
		$form;
		
		$top = ($top + 20);
		$cloneCheck[$i] = `checkBox -q -v $checkBox`;
		$cloneTextFields[$i] = $textField;
		$cloneSource[$i] = $coreName;
		string $cloneParent[];
		if (`objExists ("RRM_" + $coreName + ".parent")`)
		{
			$cloneParent[$i] = `getAttr ("RRM_" + $coreName + ".parent")`;
		}
		else
		{
			$cloneParent[$i] = `getAttr ("RRM_" + $coreName + ".attachNode")`;
		}
		$i++;
	}
	string $button_OK = `button -w 144 -label "OK" -c "RRM_CheckCloneFields($cloneCheck, $cloneTextFields, $cloneSource, $cloneParent);layoutDialog -dismiss \"OK\";" Clone_Button`;
	string $button_Cancel = `button -w 144 -label "Cancel" -c "layoutDialog -dismiss \"Cancel\""`;
	formLayout -edit
		-attachForm			$button_OK		"top" ($top + 10)
		-attachForm			$button_OK		"left" 4
		
		-attachForm			$button_Cancel	"top" ($top + 10)
		-attachForm			$button_Cancel	"right" 4
	$form;
	
	textField -e -text $name $cloneTextFields[0]; 
}

global proc RRM_ClonePrompts(string $name, int $branchClone, int $clone)
{
	string $selection[] = `ls -sl`;
	string $coreCheck;
	if (`objExists ($selection[0] + ".core")`)
	{
		$coreCheck = `getAttr ($selection[0] + ".core")`;
	}
	
	string $dupeType = "clone";
	if ($clone == 0)
	{
		$dupeType = "rename";
	}
	
	if (`size $selection` == 0)
	{//CHECK THAT SOMETHING IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Nothing Selected"
			-message ("You must select a node of the desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`size $selection` > 1)
	{//CHECK THAT ONLY ONE OBJECT IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Only One Module May Be Cloned At A Time"
			-message ("You must select only one node of a desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (!`objExists ($selection[0] + ".core")`)
	{//CHECK TO MAKE SURE OBJECT IS A VALID MODULE
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message ("You must select one node of a desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else if (`gmatch $coreCheck "MAIN"` || `gmatch $coreCheck "ROOT"`)
	{//CHECK TO MAKE SURE OBJECT IS NOT MAIN OR ROOT
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message ("You cannot " + $dupeType + " the MAIN or ROOT modules.\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else if (`size $name` == "0")
	{//CHECK TO MAKE SURE THE USER HAS INPUT A NAME
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message ("You must enter a name for the " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (! RRM_CheckName($name))
	{//CHECK TO MAKE SURE A VALID NAME HAS BEEN USED
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ("RRM_" + $name)`)
	{//CHECK TO MAKE SURE NAME DOES NOT CONFLICT WITH EXISTING OBJECT
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $parentNullName = "";
		if ($branchClone == 0)
		{//ONLY CLONE LOADED MODULE
			if ($clone == 1)
			{
				print "Cloning...\n";
				RRM_Clone($name, $selection[0], $parentNullName, 0);
			}
			else
			{
				print "Renaming...\n";
				RRM_Rename($name, $selection[0], 0);
			}
		}
		else
		{//CLONE BRANCHES
			string $topModules[];
			$modName = `getAttr ($selection[0] + ".modName")`;
			
			$hierarchy = `listRelatives -ad -type "nurbsCurve" ("RRM_" + $modName)`;
			//$nodeShapes = `ls -type "nurbsCurve" $hierarchy`;
			$nodes = `listRelatives -p $hierarchy`;
			for ($each in $nodes)
			{
				if (`objExists ($each + ".modName")` && `nodeType $each` != "constraint")
				{
					$modules = ("RRM_" + `getAttr ($each + ".modName")`);
					select $topModules $modules;
					$topModules = `ls -sl`;
				}
				
			}
			if (`size $topModules` == 1)
			{
				if ($clone = 1) 
				{
					RRM_Clone($name, $selection[0], $parentNullName, 0);
				}
				else
				{
					RRM_Rename($name, $selection[0], 0);
				}					
			}
			if ($branchClone == 1 && `size $topModules` > 1)
			{
				select $selection[0];
				layoutDialog -ui "RRM_CloneHierarchyUI()";
			}
		}
		//RESET CLONE ATTRIBUTES FOR FUTURE CLONES
		
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		$shapeNodes = `ls -type "nurbsCurve" $hierarchy`;
		$nodes = `listRelatives -p $shapeNodes`;
		
		string $each;
		for ($each in $nodes)
		{
			if (`objExists ($each + ".clone")`)
			{
				setAttr -type "string" ($each + ".clone") "";
			}
		}
	}
	select -cl;
	int $selectionInt = 0;
	while ($selectionInt <= `size $selection`)
	{
		if (`objExists $selection[$selectionInt]`)
		{
			select -add $selection[$selectionInt];
		}
		$selectionInt++;
	}
	if (`objExists "RRM_Clone_Lctr.topCloneNode"`)
	{
		$topNode[0] = `getAttr "RRM_Clone_Lctr.topCloneNode"`;
		if (`objExists ($topNode[0] + ".opposite")`)
		{
			$opposite = `getAttr ($topNode[0] + ".opposite")`;
			$topNode[1] = ("RRM_" + $opposite);
		}
		delete "RRM_Clone_Lctr";
		select $topNode;
	}
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////DELETE BRANCH/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_DeleteBranch(string $eachMod)
{
	//UNLOCK NODES	
	$rigHierarchy = `listRelatives -ad RRM_MAIN`;
	
	lockNode -l off $rigHierarchy;

	string $crntNode;
	int $crntInt = 0;
	select $eachMod;
	$eachNode = `ls $eachMod`;
	
	while ((!`objExists ($eachNode[0] + ".top")`) && ($crntInt < 101))
	{
		pickWalk -d up;
		$eachNode = `ls -sl`;
		$crntInt++;
	}
	if (`objExists ($eachNode[0] + ".top")`)
	{
		delete $eachNode;
		$crntInt = 100;
	}
	
	//LOCK NODES
	$rigHierarchy2 = `listRelatives -ad RRM_MAIN`;
	lockNode $rigHierarchy2;
}
			
global proc RRM_DeleteBranchPrompts()
{
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	string $eachMod;
	if (`size $attachMod` == 0)
	{
		string $returnVal_Generate = `confirmDialog
				-title "No Module Selected"
				-message "Please select a module node of a branch to delete.\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
	}
	else
	{
		for ($eachMod in $attachMod)
		{
			if (`objExists $eachMod` && !`objExists ($eachMod + ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Branch Node"
					-message "You cannot delete the selected node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ((`gmatch $eachMod "RRM_ROOT"`) || (`gmatch $eachMod "RRM_MAIN"`))
			{
				string $returnVal_Generate = `confirmDialog
					-title "Proxy Rig Deletion"
					-message "This will delete your entire proxy rig!\nAre you sure you wisth to proceed?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "critical"`;
				if ($returnVal_Generate == "OK") 
				{
					//select -hi RRM_MAIN;
					//$rigHierarchy = `ls -sl`;
					$rigHierarchy = `listRelatives -ad RRM_MAIN`;
					lockNode -l off $rigHierarchy RRM_MAIN RRM_ProxiesLayer;
					delete RRM_MAIN RRM_ProxiesLayer;
				}
			}
			else
			{
				if (`objExists $eachMod`)
				{
					RRM_DeleteBranch($eachMod);
				}
			}
		}
	}
}

global proc modLocalAxesToggleAll()
{
	$crnt = `ls -sl`;
	string $proxies[];
	$hierarchy = `listRelatives -ad RRM_MAIN`;
	string $crntProxy;
	for ($crntProxy in $hierarchy)
	{
	 if (`objExists ($crntProxy + ".core")`)
	 {
	 	$LocalAxisDisplay = `getAttr ($crntProxy + ".displayLocalAxis")`;
	 	if ($LocalAxisDisplay == 0)
	 	{
	 		setAttr ($crntProxy + ".displayLocalAxis") 1;
	 	}
	 	else
	 	{
	 		setAttr ($crntProxy + ".displayLocalAxis") 0;
	 	}
	 }
	}
	select $crnt;
}

global proc RRM_LocalAxesToggleSelected()
{
	$crnt = `ls -sl`;
	string $crntProxy;
	for ($crntProxy in $crnt)
	{
	 if (`objExists ($crntProxy + ".core")`)
	 {
	 	$LocalAxisDisplay = `getAttr ($crntProxy + ".displayLocalAxis")`;
	 	if ($LocalAxisDisplay == 0)
	 	{
	 		setAttr ($crntProxy + ".displayLocalAxis") 1;
	 	}
	 	else
	 	{
	 		setAttr ($crntProxy + ".displayLocalAxis") 0;
	 	}
	 }
	}
}

global proc RRM_LoadNewModuleAttachNode()
{
	$crnt = `ls -sl`;
	if (`size $crnt` == 1)
	{
		if (`objExists ($crnt[0] + ".core")`)
		{
			$checkMain = `getAttr ($crnt[0] + ".core")`;
			if (($checkMain != "MAIN") && (!`objExists ($crnt[0] + ".parent")`))
			{
				textFieldButtonGrp -e -text $crnt RRM_LoadNewModuleAttachNodeTextField;
			}
			else
			{
				warning "Cannot assign the main control or parent nodes as the new attach node";
			}
		}
		else
		{
			warning "Please select a valid proxy node to load";
		}
	}
	else if (`size $crnt` == 0)
	{
		warning "Please select a proxy node to load";
	}
	else
	{
		warning "Please select only one node. Mirrored parents will automatically be connected properly";
	}
}

global proc RRM_AttachToNewModule(string $modAttachName)
{
	$checkMain = `getAttr ($modAttachName + ".core")`;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	if ((!`objExists $checkMain`) && ($checkMain != "MAIN") && (!`objExists ($checkMain + ".parent")`))
	{
		$parentModules = `ls -sl`;
		$moduleGroups = `listRelatives -p $parentModules`;
		$parentModulesHierarchy = `listRelatives -ad $parentModules`;
		
		string $eachModule;
		for ($eachModule in $parentModulesHierarchy)
		{
			if ($modAttachName == $eachModule)
			{
				select $parentModules;
				error "You cannot attach parent nodes to one of their children";
			}
		}
		
		string $eachModule;
		for ($eachModule in $parentModules)
		{
			string $modType;
			if (`objExists ($eachModule + ".parent")`)
			{
				$modType = 	`getAttr ($eachModule + ".parent")`;
			}
			else if (`objExists ($eachModule + ".modType")`)
			{
				$modType = `getAttr ($eachModule + ".modType")`;
			}
			
			string $modAbsoluteParent[];
			if (`objExists ($eachModule + ".parent")` || $modType == "auxiliary")
			{
				$modParent = `listRelatives -p $eachModule`;
				$modAbsoluteParent[0] = $modParent[0];
				if (`objExists ($eachModule + ".pair")`)
				{
					if (`objExists ($modAttachName + ".pair")`)
					{
						$moduleSideCheck = `getAttr ($eachModule + ".pair")`; 
						if ($moduleSideCheck == "right")
						{
							$eachModule = `getAttr ($eachModule + ".opposite")`;
							$eachModule = ("RRM_" + $eachModule);
						}
						$modAttachSideCheck = `getAttr ($modAttachName + ".pair")`;
						if ($modAttachSideCheck == "right")
						{
							$modAttachName = `getAttr ($modAttachName + ".opposite")`;
							$modAttachName = ("RRM_" + $modAttachName);
						}
					}
					$modAbsoluteParent = `listRelatives -p $modParent[0]`;
				}
				
				//DELETE CONSTRAINTS
				lockNode -l off ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1") $eachModule $modAbsoluteParent[0];
				delete ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1");
 	
				//PARENT IF NOT ALREADY PARENTED
				string $parent[] = `listRelatives -parent $modAbsoluteParent[0]`;
				if (!`gmatch $parent[0] $modAttachName`)
				{
					parent $modAbsoluteParent[0] $modAttachName;
				}
				
				//DELETE OLD CONNECTOR AND CREATE NEW ONE
				$attachCore = `getAttr ($eachModule + ".attachNode")`;
				$connectorHi = `listRelatives -ad ("RRM_" + $attachCore + "_" + $eachModule + "_Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr")`;
				lockNode -l off $connectorHi ("RRM_" + $attachCore + "_" + $eachModule + "_Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr");
				delete ("RRM_" + $attachCore + "_" + $eachModule + "_Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr");
				
				$modName = `getAttr ($eachModule + ".modName")`;
				$prfx = "";
				if (`objExists ($eachModule + ".pair")`)
				{
					$sideCheck = `getAttr ($eachModule + ".pair")`;
					if ($sideCheck == "left")
					{
						$prfx = $lPrfx;
					}
					else
					{
						$prfx = $rPrfx;
					}
				}
				RRM_ProxyConnectors($modName, $prfx, $modAttachName, $eachModule);

				//MAKE NEW CONSTRAINTS
				parentConstraint -mo $modAttachName "RRM_MAIN" $modParent[0];
				scaleConstraint -mo $modAttachName "RRM_MAIN" $modParent[0];
				setAttr ($modParent[0] + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ($modParent[0] + "_scaleConstraint1.RRM_MAINW1") 0;
				
				//CHANGE ATTACH NODE ATTRIBUTE IN PARENT NODE
				$modAttachCore = `getAttr ($modAttachName + ".core")`;
				setAttr -l false ($eachModule + ".attachNode");
				setAttr -type "string" ($eachModule + ".attachNode") $modAttachCore;
				setAttr -l true ($eachModule + ".attachNode");
				
				//CHANGE PARENT ATTRIBUTE IN TOP NODE
				setAttr -l false ($modAbsoluteParent[0] + ".parent");
				setAttr -type "string" ($modAbsoluteParent[0] + ".parent") $modAttachCore;
				
				
				//CHECK TO SEE IF MIRRORED////////////////////////////////////////////////////////////
				if (`objExists ($eachModule + ".pair")`)
				{
					$mirrorModule = `getAttr ($eachModule + ".opposite")`;
					$mirrorModule = ("RRM_" + $mirrorModule); 
					//
					////CHECK FOR MIRROR NODE
					$mirrorModAttachName = $modAttachName;
					$mirrorModAttachName = $mirrorModAttachName;
					

					$mirrorModuleSideCheck = `getAttr ($eachModule + ".pair")`; 
					if ($mirrorModuleSideCheck == "left")
					{
						$mirrorModule = `getAttr ($eachModule + ".opposite")`;
						$mirrorModule = ("RRM_" + $mirrorModule);
					}
					
					if (`objExists ($modAttachName + ".pair")`)
					{						
						$mirrorModAttachSideCheck = `getAttr ($modAttachName + ".pair")`;
						if ($mirrorModAttachSideCheck == "left")
						{
							$mirrorModAttachName = `getAttr ($modAttachName + ".opposite")`;
							$mirrorModAttachName = ("RRM_" + $mirrorModAttachName);
						}
					}

					$mirrorModParent = `listRelatives -p $mirrorModule`;
					
					//DELETE CONSTRAINTS
					lockNode -l off ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1") $mirrorModule;
					delete ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1");
 	
					//DELETE OLD CONNECTOR AND CREATE NEW ONE
					$attachCore = `getAttr ($mirrorModule + ".attachNode")`;
					$connectorHi = `listRelatives -ad ("RRM_" + $attachCore + "_" + $mirrorModule + "_Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr")`;
					lockNode -l off $connectorHi ("RRM_" + $attachCore + "_" + $mirrorModule + "_Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr");
					delete ("RRM_" + $attachCore + "_" + $mirrorModule + "_Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr");
					
					$modName = `getAttr ($mirrorModule + ".modName")`;
					$prfx = "";
					if (`objExists ($mirrorModule + ".pair")`)
					{
						$sideCheck = `getAttr ($mirrorModule + ".pair")`;
						if ($sideCheck == "left")
						{
							$prfx = $lPrfx;
						}
						else
						{
							$prfx = $rPrfx;
						}
					}
					RRM_ProxyConnectors($modName, $prfx, $modAttachName, $mirrorModule);
					
					//MAKE NEW CONSTRAINTS
					if (`objExists $mirrorModAttachName`)
					{
						parentConstraint -mo ($mirrorModAttachName) "RRM_MAIN" $mirrorModParent[0];
						scaleConstraint -mo ($mirrorModAttachName) "RRM_MAIN" $mirrorModParent[0];
						setAttr ($mirrorModParent[0] + "_parentConstraint1.RRM_MAINW1") 0;
						setAttr ($mirrorModParent[0] + "_scaleConstraint1.RRM_MAINW1") 0;

						//CHANGE ATTACH NODE ATTRIBUTE IN PARENT NODE
						$mirrorModAttachCore = `getAttr ($mirrorModAttachName + ".core")`;
						setAttr -l false ($mirrorModule + ".attachNode");
						setAttr -type "string" ($mirrorModule + ".attachNode") $mirrorModAttachCore;
						setAttr -l true ($mirrorModule + ".attachNode");
					}
					lockNode -l on ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1") $mirrorModule;
				}
				lockNode -l on ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1") $eachModule $modAbsoluteParent[0];
			}
			else
			{
				print ("\"" + $eachModule + "\" IS NOT A PARENT MODULE... SKIPPING\n");
			}
		}
		select $parentModules;
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////RESET///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_ResetProxies(int $RRM_PoseSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	string $crntProxy;
	string $topMods[];
	
	if ($RRM_PoseSelection == 2 || $RRM_PoseSelection == 3)
	{//MODULE OR BRANCH
		if (`size $proxies` > 0)
		{//CHECK THAT SOMETHING IS SELECTED
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					if (`objExists ($crntProxy + ".modName")`)
					{
						$modName = `getAttr ($crntProxy + ".modName")`;
						$topMods = `ls $topMods ("RRM_*" + $modName + "_Parent")`;							
						$proxies = `ls -type "transform" ("RRM_*" + $modName + "_*")`;
					}
				}
				else
				{
					$topMods = `ls $crntProxy $topMods`;
				}
			}
			if ($RRM_PoseSelection == 3)
			{
				$hierarchy = `listRelatives -ad $topMods`;
				for ($crntProxy3 in $hierarchy)
				{
					if (`objExists ($crntProxy3 + ".core")`)
					{
						$proxies = `ls $proxies $crntProxy3`;
					}
				}
			}
		}
		else if ($RRM_PoseSelection != 4)
		{
			warning "Nothing Selected. No action taken.";
		}
	}
	if ($RRM_PoseSelection == 4)
	{
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
			if (`objExists ($crntProxy + ".core")`)
			{
				$proxies = `ls $proxies $crntProxy`;
			}
		}
	}
	else if ($RRM_PoseSelection == 1 && `size $proxies` == 0)
	{
		warning "Nothing Selected. No action taken.";
	}
	
	for ($crntProxy in $proxies)
	{
		if (!`gmatch $crntProxy "RRM_ROOT"` && !`objExists ($crntProxy + ".parent")` && `objExists ($crntProxy + ".modName")`)
		{
			if (`getAttr -l ($crntProxy + ".tx")` == 0)
			{
				setAttr ($crntProxy + ".tx") 0;
			}
			if (`getAttr -l ($crntProxy + ".ty")` == 0)
			{
				setAttr ($crntProxy + ".ty") 0;
			}
			if (`getAttr -l ($crntProxy + ".tz")` == 0)
			{
				setAttr ($crntProxy + ".tz") 0;
			}
			if (`getAttr -l ($crntProxy + ".rx")` == 0)
			{
				setAttr ($crntProxy + ".rx") 0;
			}
			
			if (`getAttr -l ($crntProxy + ".ry")` == 0)
			{
				setAttr ($crntProxy + ".ry") 0;
			}
			if (`getAttr -l ($crntProxy + ".rz")` == 0)
			{
				setAttr ($crntProxy + ".rz") 0;
			}
			
			if (`getAttr -l ($crntProxy + ".sx")` == 0)
			{
				setAttr ($crntProxy + ".sx") 1;
			}
			if (`getAttr -l ($crntProxy + ".sy")` == 0)
			{
				setAttr ($crntProxy + ".sy") 1;
			}
			if (`getAttr -l ($crntProxy + ".sz")` == 0)
			{
				setAttr ($crntProxy + ".sz") 1;
			}
			select $originalSelection;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// TRANSFER ///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_TransferProxies(string $side, int $RRM_PoseSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	string $crntProxy;
	string $topMods[];
	
	if ($RRM_PoseSelection == 2 || $RRM_PoseSelection == 3)
	{//MODULE OR BRANCH
		if (`size $proxies` > 0)
		{//CHECK THAT SOMETHING IS SELECTED
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					if (`objExists ($crntProxy + ".modName")`)
					{
						$modName = `getAttr ($crntProxy + ".modName")`;
						$topMods = `ls $topMods ("RRM_*" + $modName + "_Parent")`;							
						$proxies = `ls -type "transform" ("RRM_*" + $modName + "_*")`;
					}
				}
				else
				{
					$topMods = `ls $crntProxy $topMods`;
				}
			}
			if ($RRM_PoseSelection == 3)
			{
				$hierarchy = `listRelatives -ad $topMods`;
				for ($crntProxy3 in $hierarchy)
				{
					if (`objExists ($crntProxy3 + ".core")`)
					{
						$proxies = `ls $proxies $crntProxy3`;
					}
				}
			}
		}
		else if ($RRM_PoseSelection != 4)
		{
			warning "Nothing Selected. No action taken.";
		}
	}
	if ($RRM_PoseSelection == 4)
	{
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
			if (`objExists ($crntProxy + ".core")`)
			{
				$proxies = `ls $proxies $crntProxy`;
			}
		}
	}
	else if ($RRM_PoseSelection == 1 && `size $proxies` == 0)
	{
		warning "Nothing Selected. No action taken.";
	}
	
	//TRANSFER
	for ($crntProxy in $proxies)
	{
		if (`objExists ($crntProxy + ".modName")`)
		{
			if (`objExists ($crntProxy + ".opposite")`)
			{
				if ($side == `getAttr ($crntProxy + ".pair")`)
				{
					string $opp = `getAttr ($crntProxy + ".opposite")`;
					
					//CHECK IF FK MODULE
					$modName = `getAttr ($crntProxy + ".modName")`;
					
					if (`getAttr ("RRM_" + $modName + ".top")` != "fkChain")
					{
						if (`getAttr -l ($crntProxy + ".tx")` == 0)
						{
							setAttr ("RRM_" + $opp + ".tx") (`getAttr ($crntProxy + ".tx")` * -1);
						}
						if (`getAttr -l ($crntProxy + ".ty")` == 0)
						{
							setAttr ("RRM_" + $opp + ".ty") (`getAttr ($crntProxy + ".ty")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".tz")` == 0)
						{
							setAttr ("RRM_" + $opp + ".tz") (`getAttr ($crntProxy + ".tz")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".rx")` == 0)
						{
							setAttr ("RRM_" + $opp + ".rx") (`getAttr ($crntProxy + ".rx")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".ry")` == 0)
						{
							setAttr ("RRM_" + $opp + ".ry") (`getAttr ($crntProxy + ".ry")` * -1);
						}
						if (`getAttr -l ($crntProxy + ".rz")` == 0)
						{
							setAttr ("RRM_" + $opp + ".rz") (`getAttr ($crntProxy + ".rz")` * -1);
						}
						if (`getAttr -l ($crntProxy + ".sx")` == 0)
						{
							setAttr ("RRM_" + $opp + ".sx") (`getAttr ($crntProxy + ".sx")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".sy")` == 0)
						{
							setAttr ("RRM_" + $opp + ".sy") (`getAttr ($crntProxy + ".sy")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".sz")` == 0)
						{
							setAttr ("RRM_" + $opp + ".sz") (`getAttr ($crntProxy + ".sz")` * 1);
						}
					}
					else
					{
						if (`getAttr -l ($crntProxy + ".tx")` == 0)
						{
							setAttr ("RRM_" + $opp + ".tx") (`getAttr ($crntProxy + ".tx")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".ty")` == 0)
						{
							setAttr ("RRM_" + $opp + ".ty") (`getAttr ($crntProxy + ".ty")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".tz")` == 0)
						{
							setAttr ("RRM_" + $opp + ".tz") (`getAttr ($crntProxy + ".tz")` * -1);
						}
						if (`getAttr -l ($crntProxy + ".rx")` == 0)
						{
							setAttr ("RRM_" + $opp + ".rx") (`getAttr ($crntProxy + ".rx")` * -1);
						}
						if (`getAttr -l ($crntProxy + ".ry")` == 0)
						{
							setAttr ("RRM_" + $opp + ".ry") (`getAttr ($crntProxy + ".ry")` * -1);
						}
						if (`getAttr -l ($crntProxy + ".rz")` == 0)
						{
							setAttr ("RRM_" + $opp + ".rz") (`getAttr ($crntProxy + ".rz")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".sx")` == 0)
						{
							setAttr ("RRM_" + $opp + ".sx") (`getAttr ($crntProxy + ".sx")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".sy")` == 0)
						{
							setAttr ("RRM_" + $opp + ".sy") (`getAttr ($crntProxy + ".sy")` * 1);
						}
						if (`getAttr -l ($crntProxy + ".sz")` == 0)
						{
							setAttr ("RRM_" + $opp + ".sz") (`getAttr ($crntProxy + ".sz")` * 1);
						}
					}						
				}
			}
		}
	}
	select $originalSelection;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////PINNING///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_PinProxies(int $on, int $off)
{
	$selected = `ls -sl`;
	string $parentModules[];
	string $prfx = "";
	string $rootCheck;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}

	//CHECK THAT SOMETHING IS SELECTED
	if (`size $selected` > 0)
	{
		//CHECK IF VALID MODULE
		string $each;
		for ($each in $selected)
		{
			if (`objExists ($each + ".modName")`)
			{
				//CHECK IF PAIR, GET PREFIX IF TRUE
				if (`objExists ($each + ".pair")`)
				{
					$sideCheck = `getAttr ($each + ".pair")`;
					if ($sideCheck == "left")
						{$prfx = $lPrfx;}
					else if ($sideCheck == "right")
						{$prfx = $rPrfx;}
				}
				else
				{
					$prfx = "";
				}
				$modName = `getAttr ($each + ".modName")`;
				//CHECK IF ROOT
				$rootCheck = `getAttr ($each + ".core")`;
				{
					if ($rootCheck == "ROOT")
					{
						warning "YOU CANNOT PIN THE ROOT PROXY.";
					}
					else if ($rootCheck == "MAIN")
					{
						warning "YOU CANNOT PIN THE MAIN PROXY.";
					}
					else
					{
						$parentModules = `ls ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_*_Aux") $parentModules`;
					}
				}
			}
		}
		if (`size $parentModules` > 0)
		{
			//GET WORLD SPACE AND SCALE
			string $each2;
			string $mirroredTopNode;
			$topNodeScale = <<1,1,1>>;
			for ($each2 in $parentModules)
			{
				$pinCheck = `getAttr ($each2 + ".pinned")`;
				if ($pinCheck != $on)
				{
					//CHECK IF PAIR, GET PREFIX IF TRUE
					if (`objExists ($each2 + ".pair")`)
					{
						$sideCheck = `getAttr ($each2 + ".pair")`;
						if ($sideCheck == "left")
							{$prfx = $lPrfx;}
						else if ($sideCheck == "right")
							{$prfx = $rPrfx;}
						//GET TOP NODE'S SCALE
						$mirroredTopNode = `getAttr ($each2 + ".modName")`;
						$topNodeScale = `getAttr ("RRM_" + $mirroredTopNode + ".scale")`;
					}
					else 
					{
						$prfx = "";
						$topNodeScale = <<1,1,1>>;
					}
	
					$modLoc = `xform -q -ws -rp $each2`;
					$modRot = `xform -q -ws -ro $each2`;
					
					//GET SCALE
					spaceLocator -n ($each + "_ScaleLctr");
					parent ($each + "_ScaleLctr") RRM_MAIN;
					scaleConstraint $each2 ($each + "_ScaleLctr");
					$modScale = `getAttr ($each + "_ScaleLctr.scale")`;
					delete ($each + "_ScaleLctr");
					
					$modName = `getAttr ($each2 + ".modName")`;
					$topScale = `getAttr ("RRM_" + $prfx + $modName + ".scale")`;
					
					$scaleRatio[0] = ($modScale[0] * $topScale[0] * $topNodeScale.x);
					$scaleRatio[1] = ($modScale[1] * $topScale[1] * $topNodeScale.y);
					$scaleRatio[2] = ($modScale[2] * $topScale[2] * $topNodeScale.z);
					
					//ATTACH NODE
					string $attachNode;
					if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
					{
						$attachNode = `getAttr ("RRM_" + $prfx + $modName + "_Parent.attachNode")`;
					}
					else if (`objExists ("RRM_" + $prfx + $modName + "_Aux")`)
					{
						$attachNode = `getAttr ("RRM_" + $prfx + $modName + "_Aux.attachNode")`;
					}

					//SET CONSTRAINT WEIGHTS
					setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_" + $attachNode + "W0") $off;
					setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") $on;				
					setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_" + $attachNode + "W0") $off;
					setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") $on;
					
					//SET SCALE VALUES
					setAttr (($each2 + ".scale"), $scaleRatio[0], $scaleRatio[1], $scaleRatio[2]);
					//SET ROTATE
					rotate -ws -a $modRot[0] $modRot[1] $modRot[2] $each2;
					//SET SCALE
					move -ws $modLoc[0] $modLoc[1] $modLoc[2] $each2;
					
					////CHANGE COLOR OF CONNECTOR
					
					if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
					{
						//CHANGE COLOR OF CONNECTOR
						setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_ParentConnector.overrideColor") (6 + (7 * $on));

						//SET PIN CHANNEL
						lockNode -l 0 ("RRM_" + $prfx + $modName + "_Parent");
						setAttr -l 0 ("RRM_" + $prfx + $modName + "_Parent.pinned");
						setAttr ("RRM_" + $prfx + $modName + "_Parent.pinned") $on;
						setAttr -l 1 ("RRM_" + $prfx + $modName + "_Parent.pinned");
						lockNode ("RRM_" + $prfx + $modName + "_Parent");
					}
					else if (`objExists ("RRM_" + $prfx + $modName + "_Aux")`)
					{
						//CHANGE COLOR OF CONNECTOR
						setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_Aux_Ctrl.overrideColor") (6 + (7 * $on));

						//SET PIN CHANNEL
						lockNode -l 0 ("RRM_" + $prfx + $modName + "_Aux");
						setAttr -l 0 ("RRM_" + $prfx + $modName + "_Aux.pinned");
						setAttr ("RRM_" + $prfx + $modName + "_Aux.pinned") $on;
						setAttr -l 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
						lockNode ("RRM_" + $prfx + $modName + "_Aux");
					}						
				}
			}
		}
		else
		{
			warning "No valid modules were selected";
		}
	}
	else
	{
		warning "NOTHING SELECTED";
	}
	select $selected;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////TRANSFER TRANSFORMS///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_TransferModTransforms2(string $sourceParent, string $destinationParent)
{
	
	//CHECK WHETHER TO INCLUDE PARENT NODE
	$parentCheck = `checkBox -q -v RRM_TransferParent`;
	
	select -hi $sourceParent;
	select -d "*Shape" "*Constraint1";
	if ($parentCheck == 0)
	{
		select -d $sourceParent;
	}
	$sourceHierarchy = `ls -sl -type "transform"`;
	
	select -hi $destinationParent;
	select -d "*Shape" "*Constraint1";
	if ($parentCheck == 0)
	{
		select -d $destinationParent;
	}
	$destinationHierarchy = `ls -sl -type "transform"`;
		
	if ((`size $sourceHierarchy` > 0) && (`size $destinationHierarchy` > 0))
	{
		int $crntHierarchyMod = 0;
		while (($crntHierarchyMod < `size $sourceHierarchy`) && ($crntHierarchyMod < `size $destinationHierarchy`))
		{
			if (`objExists ($sourceHierarchy[$crntHierarchyMod] + ".modName")` && `objExists ($sourceHierarchy[$crntHierarchyMod] + ".modName")`)
			{
				$sourceT = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".translate")`;
				$sourceR = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".rotate")`;
				$sourceS = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".scale")`;
					
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".tx")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".tx") $sourceT[0];}
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".ty")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".ty") $sourceT[1];}
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".tz")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".tz") $sourceT[2];}
				
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".rx")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".rx") $sourceR[0];}
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".ry")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".ry") $sourceR[1];}
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".rz")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".rz") $sourceR[2];}
					
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".sx")`== 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sx") $sourceS[0];}
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".sy")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sy") $sourceS[1];}
				if (`getAttr -l ($destinationHierarchy[$crntHierarchyMod] + ".sz")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sz") $sourceS[2];}
			}
			$crntHierarchyMod++;
		}
	}
}
global proc RRM_TransferModTransforms()
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	$sourceParent = `ls -sl`;
	$destinationParent = `ls -sl`;
	string $crntProxy;
	
	$lPrfx = "l_";
	$rPrfx = "r_";
	if (`objExists RRM_MAIN.lPrfx`)
	{
		$lPrfx = `getAttr RRM_MAIN.lPrfx`;
		$rPrfx = `getAttr RRM_MAIN.rPrfx`;
	}
	
	int $RRM_TransferSelectionButton = `radioButtonGrp -q -select RRM_TransferSelectionButton`;

	if (`size $proxies` == 2)
	{
		//SELECTED
		if ($RRM_TransferSelectionButton == 1)
		{
			$sourceT = `getAttr ($proxies[0] + ".translate")`;
			$sourceR = `getAttr ($proxies[0] + ".rotate")`;
			$sourceS = `getAttr ($proxies[0] + ".scale")`;


			if (`getAttr -l ($proxies[1] + ".tx")` == 0)
			{setAttr ($proxies[1] + ".tx") $sourceT[0];}
			if (`getAttr -l ($proxies[1] + ".ty")` == 0)
			{setAttr ($proxies[1] + ".ty") $sourceT[1];}
			if (`getAttr -l ($proxies[1] + ".tz")` == 0)
			{setAttr ($proxies[1] + ".tz") $sourceT[2];}
			
			if (`getAttr -l ($proxies[1] + ".rx")` == 0)
			{setAttr ($proxies[1] + ".rx") $sourceR[0];}
			if (`getAttr -l ($proxies[1] + ".ry")` == 0)
			{setAttr ($proxies[1] + ".ry") $sourceR[1];}
			if (`getAttr -l ($proxies[1] + ".rz")` == 0)
			{setAttr ($proxies[1] + ".rz") $sourceR[2];}

			if (`getAttr -l ($proxies[1] + ".sx")` == 0)
			{setAttr ($proxies[1] + ".sx") $sourceS[0];}
			if (`getAttr -l ($proxies[1] + ".sy")` == 0)
			{setAttr ($proxies[1] + ".sy") $sourceS[1];}
			if (`getAttr -l ($proxies[1] + ".sz")` == 0)
			{setAttr ($proxies[1] + ".sz") $sourceS[2];}
		}
		
		//BRANCH
		else if ($RRM_TransferSelectionButton == 2)
		{
			$sourceProxy = $proxies[0];
			$destinationProxy = $proxies[1];
			
			//GET SOURCE PARENT
			if (!`objExists ($sourceProxy + ".parent")`)
			{
				if (`objExists ($sourceProxy + ".modName")`)
				{
					$modName = `getAttr ($sourceProxy + ".modName")`;
					if (`objExists ($sourceProxy + ".pair")`)
					{
						$side = `getAttr ($sourceProxy + ".pair")`;
						if ($side == "left")
						{
							$side = $lPrfx;
						}
						else
						{
							$side = $rPrfx;
						}
						$sourceParent = `ls ("RRM_" + $side + $modName + "_Parent")`;
					}
					else
					{
						$sourceParent = `ls ("RRM_" + $modName + "_Parent")`;							
					}
				}
			}
			else
			{
				$sourceParent = `ls $sourceProxy`;
			}
			
			//GET DESTINATION PARENT
			if (!`objExists ($destinationProxy + ".parent")`)
			{
				if (`objExists ($destinationProxy + ".modName")`)
				{
					$modName = `getAttr ($destinationProxy + ".modName")`;
					if (`objExists ($destinationProxy + ".pair")`)
					{
						$side = `getAttr ($destinationProxy + ".pair")`;
						if ($side == "left")
						{
							$side = $lPrfx;
						}
						else
						{
							$side = $rPrfx;
						}
						$destinationParent = `ls ("RRM_" + $side + $modName + "_Parent")`;
					}
					else
					{
						$destinationParent = `ls ("RRM_" + $modName + "_Parent")`;							
					}
				}
			}
			else
			{
				$destinationParent = `ls $destinationProxy`;
			}
			$sourceModType = `getAttr ($sourceParent[0] + ".parent")`;
			$destinationModType = `getAttr ($destinationParent[0] + ".parent")`;
			
			//CHECK TO SEE IF THEY ARE THE SAME TYPE OF MODULE
			if ($sourceModType == $destinationModType)
			{
				select -hi $sourceParent[0];
				select -d "*Shape" "*Constraint1" "*Grp";
				$sourceHierarchy = `ls -sl`;
				
				select -hi $destinationParent[0];
				select -d "*Shape" "*Constraint1" "*Grp";
				$destinationHierarchy = `ls -sl`;

				//CHECK TO SEE IF SOURCE AND DESTINATION HAVE SAME NUMBER OF NODES				
				if (`size $sourceHierarchy` == `size $destinationHierarchy`)
				{
					//select $sourceParent[0] $destinationParent[0];
					RRM_TransferModTransforms2($sourceParent[0], $destinationParent[0]);
				}
				else
				{
					string $returnVal_Generate = `confirmDialog
						-title "The Source And Destination Branches Have A Different Number Of Nodes."
						-message "The results may not transfer properly.\nProceed?"
						-button "OK" -button "Cancel"
						-defaultButton "OK"
						-cancelButton "Cancel"
						-icon "question"`;
					if ($returnVal_Generate == "OK") 
					{
						//select $sourceParent[0] $destinationParent[0];
						RRM_TransferModTransforms2($sourceParent[0], $destinationParent[0]);
					}
				}
			}
			else
			{
				string $returnVal_Generate = `confirmDialog
					-title "The Modules Are Not Of The Same Type."
					-message "The results may not transfer properly.\nProceed?"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					//select $sourceParent[0] $destinationParent[0];
					RRM_TransferModTransforms2($sourceParent[0], $destinationParent[0]);
				}
			}
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
			-title "Wrong Number Of Objects Seleted"
			-message "Select ONE target node followed by ONE destination node that you want to match to.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	select $originalSelection;
}

//SAVE/LOAD PROXY TRANSFORMS//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

global proc RRM_WritePathProxyTransforms()
{
	int $mayaVer = `about -version`;
	string $mayaFolder;
	string $fileName[];	

	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Transforms (.rrmprox) (*.rrmprox)";
			$fileName = `fileDialog2 -cap "Save Proxy Positions" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_SaveProxyTransforms("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 1
			-fileCommand ( "RRM_SaveProxyTransforms \"" + $mayaFolder + "\"" )
			-actionName "Save";
		}
 }
 else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to save the transforms from.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	} 	
}


global proc RRM_SaveProxyTransforms(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;
		
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
		 if (`objExists ($crntProxy + ".core")`)
		 {
		  $proxies = `ls $proxies $crntProxy`;
		 }
		}
	
	for ($crntProxy in $proxies)
	{
		fprint $fileID ("if (`objExists " + $crntProxy + "`) {");
		
		if (`getAttr -l ($crntProxy + ".tx")` == 0)
		{
			$crntTX = `getAttr ($crntProxy + ".tx")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".tx "+ $crntTX +";} ");
		}
		if (`getAttr -l ($crntProxy + ".ty")` == 0)
		{
			$crntTY = `getAttr ($crntProxy + ".ty")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".ty "+ $crntTY +";} ");
		}
		if (`getAttr -l ($crntProxy + ".tz")` == 0)
		{
			$crntTZ = `getAttr ($crntProxy + ".tz")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".tz "+ $crntTZ +";} ");
		}		

		if (`getAttr -l ($crntProxy + ".rx")` == 0)
		{
			$crntRX = `getAttr ($crntProxy + ".rx")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".rx "+ $crntRX +";} ");
		}
		if (`getAttr -l ($crntProxy + ".ry")` == 0)
		{
			$crntRY = `getAttr ($crntProxy + ".ry")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".ry "+ $crntRY +";} ");
		}
		if (`getAttr -l ($crntProxy + ".rz")` == 0)
		{
			$crntRZ = `getAttr ($crntProxy + ".rz")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".rz "+ $crntRZ +";} ");
		}		

		if (`getAttr -l ($crntProxy + ".sx")` == 0)
		{
			$crntSX = `getAttr ($crntProxy + ".sx")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".sx` == 0){setAttr " + $crntProxy + ".sx "+ $crntSX +";} ");
		}
		if (`getAttr -l ($crntProxy + ".sy")` == 0)
		{
			$crntSY = `getAttr ($crntProxy + ".sy")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".sy` == 0){setAttr " + $crntProxy + ".sy "+ $crntSY +";} ");
		}
		if (`getAttr -l ($crntProxy + ".sz")` == 0)
		{
			$crntSZ = `getAttr ($crntProxy + ".sz")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".sz` == 0){setAttr " + $crntProxy + ".sz "+ $crntSZ +";} ");
		}
		fprint $fileID "}\n";

	}
	fclose $fileID;
	select $originalSelection;		
}


global proc RRM_ReadPathProxyTransform()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder2;
	string $fileName[];

	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Transforms (.rrmprox) (*.rrmprox)";
			$fileName = `fileDialog2 -fileMode 1 -cap "Load Proxy Positions" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_LoadModProxyTransforms("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 0
			-fileCommand ( "RRM_LoadModProxyTransforms \"" + $mayaFolder2 + "\"" )
			-actionName "Load";
		}
 }
 else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to load the transforms to.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
}

global proc RRM_LoadModProxyTransforms(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING POSE FROM "+$result2+"...\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		//print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}

//SAVE/LOAD PROXY SETUP///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

global proc RRM_WritePathProxySetup()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder;
	string $fileName[];

	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Setup (.rrmsstp) (*.rrmsstp)";
			$fileName = `fileDialog2 -cap "Save Proxy Setup" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_SaveProxySetup("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 1
			-fileCommand ( "RRM_SaveProxySetup \"" + $mayaFolder + "\"" )
			-actionName "Save";
		}
 }
 else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to save to a setup file.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	} 
}


global proc RRM_SaveProxySetup(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;
		
	$originalSelection = `ls -sl`;
	string $proxies[];
	string $modules[];
	

	$lPrfx = `getAttr "RRM_MAIN.lPrfx"`;
	$rPrfx = `getAttr "RRM_MAIN.rPrfx"`;

	select -hi RRM_MAIN;
	$hierarchy = `ls -sl`;
	
	//FIND MODULE NODES
	for ($crntProxy in $hierarchy)
	{
		if (`objExists ($crntProxy + ".core")`)
		{
			$proxies = `ls $proxies $crntProxy`;
		}
	}
	
	//FIND PROXIES
	for ($crntProxy in $hierarchy)
	{
		if (`objExists ($crntProxy + ".top")`)
		{
			$modules = `ls $modules $crntProxy`;
		}
	}
	
	//CREATE MAIN AND ROOT PROXIES8
	fprint $fileID ("RRM_CreateProxyMainProxy(0, \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
	
	//CREATE MODULES
	for ($each in $modules)
	{
		//CHECK TYPE OF MODULE, MOD NAME, ATTACH NODE
		string $modType = `getAttr ($each + ".top")`;
		string $modName = `getAttr ($each + ".core")`;
		string $attachNode = `getAttr ($each + ".parent")`;
		$attachNode = ("RRM_" + $attachNode);
		int $mirror = 0;
		int $single;
		if (`objExists ($each + ".pair")`)
		{
			$mirror = 1;
			if ($modType == "arm"||$modType == "leg")
			{
				$mirror = 2;
			}
		}
		else if ($modType == "arm")
		{
			string $single = `getAttr ($each + ".single")`;
			if ($single == "left")
			{
				$mirror = 1;
			}
			if ($single == "right")
			{
				$mirror = 3;
			}
		}
		else if ($modType == "leg")
		{
			$mirror = 1;
		}
		
		
		//DEFINE CUSTOM ATTRIBUTES OF EACH MODULE
		//SPLINE
		int $splineNum;
		int $twistAxis;
		//ARM/LEG
		int $upperNum;
		int $lowerNum;
		int $elbowNum;
		int $elbowJoints;
		int $kneeNum;
		int $kneeJoints;
		int $toon;
		//Fk CHAIN
		int $chainNum;
		int $jointNum;
		int $direction;
		int $enableIk;
		//HEAD
		int $jaw;
		//LOOKAT
		int $eyeNum;

		//SELECT
		fprint $fileID ("select " + $attachNode + ";\n");
		
		if ($modType == "spline")
		{
			$splineNum = `getAttr ($each + ".jointsNum")`;
			$twistAxis = 2;
			if (`objExists ($each + ".twistAxis")`)
			{
				$twistAxis = `getAttr ($each + ".twistAxis")`;
				$twistAxis++;
			}
			fprint $fileID ("RRM_CreateProxySpline(\"" + $modName + "\"," + $splineNum + "," + $twistAxis + "," + $mirror + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
		}
		if ($modType == "arm")
		{
			$upperNum = `getAttr ($each + ".upperArmNum")`;
			$lowerNum = `getAttr ($each + ".lowerArmNum")`;
			$elbowNum = `getAttr ($each + ".elbowNum")`;
			$elbowJoints = `getAttr ($each + ".elbowJoints")`;
			if (`objExists ($each + ".toonArms")`)
				{$toon = `getAttr ($each + ".toonArms")`;}
			fprint $fileID ("RRM_CreateProxyArm(\"" + $modName + "\"," + $upperNum + "," + $lowerNum + "," + $elbowNum + "," + $elbowJoints + "," + $toon + "," + $mirror + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
		}
		if ($modType == "leg")
		{
			$upperNum = `getAttr ($each + ".upperLegNum")`;
			$lowerNum = `getAttr ($each + ".lowerLegNum")`;
			$kneeNum = `getAttr ($each + ".kneeNum")`;
			$kneeJoints = `getAttr ($each + ".kneeJoints")`;
			if (`objExists ($each + ".toonLegs")`)
				{$toon = `getAttr ($each + ".toonLegs")`;}
			fprint $fileID ("RRM_CreateProxyLeg(\"" + $modName + "\"," + $upperNum + "," + $lowerNum + "," + $kneeNum + "," + $kneeJoints + "," + $toon + "," + $mirror + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
		}
		if ($modType == "fkChain")
		{
			$chainNum = `getAttr ($each + ".chainsNum")`;
			$jointNum = `getAttr ($each + ".jointsNum")`;
			$direction = `getAttr ($each + ".direction")`;
			$direction2 = `getAttr ($each + ".direction")`;
			if ($direction > 3)
			{
				$direction2 = ($direction2 - 3);
				$direction = 0;
			}
			else
			{
				$direction2 = 0;
			}
			if (`objExists ($each + ".ikEnabled")`)
			{
				$enableIk = `getAttr ($each + ".ikEnabled")`;
				fprint $fileID ("RRM_CreateProxyFkChain(\"" + $modName + "\"," + $chainNum + "," + $jointNum + "," + $direction + "," + $direction2 + "," + $mirror + "," + $enableIk + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
			}
		}
		if ($modType == "head")
		{
			$jaw = `getAttr ($each + ".jaw")`;
			fprint $fileID ("RRM_CreateProxyHead(\"" + $modName + "\"," + $jaw + "," + $mirror + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
		}
		if ($modType == "lookAt")
		{
			$eyeNum = `getAttr ($each + ".eyeNum")`;
			$direction = `getAttr ($each + ".direction")`;
			$direction2 = `getAttr ($each + ".direction")`;
			if ($direction > 3)
			{
				$direction2 = ($direction2 - 3);
				$direction = 0;
			}
			else
			{
				$direction2 = 0;
			}
			fprint $fileID ("RRM_CreateProxyLookAt(\"" + $modName + "\"," + $eyeNum + "," + $direction + "," + $direction2 + "," + $mirror + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
		}
		if ($modType == "auxiliary")
		{
			fprint $fileID ("RRM_CreateProxyAuxiliary(\"" + $modName + "\"," + $mirror + ", \"" + $lPrfx + "\", \"" + $rPrfx + "\");\n");
		}
	}
				
	for ($crntProxy in $proxies)
	{
		fprint $fileID ("if (`objExists " + $crntProxy + "`) {");
		
		//SET PINNING
		if (`objExists ($crntProxy + ".pinned")`)
		{
			$pinned = `getAttr ($crntProxy + ".pinned")`;
			if ($pinned == 1)
			{
				fprint $fileID ("select " + $crntProxy + "; ");
				fprint $fileID ("RRM_PinProxies(1, 0); ");
			}
		}
		
		if (`getAttr -l ($crntProxy + ".tx")` == 0)
		{
			$crntTX = `getAttr ($crntProxy + ".tx")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tx` == 0){setAttr " + $crntProxy + ".tx "+ $crntTX +";} ");
		}
		if (`getAttr -l ($crntProxy + ".ty")` == 0)
		{
			$crntTY = `getAttr ($crntProxy + ".ty")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".ty` == 0){setAttr " + $crntProxy + ".ty "+ $crntTY +";} ");
		}
		if (`getAttr -l ($crntProxy + ".tz")` == 0)
		{
			$crntTZ = `getAttr ($crntProxy + ".tz")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".tz` == 0){setAttr " + $crntProxy + ".tz "+ $crntTZ +";} ");
		}		

		if (`getAttr -l ($crntProxy + ".rx")` == 0)
		{
			$crntRX = `getAttr ($crntProxy + ".rx")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".rx` == 0){setAttr " + $crntProxy + ".rx "+ $crntRX +";} ");
		}
		if (`getAttr -l ($crntProxy + ".ry")` == 0)
		{
			$crntRY = `getAttr ($crntProxy + ".ry")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".ry` == 0){setAttr " + $crntProxy + ".ry "+ $crntRY +";} ");
		}
		if (`getAttr -l ($crntProxy + ".rz")` == 0)
		{
			$crntRZ = `getAttr ($crntProxy + ".rz")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".rz` == 0){setAttr " + $crntProxy + ".rz "+ $crntRZ +";} ");
		}		

		if (`getAttr -l ($crntProxy + ".sx")` == 0)
		{
			$crntSX = `getAttr ($crntProxy + ".sx")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".sx` == 0){setAttr " + $crntProxy + ".sx "+ $crntSX +";} ");
		}
		if (`getAttr -l ($crntProxy + ".sy")` == 0)
		{
			$crntSY = `getAttr ($crntProxy + ".sy")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".sy` == 0){setAttr " + $crntProxy + ".sy "+ $crntSY +";} ");
		}
		if (`getAttr -l ($crntProxy + ".sz")` == 0)
		{
			$crntSZ = `getAttr ($crntProxy + ".sz")`;
			fprint $fileID ("if (`getAttr -l " + $crntProxy + ".sz` == 0){setAttr " + $crntProxy + ".sz "+ $crntSZ +";} ");
		}
		fprint $fileID "}\n";

	}
	fprint $fileID "select -cl;";
	fclose $fileID;
	select $originalSelection;		
}


global proc RRM_ReadPathProxySetup()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder2;
	string $fileName[];

	if (!`objExists "RRM_MAIN"` || !`objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Setup (.rrmsstp) (*.rrmsstp) ";
			$fileName = `fileDialog2 -fileMode 1 -cap "Load Proxy Setup" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_LoadModProxySetup("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 0
			-fileCommand ( "RRM_LoadModProxySetup \"" + $mayaFolder2 + "\"" )
			-actionName "Load";
		}
 }
 else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "Proxy Rig Already Exists"
			-message "You must first delete the existing proxy rig to load a new one. Do you wish to delete the proxy rig and then load a proxy?.\n"
			-button "Yes"
			-button "Cancel"
			-defaultButton "Cancel"
			-cancelButton "Cancel"
			-icon "critical"`;
			
			if ($returnVal_Generate == "Yes")
			{
				RRM_DeleteProxyRig;
				fileBrowserDialog -mode 0
				-fileCommand ( "RRM_LoadModProxySetup \"" + $mayaFolder2 + "\"" )
				-actionName "Load";
			}
	} 
}

global proc RRM_LoadModProxySetup(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING POSE FROM "+$result2+"...\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}


///////////////////TUTORIAL LINKS
global proc RRM_GotToTutorial(float $time)
{
	launch -web ("https://youtu.be/sX_iUaE70iQ?t=" + $time);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE FINAL RIG//////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_BasicControl(string $name, string $direction, float $size, int $volume, float $length)
{
	circle -n $name -nr 1 0 0 -r 1 -s 18 -ch 0;
	move 0 0 1.53 ($name + ".cv[5]");
	move 0 -0.05 1 ($name + ".cv[6]");
	move 0 0.05 1 ($name + ".cv[4]");
	if ($volume == 1)
	{
		duplicate -n ($name + "2") $name;
		move -r -os ($length * 0.8) 0 0 ($name + "2");
		makeIdentity -apply 1 -t 1 ($name + "2");
        curve -n ($name + "3") -d 1 -p 0 0 1.35333 -p ($length * 0.8) 0 1.35333 -k 0 -k 1 ;
		rename `listRelatives -c ($name + "3")` ($name + "3Shape");
        curve -n ($name + "4") -d 1 -p 0 1 0 -p ($length * 0.8) 1 0 -k 0 -k 1 ;
		rename `listRelatives -c ($name + "4")` ($name + "4Shape");
        curve -n ($name + "5") -d 1 -p 0 -1 0 -p ($length * 0.8) -1 0 -k 0 -k 1 ;
		rename `listRelatives -c ($name + "5")` ($name + "5Shape");
        curve -n ($name + "6") -d 1 -p 0 0 -1 -p ($length * 0.8) 0 -1 -k 0 -k 1 ;
		rename `listRelatives -c ($name + "6")` ($name + "6Shape");
		parent -r -s ($name + "2Shape") ($name + "3Shape") ($name + "4Shape") ($name + "5Shape") ($name + "6Shape") $name;
		delete ($name + "2") ($name + "3") ($name + "4") ($name + "5") ($name + "6");
		
        addAttr -ln "volumeAppearance"  -at bool -dv 0 $name;
        setAttr -e-keyable true ($name + ".volumeAppearance");
        
        connectAttr -f ($name + ".volumeAppearance") ($name + "2Shape.v");
        connectAttr -f ($name + ".volumeAppearance") ($name + "3Shape.v");
        connectAttr -f ($name + ".volumeAppearance") ($name + "4Shape.v");
        connectAttr -f ($name + ".volumeAppearance") ($name + "5Shape.v");
        connectAttr -f ($name + ".volumeAppearance") ($name + "6Shape.v");
	}

	if ($direction == "y")
	{
	  rotate -r -os 0 0 90 $name; 
	}
	else if ($direction == "z")
	{
  	rotate -r -os 0 90 90 $name;	  
	}
	
	scale -r 1 $size $size $name;
	makeIdentity -apply true -r 1 -s 1 $name;
}

global proc RRM_MoveablePivot_Ctrl(string $name, float $size)
{
	//CREATE MOVEABLE PIVOT CONTROL
	circle -n ($name + "_Outer1") -nr 0 1 0 -sw 10 -r .25 -ch 0;
	
	circle -n ($name + "_Inner1") -nr 0 1 0 -sw 10 -r 2 -ch 0;
	
	curve -n ($name + "_leftLine1") -d 1 -p 0 0 -0.25 -p 0 0 -2 -k 0 -k 1 ;
	rename `listRelatives -c ($name + "_leftLine1")` ($name + "_leftLine1Shape");
	curve -n ($name + "_rightLine1") -d 1 -p -0.043412 0 -0.246202 -p -0.347296 0 -1.969616 -k 0 -k 1 ;
	rename `listRelatives -c ($name + "_rightLine1")` ($name + "_RightLine1Shape");
	parent -r -s ($name + "_Inner1Shape") ($name + "_leftLine1Shape") ($name + "_RightLine1Shape") ($name + "_Outer1");
	delete ($name + "_Inner1") ($name + "_leftLine1") ($name + "_rightLine1");
	rotate -r 0 -5 0 ($name + "_Outer1");
	duplicate -rr -n ($name + "_Outer2") ($name + "_Outer1");
	rotate -r 0 -90 0 ($name + "_Outer2");
	duplicate -rr -n ($name + "_Outer3") ($name + "_Outer1");
	rotate -r 0 -180 0 ($name + "_Outer3");
	duplicate -rr -n ($name + "_Outer4") ($name + "_Outer1");
	rotate -r 0 -270 0 ($name + "_Outer4");
	duplicate ($name + "_Outer1") ($name + "_Outer2") ($name + "_Outer3") ($name + "_Outer4");
	rotate -r 0 0 90 ($name + "_Outer5") ($name + "_Outer6") ($name + "_Outer7") ($name + "_Outer8");
	duplicate ($name + "_Outer1") ($name + "_Outer2") ($name + "_Outer3") ($name + "_Outer4");
	rotate -r 90 0 0 ($name + "_Outer9") ($name + "_Outer10") ($name + "_Outer11") ($name + "_Outer12");
	curve -n $name -d 1 -p 0.25 0 0 -p -0.25 0 0 -k 0 -k 1 ;
	rename `listRelatives -c $name` ($name + "Shape");
	curve -n ($name + "_Line1") -d 1 -p 0 0.25 0 -p 0 -0.25 0 -k 0 -k 1 ;
	rename `listRelatives -c ($name + "_Line1")` ($name + "_Line1Shape");
	curve -n ($name + "_Line2") -d 1 -p 0 0 0.25 -p 0 0 -0.25 -k 0 -k 1 ;
	rename `listRelatives -c ($name + "_Line2")` ($name + "_Line2Shape");
	makeIdentity -apply true -r 1 ($name + "_Outer1") ($name + "_Outer2") ($name + "_Outer3") ($name + "_Outer4") ($name + "_Outer5") ($name + "_Outer6") ($name + "_Outer7") ($name + "_Outer8") ($name + "_Outer9") ($name + "_Outer10") ($name + "_Outer11") ($name + "_Outer12");
	$shapes = `listRelatives -f -c -type "nurbsCurve" ($name + "_Outer1") ($name + "_Outer2") ($name + "_Outer3") ($name + "_Outer4") ($name + "_Outer5") ($name + "_Outer6") ($name + "_Outer7") ($name + "_Outer8") ($name + "_Outer9") ($name + "_Outer10") ($name + "_Outer11") ($name + "_Outer12") ($name + "_Line1") ($name + "_Line2") `;
	for ($each in $shapes)
	{
		parent -r -s $each $name;
	}
	delete ($name + "_Outer1") ($name + "_Outer2") ($name + "_Outer3") ($name + "_Outer4") ($name + "_Outer5") ($name + "_Outer6") ($name + "_Outer7") ($name + "_Outer8") ($name + "_Outer9") ($name + "_Outer10") ($name + "_Outer11") ($name + "_Outer12") ($name + "_Line1") ($name + "_Line2");
	setAttr (($name + ".scale"), $size, $size, $size);
	makeIdentity -apply 1 -s 1 $name;
	group -n ($name + "Grp") $name;
}


global proc RRM_ColorControls(string $modRigName)
{
	//LEFT
	//MAIN BLUE IS 6
	//SECONDARY BLUE IS 18
	
	//RIGHT
	//MAIN RED IS 13
	//SECONDARY RED IS 21
	
	//CENTER
	//MAIN GREEN IS 14
	//SECONDARY GREEN IS 27
	
	select -hi ($modRigName + "MAIN_Ctrl");
	
	$controls= `ls -sl -type "nurbsCurve"`;
	string $crnt;
	for ($crnt in $controls)
	{
		$crntParent = `listRelatives -parent $crnt`;
		string $parentNode = $crntParent[0];
		
		if (`objExists ($parentNode + ".modRigName")`)
		{
			if (!`objExists ($parentNode + ".leftControl")` && !`objExists ($parentNode + ".rightControl")`)
			{
				if (!`gmatch $parentNode ($modRigName + "*Curve*_Ctrl")`)
				{//MAIN NON-MIRRORED CONTROLS
					setAttr ($crnt + ".overrideEnabled") 1;
					setAttr ($crnt + ".overrideColor") 14;
				}
				else
				{//MAIN NON-MIRRORED CURVE CONTROLS
					setAttr ($crnt + ".overrideEnabled") 1;
					setAttr ($crnt + ".overrideColor") 27;
				}
			}
			else
			{//MIRRORED CONTROLS
				if (`objExists ($parentNode + ".rightControl")`)
				{//RIGHT CONTROLS
					if (!`gmatch $parentNode ($modRigName + "*Curve*_Ctrl")` && !`gmatch $parentNode ($modRigName + "*Twist_Ctrl")`)
					{//MAIN NON-MIRRORED CONTROLS
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 6;
					}
					else
					{
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 18;
					}					
				}
				else if (`objExists ($parentNode + ".leftControl")`)
				{//LEFT CONTROLS
					if (!`gmatch $parentNode ($modRigName + "*Curve*_Ctrl")` && !`gmatch $parentNode ($modRigName + "*Twist_Ctrl")`)
					{//MAIN NON-MIRRORED CONTROLS
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 13;
					}
					else
					{
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 21;
					}					
				}
			}
		}
	}
}


//ADD CORE NAME
global proc RRM_CoreName(string $modControls[])
{
	for ($crntModControl in $modControls)
	{
		addAttr -ln "modCoreName" -dt "string" $crntModControl;
		setAttr -e -k 1 ($crntModControl + ".modCoreName");
	}
}

//ADD CONTROL NAME
global proc RRM_ControlName(string $modRigName, string $rigGrp, string $modControls[])
{
	for ($crntModControl in $modControls)
	{
		string $controlName = endString($crntModControl, (`size($crntModControl)` - `size($modRigName)`));
		if (!`objExists ($crntModControl + ".modControlName")`)
		{
			addAttr -ln "modControlName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modControlName");
			setAttr -type "string" ($crntModControl + ".modControlName") $controlName;
			setAttr -l 1 -k 0 ($crntModControl + ".modControlName");
		}
	}
}

//SET UP ORIENTATION TO PARENT NODE
global proc RRM_ParentOrient(string $modRigName, string $modCore, string $modAttachNode, string $parentOrient)
{
	if ($modAttachNode != "ROOT")
	{
		addAttr -ln "parentOrient" -at double -min 0 -max 1 -dv 1 $parentOrient;
		setAttr -e -k 1 ($parentOrient + ".parentOrient");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_orientConstraint1." + $modRigName + "" + $modAttachNode + "JntW1");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_orientConstraint1." + $modRigName + "" + $modAttachNode + "JntW1");
	}
	else
	{
		addAttr -ln "ROOT_Parent" -at "enum" -en "ROOT:ROOTSecondary:" $parentOrient;
		setAttr -e -k 1 ($parentOrient + ".ROOT_Parent");
		addAttr -ln "parentOrient" -at double -min 0 -max 1 -dv 1 $parentOrient;
		setAttr -e -k 1 ( $parentOrient + ".parentOrient");		
  
		//CREATE NODES FOR BLENDING BETWEEN THE TWO ROOT CHOICES AND MAIN CONTROL
		
		//MODULE GROUP
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ParentMD");
		shadingNode -asUtility reverse -n ($modCore + "_ParentReverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ParentMD.input2X");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ParentReverse.inputX");
		connectAttr -force ($modCore + "_ParentReverse.outputX") ($modCore + "_ParentMD.input2Y");
		setAttr ($modCore + "_ParentMD.input1X") 1;
		setAttr ($modCore + "_ParentMD.input1Y") 1;
		
		//SECOND MULTIPLY DIVIDE TO ZERO OUT BOTH ROOT CHOICES WHEN PARENT ORIENT SET TO ZERO
		shadingNode -asUtility multiplyDivide -n ($modCore + "_Parent2MD");
		connectAttr -force ($modCore + "_ParentMD.outputX") ($modCore + "_Parent2MD.input1X");
		connectAttr -force ($modCore + "_ParentMD.outputY") ($modCore + "_Parent2MD.input1Y");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_Parent2MD.input2X");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_Parent2MD.input2Y");
		
		//CONNECT MULTIPLY/DIVIDE TO ORIENT CONSTRAINT
		connectAttr -force ($modCore + "_Parent2MD.outputY") ($modCore + "_orientConstraint1." + $modRigName + "ROOT_CtrlW1");
		connectAttr -force ($modCore + "_Parent2MD.outputX") ($modCore + "_orientConstraint1." + $modRigName + "ROOTSecondary_CtrlW2");
		
		connectAttr -force ($modCore + "_Parent2MD.outputY") ($modCore + "_pointConstraint1." + $modRigName + "ROOT_CtrlW1");
		connectAttr -force ($modCore + "_Parent2MD.outputX") ($modCore + "_pointConstraint1." + $modRigName + "ROOTSecondary_CtrlW0");
				
		//MODULE SCALEG
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ScaleGrp_ParentMD");
		shadingNode -asUtility reverse -n ($modCore + "_ScaleGrp_ParentReverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_ParentMD.input2X");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_ParentReverse.inputX");
		connectAttr -force ($modCore + "_ScaleGrp_ParentReverse.outputX") ($modCore + "_ScaleGrp_ParentMD.input2Y");
		setAttr ($modCore + "_ScaleGrp_ParentMD.input1X") 1;
		setAttr ($modCore + "_ScaleGrp_ParentMD.input1Y") 1;
		
		//SECOND MULTIPLY DIVIDE TO ZERO OUT BOTH ROOT CHOICES WHEN PARENT ORIENT SET TO ZERO
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ScaleGrp_Parent2MD");
		connectAttr -force ($modCore + "_ScaleGrp_ParentMD.outputX") ($modCore + "_ScaleGrp_Parent2MD.input1X");
		connectAttr -force ($modCore + "_ScaleGrp_ParentMD.outputY") ($modCore + "_ScaleGrp_Parent2MD.input1Y");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_Parent2MD.input2X");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_Parent2MD.input2Y");
		
		//CONNECT MULTIPLY/DIVIDE TO ORIENT CONSTRAINT
		connectAttr -force ($modCore + "_ScaleGrp_Parent2MD.outputY") ($modCore + "_ScaleGrp_orientConstraint1." + $modRigName + "ROOT_CtrlW1");
		connectAttr -force ($modCore + "_ScaleGrp_Parent2MD.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modRigName + "ROOTSecondary_CtrlW0");
	 
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_parentConstraint1." + $modRigName + "ROOTSecondary_CtrlW0");
		
		shadingNode -asUtility reverse -n ($modCore + "_ScaleGrp_Parent2Reverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_Parent2Reverse.inputX");

		connectAttr -force ($modCore + "_ScaleGrp_Parent2Reverse.outputX") ($modCore + "_ScaleGrp_parentConstraint1." + $modRigName + "ROOT_CtrlW1");
		
		//CHECK IF LEG, AND CHANGE TO ROOT Secondary
		if (`objExists ($modCore + "_FootIk_Ctrl")`)
		{
			setAttr ($parentOrient + ".ROOT_Parent") 1;
		}
	}
	//MODULE
	shadingNode -asUtility reverse -n ($modCore + "_ParentOrientReverse");
	connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ParentOrientReverse.inputX");
	connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_orientConstraint1." + $modCore + "_OffsetLctrW0");
	if (`objExists ($modCore + "_ScaleGrp_orientConstraint1." + $modCore + "_OffsetLctrW0")`)
	{
		connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modCore + "_OffsetLctrW0");
	}
	else if (`objExists ($modCore + "_ScaleGrp_orientConstraint1." + $modCore + "_OffsetLctrW2")`)
	{
		connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modCore + "_OffsetLctrW2");
	}
	if (`objExists ($modCore + "_pointConstraint1." + $modRigName + "ROOTLocLctrW2")`)
	{
		connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_pointConstraint1." + $modRigName + "ROOTLocLctrW2");
	}	
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE ROOT MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigRoot(string $modRigName, string $rigGrp, string $lPrfx, string $rPrfx, int $ea)
{
	$twistAxis = 1;
	if (`objExists ("RRM_ROOT.twistAxis")`)
	{
		$twistAxis = `getAttr ("RRM_ROOT.twistAxis")`;
	}
	//CREATE TOP GROUP
	select -cl;
	group -em -n $rigGrp;

	//CREATE MAIN CTRL OFFSET
	if ($ea == 1)
	{
		circle -nr 0 1 0 -n ($modRigName + "MAIN_Offset_Ctrl") -r 9.0 -sw 360 -ch 0;
		setAttr ($modRigName + "MAIN_Offset_CtrlShape.overrideEnabled") 1;
		setAttr ($modRigName + "MAIN_Offset_CtrlShape.overrideColor") 16;
	}
	else
	{
		curve -n ($modRigName + "MAIN_Offset_Ctrl") -d 1 -p 0 0 16 -p 7 0 9 -p 7 0 7 -p 9 0 7 -p 13.328837 0 0.00207916 -p 9 0 -7 -p 7 0 -7 -p 7 0 -9 -p 0 0 -13.326758 -p -7 0 -9 -p -7 0 -7 -p -9 0 -7 -p -13.328837 0 0.00207916 -p -9 0 7 -p -7 0 7 -p -7 0 9 -p 0 0 16 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
		rename `listRelatives -c ($modRigName + "MAIN_Offset_Ctrl")` ($modRigName + "MAIN_Offset_CtrlShape");
		setAttr ($modRigName + "MAIN_Offset_CtrlShape.overrideEnabled") 1;
		setAttr ($modRigName + "MAIN_Offset_CtrlShape.overrideColor") 14;
	}

	//CREATE MAIN CONTROLLER///////////////////////////////////////////////////////////////
	if ($ea == 1)
	{
		circle -n ($modRigName + "MAIN_Ctrl") -nr 0 1 0 -r 8.2 -ch 0;
		setAttr ($modRigName + "MAIN_CtrlShape.overrideEnabled") 1;
		setAttr ($modRigName + "MAIN_CtrlShape.overrideColor") 16;			
	}
	else
	{
		circle -n ($modRigName + "MAIN_Ctrl") -nr 0 1 0 -r 8.2 -ch 0;
		curve -n ($modRigName + "Arrow1") -d 1 -p 3 0 8 -p 3 0 9 -p 5 0 9 -p 0 0 12 -p -5 0 9 -p -3 0 9 -p -3 0 8 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ($modRigName + "Arrow1")` ($modRigName + "Arrow1Shape");
		circle -n ($modRigName + "Outer1") -nr 0 1 0 -sw 48.9 -r 8.545 -ch 0;
		rotate -r 0 110.55 0 ($modRigName + "Outer1");
		duplicate -rr ($modRigName + "Arrow1") ($modRigName + "Outer1");
		rotate -r 0 90 0 ($modRigName + "Arrow2") ($modRigName + "Outer2");
		duplicate -rr ($modRigName + "Arrow1") ($modRigName + "Outer1");
		rotate -r 0 180 0 ($modRigName + "Arrow3") ($modRigName + "Outer3");
		duplicate -rr ($modRigName + "Arrow1") ($modRigName + "Outer1");
		rotate -r 0 270 0 ($modRigName + "Arrow4") ($modRigName + "Outer4");
		makeIdentity -apply true -r 1 ($modRigName + "MAIN_Ctrl") ($modRigName + "Arrow1") ($modRigName + "Outer1") ($modRigName + "Arrow2") ($modRigName + "Outer2") ($modRigName + "Arrow3") ($modRigName + "Outer3") ($modRigName + "Arrow4") ($modRigName + "Outer4") ;
		parent -r -s ($modRigName + "Arrow1Shape") ($modRigName + "Outer1Shape") ($modRigName + "Arrow2Shape") ($modRigName + "Outer2Shape") ($modRigName + "Arrow3Shape") ($modRigName + "Outer3Shape") ($modRigName + "Arrow4Shape") ($modRigName + "Outer4Shape") ($modRigName + "MAIN_Ctrl");
		delete ($modRigName + "Arrow1") ($modRigName + "Outer1") ($modRigName + "Arrow2") ($modRigName + "Outer2") ($modRigName + "Arrow3") ($modRigName + "Outer3") ($modRigName + "Arrow4") ($modRigName + "Outer4") ;
		move -r 0 0 2 ($modRigName + "Arrow1Shape.cv[3]") ;
		
		//ADD RRM TO THE MAIN CONTROL
		curve -n ($modRigName + "R1_OuterCurve") -p -0.407227 0 -0.429492 -p -0.263487 0 -0.429492 -p 0.0239912 0 -0.432182 -p 0.153059 0 -0.418734 -p 0.253227 0 -0.330969 -p 0.296535 0 -0.194139 -p 0.237588 0 -0.0195534 -p 0.0868775 0 0.0315034 -p 0.040764 0 0.0378381 -p 0.0375 0 0.0386719 -p 0.0382526 0 0.0396925 -p 0.0951021 0 0.0649485 -p 0.176419 0 0.152211 -p 0.284981 0 0.330214 -p 0.348426 0 0.427287 -p 0.349805 0 0.429492 -p 0.345946 0 0.429492 -p 0.276161 0 0.429492 -p 0.209868 0 0.429492 -p 0.206836 0 0.429492 -p 0.205116 0 0.426765 -p 0.154922 0 0.348158 -p 0.10053 0 0.260202 -p 0.0030441 0 0.11572 -p -0.0459097 0 0.0714475 -p -0.0972157 0 0.0491625 -p -0.149125 0 0.0478205 -p -0.274914 0 0.0480469 -p -0.288614 0 0.0480469 -p -0.293555 0 0.0480469 -p -0.293555 0 0.0510741 -p -0.293555 0 0.125268 -p -0.293493 0 0.202405 -p -0.293493 0 0.398616 -p -0.293555 0 0.428465 -p -0.293555 0 0.429492 -p -0.294535 0 0.429492 -p -0.328353 0 0.429492 -p -0.378561 0 0.429492 -p -0.405499 0 0.429492 -p -0.407227 0 0.429492 -p -0.407227 0 0.428253 -p -0.407227 0 0.405684 -p -0.407227 0 0.328387 -p -0.407227 0 -0.0915302 -p -0.407227 0 -0.429492 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 37 -k 38 -k 39 -k 40 -k 41 -k 42 -k 43 -k 43 -k 43 ;
		rename `listRelatives -c ($modRigName + "R1_OuterCurve")` ($modRigName + "R1_OuterCurveShape");
		curve -n ($modRigName + "R1_InnerCurve") -p -0.293555 0 -0.33457 -p -0.257406 0 -0.33457 -p -0.0889505 0 -0.333847 -p 0.0486942 0 -0.336975 -p 0.14017 0 -0.292901 -p 0.171323 0 -0.194613 -p 0.146198 0 -0.11598 -p 0.0827139 0 -0.0601229 -p -0.0184461 0 -0.0494054 -p -0.159798 0 -0.0503906 -p -0.290636 0 -0.0503906 -p -0.293555 0 -0.0503906 -p -0.293555 0 -0.0540591 -p -0.293555 0 -0.119074 -p -0.293555 0 -0.33457 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 12 -k 12 ;
		rename `listRelatives -c ($modRigName + "R1_InnerCurve")` ($modRigName + "R1_InnerCurveShape");
		curve -n ($modRigName + "M_Curve") -d 1 -p 0.454102 0 0.429492 -p 0.454102 0 -0.429492 -p 0.625195 0 -0.429492 -p 0.869531 0 0.305859 -p 1.120898 0 -0.429492 -p 1.273828 0 -0.429492 -p 1.273828 0 0.429492 -p 1.164258 0 0.429492 -p 1.164258 0 -0.289453 -p 0.914648 0 0.429492 -p 0.812109 0 0.429492 -p 0.563672 0 -0.301758 -p 0.563672 0 0.429492 -p 0.454102 0 0.429492 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 ;
		rename `listRelatives -c ($modRigName + "M_Curve")` ($modRigName + "M_CurveShape");
		duplicate -n ($modRigName + "R2_OuterCurve") ($modRigName + "R1_OuterCurve");
		duplicate -n ($modRigName + "R2_InnerCurve") ($modRigName + "R1_InnerCurve");
		move -r -os -wd -1.5 0 0 ($modRigName + "R2_InnerCurve") ($modRigName + "R2_OuterCurve");
		
		scale -r 1.75 1.75 1.75 ($modRigName + "R1_OuterCurve") ($modRigName + "R1_InnerCurve") ($modRigName + "R2_OuterCurve") ($modRigName + "R2_InnerCurve") ($modRigName + "M_Curve");
		move -r -ws 0 0 10.4 ($modRigName + "R1_OuterCurve") ($modRigName + "R1_InnerCurve") ($modRigName + "R2_OuterCurve") ($modRigName + "R2_InnerCurve") ($modRigName + "M_Curve");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modRigName + "R1_OuterCurve") ($modRigName + "R1_InnerCurve") ($modRigName + "R2_OuterCurve") ($modRigName + "R2_InnerCurve") ($modRigName + "M_Curve");

		select ($modRigName + "R1_OuterCurveShape") ($modRigName + "R1_InnerCurveShape") ($modRigName + "R2_OuterCurveShape") ($modRigName + "R2_InnerCurveShape") ($modRigName + "M_CurveShape");
		$RRM_Curves = `ls -sl -type "nurbsCurve"`;
		for ($each in $RRM_Curves)
		{
			parent -r -s $each ($modRigName + "MAIN_Ctrl");
			setAttr ($each + ".overrideEnabled") 1;
			setAttr ($each + ".overrideColor") 14;
		}
		delete ($modRigName + "R1_OuterCurve") ($modRigName + "R1_InnerCurve") ($modRigName + "R2_OuterCurve") ($modRigName + "R2_InnerCurve") ($modRigName + "M_Curve");
	}

	//CREATE INNER MAIN CTRL
	if ($ea == 1)
	{
		circle -nr 0 1 0 -n ($modRigName + "MAIN_Inner_Ctrl") -r 7.4 -sw 360 -ch 0;
		setAttr ($modRigName + "MAIN_Inner_CtrlShape.overrideEnabled") 1;
		setAttr ($modRigName + "MAIN_Inner_CtrlShape.overrideColor") 16;
	}
	else
	{
		circle -nr 0 1 0 -n ($modRigName + "MAIN_Inner_Ctrl") -r 7.4 -sw 320 -ch 0;
		rotate -r -os 0 -160 0 ($modRigName + "MAIN_Inner_Ctrl");
		makeIdentity -apply true ($modRigName + "MAIN_Inner_Ctrl");
		curve -n ($modRigName + "MAIN_Inner_Ctrl1") -d 1 -p -2.530949 0 6.953725 -p -1 0 6.953725 -p 0 0 7.497827 -p 1 0 6.953725 -p 2.530949 0 6.953725 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modRigName + "MAIN_Inner_Ctrl1")` ($modRigName + "MAIN_Inner_Ctrl1Shape");
		parent -r -s ($modRigName + "MAIN_Inner_Ctrl1Shape") ($modRigName + "MAIN_Inner_Ctrl");
		delete ($modRigName + "MAIN_Inner_Ctrl1");
	}
	
	//CREATE TRAJECTORY CTRL
	if ($ea == 1)
	{
		curve -n ($modRigName + "Trajectory_Ctrl") -d 1 -p -1.2 0 -1.2 -p 1.2 0 -1.2 -p 1.2 0 1.2 -p 0 0 2.3 -p -1.2 0 1.2 -p -1.2 0 -1.2 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 ;
		rename `listRelatives -c ($modRigName + "Trajectory_Ctrl")` ($modRigName + "Trajectory_CtrlShape");
		curve -n ($modRigName + "Trajectory_Ctrl1") -d 1 -p 0.7 0 0 -p -0.7 0 0 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "Trajectory_Ctrl1")` ($modRigName + "Trajectory_Ctrl1Shape");
		curve -n ($modRigName + "Trajectory_Ctrl2") -d 1 -p 0 0 0.7 -p 0 0 -0.7 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "Trajectory_Ctrl2")` ($modRigName + "Trajectory_Ctrl2Shape");
		parent -r -s ($modRigName + "Trajectory_Ctrl1Shape") ($modRigName + "Trajectory_Ctrl2Shape") ($modRigName + "Trajectory_Ctrl");
		//setAttr ($modRigName + "Trajectory_Ctrl1Shape.template") 1;
		//setAttr ($modRigName + "Trajectory_Ctrl2Shape.template") 1;
		delete ($modRigName + "Trajectory_Ctrl1") ($modRigName + "Trajectory_Ctrl2");
		group -n ($modRigName + "Trajectory_CtrlGrp") ($modRigName + "Trajectory_Ctrl"); xform -os -piv 0 0 0;
		
		addAttr -ln "followRootPos" -at double -min 0 -max 1 -dv 0 ($modRigName + "Trajectory_Ctrl");
		setAttr -e -k 1 ($modRigName + "Trajectory_Ctrl.followRootPos");	
		addAttr -ln "followRootRot" -at double -min 0 -max 1 -dv 0 ($modRigName + "Trajectory_Ctrl");
		setAttr -e -k 1 ($modRigName + "Trajectory_Ctrl.followRootRot");
		parent ($modRigName + "Trajectory_CtrlGrp") ($modRigName + "MAIN_Inner_Ctrl");
	}


	//PARENT CONTROLS
	parent ($modRigName + "MAIN_Ctrl") ($modRigName + "MAIN_Offset_Ctrl");
	parent ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "MAIN_Ctrl");
	$mainScale = `getAttr RRM_MAIN.scale`;
	setAttr (($modRigName + "MAIN_Offset_Ctrl.scale"), $mainScale[0], $mainScale[1], $mainScale[2]);
	makeIdentity -apply true -s 1 ($modRigName + "MAIN_Offset_Ctrl");
	
	addAttr -ln "masterScale" -at double ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.masterScale");
	setAttr ($modRigName + "MAIN_Ctrl.masterScale") $mainScale[1];
	setAttr -l 1 -k 0 ($modRigName + "MAIN_Ctrl.masterScale");
	
	addAttr -ln "offset_Ctrl_visibility" -at bool ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.offset_Ctrl_visibility");

	addAttr -ln "COG_Ctrl_visibility" -at bool ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.COG_Ctrl_visibility");

	if ($ea == 1)
	{
		addAttr -ln "trajectory_visibility" -at bool ($modRigName + "MAIN_Ctrl");
		setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.trajectory_visibility");
		connectAttr -f ($modRigName + "MAIN_Ctrl.trajectory_visibility") ($modRigName + "Trajectory_Ctrl.v");
	}

	addAttr -ln "sh_joint_freeze" -at bool ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 0 -l 1 ($modRigName + "MAIN_Ctrl.sh_joint_freeze");
	
	//////////////////////////////////LOCK & HIDE//////////////////////////////////
	setAttr -l 1 -k 0 ($modRigName + "MAIN_Ctrl.v");
	connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modRigName + "MAIN_Ctrl.scaleX");
	connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modRigName + "MAIN_Ctrl.scaleZ"); 
	setAttr -l 1 -k 0 ($modRigName + "MAIN_Ctrl.scaleX");
	setAttr -l 1 -k 0 ($modRigName + "MAIN_Ctrl.scaleZ");
	
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Offset_Ctrl.sx");
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Offset_Ctrl.sy");
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Offset_Ctrl.sz");
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Offset_Ctrl.v");

	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Inner_Ctrl.sx");
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Inner_Ctrl.sy");
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Inner_Ctrl.sz");
	setAttr -l 1 -k 0 -channelBox false ($modRigName + "MAIN_Inner_Ctrl.v");

	if ($ea == 1)
	{
		setAttr -l 1 -k 0 -channelBox false ($modRigName + "Trajectory_Ctrl.sx");
		setAttr -l 1 -k 0 -channelBox false ($modRigName + "Trajectory_Ctrl.sy");
		setAttr -l 1 -k 0 -channelBox false ($modRigName + "Trajectory_Ctrl.sz");
		setAttr -l 1 -k 0 -channelBox false ($modRigName + "Trajectory_Ctrl.v");
	}

	//GET ROOT POSITION
	$rootPos = `xform -q -ws -rp RRM_ROOT`;
	select -cl;
	joint -n ($modRigName + "ROOTJnt");
	move -a $rootPos[0] $rootPos[1] $rootPos[2] ($modRigName + "ROOTJnt");

	//PARENT CONTROL
	if ($twistAxis == 1)
	{
		circle -n ($modRigName + "ROOTParent_Ctrl") -nr 0 1 0 -sw 315 -r 1.2 -ch 0;
		rotate -r 0 -157.5 0 ($modRigName + "ROOTParent_Ctrl");
		makeIdentity -apply true -r 1 ($modRigName + "ROOTParent_Ctrl");
		curve -n ($modRigName + "ROOTParent_Ctrl1") -d 1 -p 0.459248 0 1.108679 -p 0.459248 0 1.232295 -p 0 0 1.454964 -p -0.459248 0 1.232295 -p -0.459248 0 1.108679 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modRigName + "ROOTParent_Ctrl1")` ($modRigName + "ROOTParent_Ctrl1Shape");	
		parent -r -s ($modRigName + "ROOTParent_Ctrl1Shape") ($modRigName + "ROOTParent_Ctrl1Shape") ($modRigName + "ROOTParent_Ctrl");
		delete ($modRigName + "ROOTParent_Ctrl1");
		scale -r 1.25 1.25 1.25 ($modRigName + "ROOTParent_Ctrl");
		makeIdentity -apply true -s 1 ($modRigName + "ROOTParent_Ctrl");
	}
	else
	{
		circle -n ($modRigName + "ROOTParent_Ctrl") -nr 1 0 0 -sw 315 -r 6 -ch 0;
		rotate -r -157.5 0 0 ($modRigName + "ROOTParent_Ctrl");
		makeIdentity -apply true -r 1 ($modRigName + "ROOTParent_Ctrl");
		
		curve -n ($modRigName + "ROOTParent_Ctrl1") -d 1 -p 0 -5.543277 -2.296101 -p 0 -6.161475 -2.29624 -p 0 -7.27482 0 -p 0 -6.161475 2.29624 -p 0 -5.543277 2.296101 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modRigName + "ROOTParent_Ctrl1")` ($modRigName + "ROOTParent_Ctrl1Shape");	
		parent -r -s ($modRigName + "ROOTParent_Ctrl1Shape") ($modRigName + "ROOTParent_Ctrl1Shape") ($modRigName + "ROOTParent_Ctrl");
		delete ($modRigName + "ROOTParent_Ctrl1");
		makeIdentity -apply true -s 1 ($modRigName + "ROOTParent_Ctrl");
	}


	//CREATE COG_Ctrl//////////////////////////////////////////////////////
	if ($twistAxis == 1)
	{
		circle -n ($modRigName + "OuterCOG_Ctrl1") -r 12 -nr 0 1 0 -sw 18 -ch 0;
		circle -n ($modRigName + "InnerCOG_Ctrl1") -r 11 -nr 0 1 0 -sw 18 -ch 0;
		rotate -r -os 0 -18 0 ($modRigName + "InnerCOG_Ctrl1");
		curve -n ($modRigName + "LeftConnectorCOG_Ctrl1") -d 1 -p 0 0 -12 -p 0 0 -11 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "LeftConnectorCOG_Ctrl1")` ($modRigName + "LeftConnectorCOG_Ctrl1Shape");
		duplicate -n ($modRigName + "RightConnectorCOG_Ctrl1") ($modRigName + "LeftConnectorCOG_Ctrl1");
		rotate -r -os 0 -18 0 ($modRigName + "LeftConnectorCOG_Ctrl1");
		
		select ($modRigName + "OuterCOG_Ctrl1") ($modRigName + "InnerCOG_Ctrl1") ($modRigName + "LeftConnectorCOG_Ctrl1") ($modRigName + "RightConnectorCOG_Ctrl1");
		
		duplicate -rr; rotate -r 0 36 0; for ($i=1; $i<9; ++$i) duplicate -rr -st;
		select ($modRigName + "*COG_Ctrl?") ($modRigName + "*COG_Ctrl??");
		makeIdentity -apply true -t 1 -r 1 -s 1;
		select -d ($modRigName + "OuterCOG_Ctrl1");
		$transforms = `ls -sl`;
		pickWalk -d down;
		$shapes = `ls -sl`;
		parent -r -s $shapes ($modRigName + "OuterCOG_Ctrl1");
		delete $transforms;
		rename ($modRigName + "OuterCOG_Ctrl1") ($modRigName + "COG_Ctrl");
		
		scale -r .7 .7 .7 ($modRigName + "COG_Ctrl");
		rotate -r 0 -9 0 ($modRigName + "COG_Ctrl");
		makeIdentity -apply true -r 1 -s 1 ($modRigName + "COG_Ctrl");
		delete `scaleConstraint RRM_COG ($modRigName + "COG_Ctrl")`;
		makeIdentity -apply true -s 1 ($modRigName + "COG_Ctrl");
	
		group -n ($modRigName + "COG_CtrlGrp") ($modRigName + "COG_Ctrl");
		delete `parentConstraint RRM_COG ($modRigName + "COG_CtrlGrp")`;		
	}
	else
	{
		circle -n ($modRigName + "OuterCOG_Ctrl1") -r 12 -nr 1 0 0 -sw 18 -ch 0;
		circle -n ($modRigName + "InnerCOG_Ctrl1") -r 11 -nr 1 0 0 -sw 18 -ch 0;
		rotate -r -os -18 0 0 ($modRigName + "InnerCOG_Ctrl1");
		curve -n ($modRigName + "LeftConnectorCOG_Ctrl1") -d 1 -p 0 12 0 -p 0 11 0 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "LeftConnectorCOG_Ctrl1")` ($modRigName + "LeftConnectorCOG_Ctrl1Shape");
		duplicate -n ($modRigName + "RightConnectorCOG_Ctrl1") ($modRigName + "LeftConnectorCOG_Ctrl1");
		rotate -r -os -18 0 0 ($modRigName + "LeftConnectorCOG_Ctrl1");
		
		select ($modRigName + "OuterCOG_Ctrl1") ($modRigName + "InnerCOG_Ctrl1") ($modRigName + "LeftConnectorCOG_Ctrl1") ($modRigName + "RightConnectorCOG_Ctrl1");
		
		duplicate -rr; rotate -r 36 0 0; for ($i=1; $i<9; ++$i) duplicate -rr -st;
		select ($modRigName + "*COG_Ctrl?") ($modRigName + "*COG_Ctrl??");
		makeIdentity -apply true -t 1 -r 1 -s 1;
		select -d ($modRigName + "OuterCOG_Ctrl1");
		$transforms = `ls -sl`;
		$shapes = `listRelatives -c $transforms`;
		parent -r -s $shapes ($modRigName + "OuterCOG_Ctrl1");
		delete $transforms;
		rename ($modRigName + "OuterCOG_Ctrl1") ($modRigName + "COG_Ctrl");
		
		scale -r .7 .7 .7 ($modRigName + "COG_Ctrl");
		rotate -r -9 0 0 ($modRigName + "COG_Ctrl");
		makeIdentity -apply true -r 1 -s 1 ($modRigName + "COG_Ctrl");
		delete `scaleConstraint RRM_COG ($modRigName + "COG_Ctrl")`;
		makeIdentity -apply true -s 1 ($modRigName + "COG_Ctrl");
	
		group -n ($modRigName + "COG_CtrlGrp") ($modRigName + "COG_Ctrl");
		delete `parentConstraint RRM_COG ($modRigName + "COG_CtrlGrp")`;
		rotate -r -os -90 0 90 ($modRigName + "COG_CtrlGrp");
	}

	parent ($modRigName + "COG_CtrlGrp") ($modRigName + "MAIN_Inner_Ctrl");
	
	connectAttr -f ($modRigName + "MAIN_Ctrl.COG_Ctrl_visibility") ($modRigName + "COG_CtrlGrp.v");
	connectAttr -f ($modRigName + "MAIN_Ctrl.offset_Ctrl_visibility") ($modRigName + "MAIN_Offset_CtrlShape.visibility");

	
	//ADD CORE NAME
	addAttr -ln "isCOG_Ctrl" -dt "string" ($modRigName + "COG_Ctrl");
	setAttr -e -k 1 ($modRigName + "COG_Ctrl.isCOG_Ctrl");
	setAttr -e-l 1 ($modRigName + "COG_Ctrl.isCOG_Ctrl");
	
	setAttr ($modRigName + "COG_Ctrl.overrideEnabled") 1;
	setAttr ($modRigName + "COG_Ctrl.overrideColor") 19;
	


	setAttr -l 1 -k 0 ($modRigName + "COG_Ctrl.sx");
	setAttr -l 1 -k 0 ($modRigName + "COG_Ctrl.sy");
	setAttr -l 1 -k 0 ($modRigName + "COG_Ctrl.sz");
	setAttr -l 1 -k 0 ($modRigName + "COG_Ctrl.v");
	
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.tx");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.ty");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.tz");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.rx");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.ry");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.rz");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.sx");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.sy");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.sz");
	setAttr -l 1 -k 0 ($modRigName + "COG_CtrlGrp.v");
	
	////CREATE MOVEABLE PIVOT CONTROL
	RRM_MoveablePivot_Ctrl(($modRigName + "Pivot_Ctrl"), 1);
	
	delete `parentConstraint RRM_ROOT ($modRigName + "Pivot_CtrlGrp")`;
	if ($twistAxis != 1)
	{
		rotate -r -os -90 0 90 ($modRigName + "Pivot_CtrlGrp");
	}
	
	setAttr (($modRigName + "Pivot_Ctrl.scale"), $mainScale[0], $mainScale[1], $mainScale[2]);
	makeIdentity -apply true -s 1 ($modRigName + "Pivot_Ctrl");
	
	parentConstraint -mo ($modRigName + "COG_Ctrl") ($modRigName + "Pivot_CtrlGrp");
	parent ($modRigName + "Pivot_CtrlGrp") ($modRigName + "MAIN_Inner_Ctrl");
	
	//CREATE ROOT CONTROL//////////////////////////////////////////////////////
	if ($ea == 0)
	{
		if ($twistAxis == 1)
		{
			circle -n ($modRigName + "ROOT_Ctrl") -nr 0 1 0 -r 1.15 -ch 0;
			circle -n ($modRigName + "ROOT_Ctrl2") -nr 0 1 0 -sw 315 -r 1.2 -ch 0;
			rotate -r 0 -157.5 0 ($modRigName + "ROOT_Ctrl2");
			makeIdentity -apply true -r 1 ($modRigName + "ROOT_Ctrl2");
			curve -n ($modRigName + "ROOT_Ctrl3") -d 1 -p 0.459248 0 1.108679 -p 0.459248 0 1.232295 -p 0 0 1.454964 -p -0.459248 0 1.232295 -p -0.459248 0 1.108679 -k 0 -k 1 -k 2 -k 3 -k 4 ;
			rename `listRelatives -c ($modRigName + "ROOT_Ctrl3")` ($modRigName + "ROOT_Ctrl3Shape");
		}
		else
		{
			circle -n ($modRigName + "ROOT_Ctrl") -nr 1 0 0 -r 4.6 -ch 0;
			circle -n ($modRigName + "ROOT_Ctrl2") -nr 1 0 0 -sw 315 -r 4.8 -ch 0;
			rotate -r -157.5 0 0 ($modRigName + "ROOT_Ctrl");
			makeIdentity -apply true -r 1 ($modRigName + "ROOT_Ctrl2");
			curve -n ($modRigName + "ROOT_Ctrl3") -d 1 -p 0 -4.434622 -1.83688 -p 0 -4.92918 -1.836992 -p 0 -5.819856 0 -p 0 -4.92918 1.836992 -p 0 -4.434622 1.83688 -k 0 -k 1 -k 2 -k 3 -k 4 ;
			rename `listRelatives -c ($modRigName + "ROOT_Ctrl3")` ($modRigName + "ROOT_Ctrl3Shape");
		}
		parent -r -s ($modRigName + "ROOT_Ctrl2Shape") ($modRigName + "ROOT_Ctrl3Shape") ($modRigName + "ROOT_Ctrl");
		delete ($modRigName + "ROOT_Ctrl2") ($modRigName + "ROOT_Ctrl3");
	}
	else
	{
		curve -n ($modRigName + "ROOT_Ctrl") -d 1 -p 0.898076 0.216707 0.898076 -p 0.898076 0.216707 -0.898076 -p -0.898076 0.216707 -0.898076 -p -0.898076 0.216707 0.898076 -p 0.898076 0.216707 0.898076 -p 1.029148 -0.248335 1.029148 -p 1.029148 -0.248335 -1.029148 -p -1.029148 -0.248335 -1.029148 -p -1.029148 -0.248335 1.029148 -p 1.029148 -0.248335 1.029148 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 ;
		rename `listRelatives -c ($modRigName + "ROOT_Ctrl")` ($modRigName + "ROOT_CtrlShape");
		curve -n ($modRigName + "ROOT_Ctrl2") -d 1 -p 0.898076 0.216707 -0.898076 -p 1.029148 -0.248335 -1.029148 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "ROOT_Ctrl2")` ($modRigName + "ROOT_Ctrl2Shape");
		curve -n ($modRigName + "ROOT_Ctrl3") -d 1 -p -0.898076 0.216707 -0.898076 -p -1.029148 -0.248335 -1.029148 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "ROOT_Ctrl3")` ($modRigName + "ROOT_Ctrl3Shape");
		curve -n ($modRigName + "ROOT_Ctrl4") -d 1 -p -0.898076 0.216707 0.898076 -p -1.029148 -0.248335 1.029148 -k 0 -k 1 ;
		rename `listRelatives -c ($modRigName + "ROOT_Ctrl4")` ($modRigName + "ROOT_Ctrl4Shape");
		parent -r -s ($modRigName + "ROOT_Ctrl2Shape") ($modRigName + "ROOT_Ctrl3Shape") ($modRigName + "ROOT_Ctrl4Shape") ($modRigName + "ROOT_Ctrl");
		delete ($modRigName + "ROOT_Ctrl2") ($modRigName + "ROOT_Ctrl3") ($modRigName + "ROOT_Ctrl4");
	}
	
	
	//SECONDARY CONTROL
	if ($ea == 0)
	{
		if ($twistAxis == 1)
		{
			circle -n ($modRigName + "ROOTSecondary_Ctrl") -nr 0 1 0 -r 0.8 -ch 0;
			curve -n ($modRigName + "ROOTSecondary_Ctrl2") -d 1 -p 0.448913 0 0.659205 -p 0.457839 0 0.707653 -p 0.43562 0 0.726309 -p 0.389727 0 0.761461 -p 0.317127 0 0.807243 -p 0.242199 0 0.852344 -p 0.165051 0 0.890957 -p 0.0916126 0 0.922558 -p 0.0354615 0 0.944185 -p 0 0 0.956437 -p 0 0 0.800148 -p 0 0 0.956437 -p -0.0354615 0 0.944185 -p -0.0916126 0 0.922558 -p -0.165051 0 0.890957 -p -0.242199 0 0.852344 -p -0.317127 0 0.807243 -p -0.389727 0 0.761461 -p -0.43562 0 0.726309 -p -0.457839 0 0.707653 -p -0.448913 0 0.659205 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 ;
			rename `listRelatives -c ($modRigName + "ROOTSecondary_Ctrl2")` ($modRigName + "ROOTSecondary_Ctrl2Shape");
			curve -n ($modRigName + "ROOTSecondary_Ctrl3") -d 1 -p 0.793238 0 -0.0839132 -p 0.715647 0 0 -p 0.793238 0 0.0839132 -k 0 -k 1 -k 2 ;
			rename `listRelatives -c ($modRigName + "ROOTSecondary_Ctrl3")` ($modRigName + "ROOTSecondary_Ctrl3Shape");
			duplicate -rr; rotate -r 0 90 0; for ($i=1; $i<2; ++$i) duplicate -rr -st;
			makeIdentity -apply true -r 1 ($modRigName + "ROOTSecondary_Ctrl4") ($modRigName + "ROOTSecondary_Ctrl5");
			parent -r -s ($modRigName + "ROOTSecondary_Ctrl2Shape") ($modRigName + "ROOTSecondary_Ctrl3Shape") ($modRigName + "ROOTSecondary_Ctrl4Shape") ($modRigName + "ROOTSecondary_Ctrl5Shape") ($modRigName + "ROOTSecondary_Ctrl");
			delete ($modRigName + "ROOTSecondary_Ctrl2") ($modRigName + "ROOTSecondary_Ctrl3") ($modRigName + "ROOTSecondary_Ctrl4") ($modRigName + "ROOTSecondary_Ctrl5");	
			
			move -r 0 0.03 0 ($modRigName + "ROOTSecondary_Ctrl.scalePivot") ($modRigName + "ROOTSecondary_Ctrl.rotatePivot");
			parent ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "ROOT_Ctrl");
			delete `pointConstraint ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl")`;
			makeIdentity -apply true ($modRigName + "ROOTSecondary_Ctrl");
			
			group -n ($modRigName + "ROOT_CtrlGrp") ($modRigName + "ROOT_Ctrl"); xform -os -piv 0 0 0;
			parentConstraint ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
			parent ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp") RRM_ROOT;
			setAttr (($modRigName + "ROOTParent_Ctrl.scale"), 4, 4, 4);
			setAttr (($modRigName + "ROOT_CtrlGrp.scale"), 4, 4, 4);
			parent -w ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
			makeIdentity -apply true -s 1 ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
			scaleConstraint ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
		
			group -n ($modRigName + "ROOTParent_CtrlGrp") ($modRigName + "ROOTParent_Ctrl"); xform -os -piv 0 0 0;
			group -n ($modRigName + "ROOTParent_CtrlGrp2") ($modRigName + "ROOTParent_CtrlGrp"); xform -os -piv 0 0 0;
			delete `parentConstraint RRM_ROOT ($modRigName + "ROOTParent_CtrlGrp2")`;
			makeIdentity -apply true -t 1 ($modRigName + "ROOTParent_CtrlGrp2");
		}
		else
		{
			circle -n ($modRigName + "ROOTSecondary_Ctrl") -nr 1 0 0 -r 3.2 -ch 0;
			curve -n ($modRigName + "ROOTSecondary_Ctrl2") -d 1 -p 0 -2.63682 -1.795652 -p 0 -2.830612 -1.831356 -p 0 -2.905236 -1.74248 -p 0 -3.045844 -1.558908 -p 0 -3.228972 -1.268508 -p 0 -3.409376 -0.968796 -p 0 -3.563828 -0.660204 -p 0 -3.690232 -0.36645 -p 0 -3.77674 -0.141846 -p 0 -3.825748 0 -p 0 -3.200592 0 -p 0 -3.825748 0 -p 0 -3.77674 0.141846 -p 0 -3.690232 0.36645 -p 0 -3.563828 0.660204 -p 0 -3.409376 0.968796 -p 0 -3.228972 1.268508 -p 0 -3.045844 1.558908 -p 0 -2.905236 1.74248 -p 0 -2.830612 1.831356 -p 0 -2.63682 1.795652 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 ;
			rename `listRelatives -c ($modRigName + "ROOTSecondary_Ctrl2")` ($modRigName + "ROOTSecondary_Ctrl2Shape");
			curve -n ($modRigName + "ROOTSecondary_Ctrl3") -d 1 -p 0 0.335653 -3.172952 -p 0 0 -2.862588 -p 0 -0.335653 -3.172952 -k 0 -k 1 -k 2 ;
			rename `listRelatives -c ($modRigName + "ROOTSecondary_Ctrl3")` ($modRigName + "ROOTSecondary_Ctrl3Shape");
			duplicate -rr; rotate -r 90 0 0; for ($i=1; $i<2; ++$i) duplicate -rr -st;
			makeIdentity -apply true -r 1 ($modRigName + "ROOTSecondary_Ctrl4") ($modRigName + "ROOTSecondary_Ctrl5");
			parent -r -s ($modRigName + "ROOTSecondary_Ctrl2Shape") ($modRigName + "ROOTSecondary_Ctrl3Shape") ($modRigName + "ROOTSecondary_Ctrl4Shape") ($modRigName + "ROOTSecondary_Ctrl5Shape") ($modRigName + "ROOTSecondary_Ctrl");
			delete ($modRigName + "ROOTSecondary_Ctrl2") ($modRigName + "ROOTSecondary_Ctrl3") ($modRigName + "ROOTSecondary_Ctrl4") ($modRigName + "ROOTSecondary_Ctrl5");	
			
			move -r 0 0.03 0 ($modRigName + "ROOTSecondary_Ctrl.scalePivot") ($modRigName + "ROOTSecondary_Ctrl.rotatePivot");
			parent ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "ROOT_Ctrl");
			delete `pointConstraint ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl")`;
			makeIdentity -apply true ($modRigName + "ROOTSecondary_Ctrl");
			
			group -n ($modRigName + "ROOT_CtrlGrp") ($modRigName + "ROOT_Ctrl"); xform -os -piv 0 0 0;
			parentConstraint ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
			parent ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp") RRM_ROOT;
			parent -w ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
			makeIdentity -apply true -s 1 ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
			scaleConstraint ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
		
			group -n ($modRigName + "ROOTParent_CtrlGrp") ($modRigName + "ROOTParent_Ctrl"); xform -os -piv 0 0 0;
			group -n ($modRigName + "ROOTParent_CtrlGrp2") ($modRigName + "ROOTParent_CtrlGrp"); xform -os -piv 0 0 0;
			delete `parentConstraint RRM_ROOT ($modRigName + "ROOTParent_CtrlGrp2")`;
			rotate -r -90 0 90;
			makeIdentity -apply true -t 1 ($modRigName + "ROOTParent_CtrlGrp2");
		}
	}
	else
	{
		RRM_BasicControl(($modRigName + "ROOTSecondary_Ctrl"), "y", 1, 0, 1);
		parent ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "ROOT_Ctrl");
		delete `pointConstraint ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl")`;
		makeIdentity -apply true ($modRigName + "ROOTSecondary_Ctrl");

		group -n ($modRigName + "ROOT_CtrlGrp") ($modRigName + "ROOT_Ctrl"); xform -os -piv 0 0 0;
		parentConstraint ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
		parent ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp") RRM_ROOT;
		setAttr (($modRigName + "ROOTParent_Ctrl.scale"), 4, 4, 4);
		setAttr (($modRigName + "ROOT_CtrlGrp.scale"), 4, 4, 4);
		parent -w ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
		makeIdentity -apply true -s 1 ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
		scaleConstraint ($modRigName + "ROOTParent_Ctrl") ($modRigName + "ROOT_CtrlGrp");
	
		group -n ($modRigName + "ROOTParent_CtrlGrp") ($modRigName + "ROOTParent_Ctrl"); xform -os -piv 0 0 0;
		group -n ($modRigName + "ROOTParent_CtrlGrp2") ($modRigName + "ROOTParent_CtrlGrp"); xform -os -piv 0 0 0;
		delete `parentConstraint RRM_ROOT ($modRigName + "ROOTParent_CtrlGrp2")`;
		makeIdentity -apply true -t 1 ($modRigName + "ROOTParent_CtrlGrp2");
	}
	parentConstraint -mo ($modRigName + "Pivot_Ctrl") ($modRigName + "ROOTParent_CtrlGrp2");
	
	//CREATE OFFSETTING VALUES ON PARENT CTRL GRP
	shadingNode -asUtility multiplyDivide -n ($modRigName + "ROOTParent_CtrlGrp_MD");
	connectAttr -f ($modRigName + "Pivot_Ctrl.translate") ($modRigName + "ROOTParent_CtrlGrp_MD.input1");
	setAttr (($modRigName + "ROOTParent_CtrlGrp_MD.input2"), -1, -1, -1);
	connectAttr -f ($modRigName + "ROOTParent_CtrlGrp_MD.output") ($modRigName + "ROOTParent_CtrlGrp.translate");
	
	delete `parentConstraint "RRM_ROOT" ($modRigName + "ROOTJnt")`;
	rotate -r -os -90 0 90 ($modRigName + "ROOTJnt");
	parentConstraint -mo ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "ROOTJnt");
	connectAttr -f ($modRigName + "ROOTSecondary_Ctrl.scale") ($modRigName + "ROOTJnt.scale");
	
		
	//HAVE TRAJECTORY FOLLOW ROOT
	if ($ea == 1)
	{
		pointConstraint -mo -skip y ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "Trajectory_CtrlGrp");
		orientConstraint -mo -skip x -skip z ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "Trajectory_CtrlGrp");
		connectAttr -f ($modRigName + "Trajectory_Ctrl.followRootPos") ($modRigName + "Trajectory_CtrlGrp_pointConstraint1." + $modRigName + "ROOTSecondary_CtrlW1");
		connectAttr -f ($modRigName + "Trajectory_Ctrl.followRootRot") ($modRigName + "Trajectory_CtrlGrp_orientConstraint1." + $modRigName + "ROOTSecondary_CtrlW1");
		//REVERSE
		shadingNode -asUtility reverse -n ($modRigName + "Trajectory_Rev");
		connectAttr -f ($modRigName + "Trajectory_Ctrl.followRootPos") ($modRigName + "Trajectory_Rev.inputX");
		connectAttr -f ($modRigName + "Trajectory_Ctrl.followRootRot") ($modRigName + "Trajectory_Rev.inputY");
		connectAttr -f ($modRigName + "Trajectory_Rev.outputX") ($modRigName + "Trajectory_CtrlGrp_pointConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
		connectAttr -f ($modRigName + "Trajectory_Rev.outputY") ($modRigName + "Trajectory_CtrlGrp_orientConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
	}
	
	//ADD VISIBILITY CONTROL FOR PARENT CONTROL
	addAttr -ln "parentControl" -at bool ($modRigName + "ROOT_Ctrl");
	setAttr -e -k 1 ($modRigName + "ROOT_Ctrl.parentControl");
	connectAttr -f ($modRigName + "ROOT_Ctrl.parentControl") ($modRigName + "ROOTParent_Ctrl.v");
	setAttr -l 1 -k 0 ($modRigName + "ROOTParent_Ctrl.v");
	setAttr ($modRigName + "ROOT_Ctrl.parentControl") 0;
	
	//ADD VISIBILITY CONTROL FOR PIVOT CONTROL
	addAttr -ln "pivot_CtrlVis" -at bool ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.pivot_CtrlVis");
	connectAttr -f ($modRigName + "MAIN_Ctrl.pivot_CtrlVis") ($modRigName + "Pivot_Ctrl.v");
	setAttr -l 1 -k 0 ($modRigName + "Pivot_Ctrl.v");
	setAttr ($modRigName + "MAIN_Ctrl.pivot_CtrlVis") 0;
	
	setAttr -l 1 -k 0 ($modRigName + "Pivot_Ctrl.sx");
	setAttr -l 1 -k 0 ($modRigName + "Pivot_Ctrl.sy");
	setAttr -l 1 -k 0 ($modRigName + "Pivot_Ctrl.sz");


	group -n ($modRigName + "ROOTGrp") ($modRigName + "ROOTParent_CtrlGrp2");
	parent ($modRigName + "ROOT_CtrlGrp") ($modRigName + "ROOTParent_CtrlGrp2");
	parent ($modRigName + "ROOTGrp") ($modRigName + "MAIN_Inner_Ctrl");
	parent ($modRigName + "ROOTJnt") ($modRigName + "ROOT_CtrlGrp");

	parent ($modRigName + "MAIN_Offset_Ctrl") $rigGrp;

	//ADD CORE NAME
	$modControls = `ls ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTParent_Ctrl")`;
	RRM_CoreName($modControls);
	for ($crntModControl in $modControls)
	{
		addAttr -ln "isROOT" -dt "string" $crntModControl;
		setAttr -e -k 1 ($crntModControl + ".isROOT");
		setAttr -type "string" ($crntModControl + ".isROOT") $crntModControl;
		setAttr -e-l 1 ($crntModControl + ".isROOT");
		
		setAttr -type "string" ($crntModControl + ".modCoreName") ("ROOT_Ctrl");
		setAttr -e-l 1 ($crntModControl + ".modCoreName");
		
		setAttr -l 1 -k 0 ($crntModControl + ".v");
	}

	addAttr -ln "isMain" -dt "string" ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.isMain");
	setAttr -type "string" ($modRigName + "MAIN_Ctrl.isMain") "isMain";
	setAttr -e-l 1 ($modRigName + "MAIN_Ctrl.isMain");

	//ADD VERSION NUMBER
	addAttr -ln "versionNumber" -dt "string" ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.versionNumber");
	setAttr -type "string" ($modRigName + "MAIN_Ctrl.versionNumber") "2.0.1";
	setAttr -e-l 1 ($modRigName + "MAIN_Ctrl.versionNumber");

	addAttr -ln "leftPrefix" -dt "string" ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.leftPrefix");
	setAttr -type "string" ($modRigName + "MAIN_Ctrl.leftPrefix") $lPrfx;
	setAttr -e-l 1 ($modRigName + "MAIN_Ctrl.leftPrefix");

	addAttr -ln "rightPrefix" -dt "string" ($modRigName + "MAIN_Ctrl");
	setAttr -e -k 1 ($modRigName + "MAIN_Ctrl.rightPrefix");
	setAttr -type "string" ($modRigName + "MAIN_Ctrl.rightPrefix") $rPrfx;
	setAttr -e-l 1 ($modRigName + "MAIN_Ctrl.rightPrefix");


	addAttr -ln "isROOT_Ctrl" -dt "string" ($modRigName + "ROOT_Ctrl");
	setAttr -e -k 1 ($modRigName + "ROOT_Ctrl.isROOT_Ctrl");
	setAttr -e-l 1 ($modRigName + "ROOT_Ctrl.isROOT_Ctrl");

	addAttr -ln "isROOTGrp" -dt "string" ($modRigName + "ROOTGrp");
	setAttr -e -k 1 ($modRigName + "ROOTGrp.isROOTGrp");
	setAttr -e-l 1 ($modRigName + "ROOTGrp.isROOTGrp");
	
	//CREATE LOCATOR FOR TURNING OFF CONSTRAINTS
	spaceLocator -n ($modRigName + "ROOTLocLctr");
	delete `pointConstraint ($modRigName + "ROOTJnt") ($modRigName + "ROOTLocLctr")`;
	parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOTLocLctr");
	parent ($modRigName + "ROOTLocLctr") ($modRigName + "ROOTGrp");
	setAttr ($modRigName + "ROOTLocLctr.v") 0;
	
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////GENERATE SPLINE MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_SplineFkControl(int $twistAxis, string $crntSide, float $behavior, string $name, int $ea)
{
	if ($ea == 0)
	{
		if ($twistAxis == 1)
		{
			circle -n $name -nr 0 1 0 -r 1 -ch 0;	
			scale -r -0.333 1 1 ($name + ".cv[3]") ($name + ".cv[7]");
			move -r 0 0 -0.35 ($name + ".cv[0]") ($name + ".cv[2]");

			if ($crntSide == "right" && $behavior == 0)
			{
				rotate -r -os 0 180 0 $name;
				makeIdentity -apply true -r 1 $name;
			}
		}
		else
		{
			circle -n $name-nr 1 0 0 -r 1 -ch 0;	
			scale -r 1 1 -0.3 ($name + ".cv[3]") ($name + ".cv[7]");
			move -r 0 0.35 0 ($name + ".cv[0]") ($name + ".cv[2]");

			if ($crntSide == "right" && $behavior == 0)
			{
				rotate -r -os 180 0 0 $name ;
				makeIdentity -apply true -r 1 $name;
			}
		}
	}
	else
	{
			curve -n ($name) -d 1 -p 0 0 0.925 -p 0 0 0 -k 0 -k 1;
			rename `listRelatives $name` ($name + "Shape");

			circle -n ($name + "2") -c 0 0 1 -nr 1 0 0 -r 0.075 -ch 0;
			circle -n ($name + "3") -c 0 0 1 -nr 0 1 0 -r 0.075 -ch 0;
			circle -n ($name + "4") -c 0 0 1 -nr 0 0 1 -r 0.075 -ch 0;
		

			parent -r -s ($name + "2Shape") ($name + "3Shape") ($name + "4Shape") ($name);
			delete ($name + "2") ($name + "3") ($name + "4");
	}
}

global proc RRM_GenerateRigSpline(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`; 

	//INTEGER FOR LOOP
	$mirrorInt = 2;
	$multiplier = 1;
		
	$core = `getAttr ($topNode + ".core")`;
	$twistAxis = 1;
	if (`objExists ($topNode + ".twistAxis")`)
	{
		$twistAxis = `getAttr ($topNode + ".twistAxis")`;
	}

	string $prfx = "";
	string $oppPrfx = "";
	float $behavior = 1;
	float $behaviorMultiplier = 1;

	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = $lPrfx;
		$oppPrfx = $rPrfx;
		$mirrorInt = 1;
		
		if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behavior = 0;
			}
		}
	}
	
	
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 2)
	{
		if ($crntSide == "right" && $behavior == 0)
		{
			$behaviorMultiplier = -1;
		}
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$modOppCore = ($modRigName + "" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		//rotate -r -os -90 0 90 ($modCore + "_OffsetLctr");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "spline";
		setAttr -l true ($modCore + "Grp.topNode");		
		
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");

			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = (`size $splineProxies` + 1);
		
		addAttr -ln "splineJoints" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.splineJoints") ;
		setAttr -type "string" ($modCore + "Grp.splineJoints") $splineSize;
		setAttr -l true ($modCore + "Grp.splineJoints");
		
		addAttr -ln "twistAxis" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.twistAxis") ;
		if ($twistAxis == 0)
		{
			setAttr -type "string" ($modCore + "Grp.twistAxis") "x";
		}
		else if ($twistAxis == 1)
		{
			setAttr -type "string" ($modCore + "Grp.twistAxis") "y";		
		}
		setAttr -l true ($modCore + "Grp.twistAxis");
		
		
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_ScaleGrp")`;
			//rotate -r -90 0 90 ($modCore + "_ScaleGrp");
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_ScaleGrp");
			
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint -mo ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp")`;
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_ScaleGrp")`;
			//rotate -r -90 0 90 ($modCore + "_ScaleGrp");
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_ScaleGrp");
			
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");
		
		//ORIENTATION AND LENGTH LOCATORS
		spaceLocator -n ($modCore + "_OrientLctr");
		parent ($modCore + "_OrientLctr") ($modCore + "Grp");	
		spaceLocator -n ($modCore + "_OrientLengthLctr");
		parent ($modCore + "_OrientLengthLctr") ($modCore + "_OrientLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_OrientLctr");
		if ($twistAxis == 1)
		{
			aimConstraint -aimVector 0 1 0 -upVector 0 0 1
			-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
			("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLctr");			
		}
		else
		{
			aimConstraint -aimVector 1 0 0 -upVector 0 0 1
			-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
			("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLctr");
		}
		pointConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLengthLctr");
		$getSplineLength = `getAttr ($modCore + "_OrientLengthLctr.ty")`;
		if ($twistAxis == 0)
		{
			$getSplineLength = `getAttr ($modCore + "_OrientLengthLctr.tx")`;
		}
	
		//FK CONTROLS
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = `size $splineProxies`;
		int $crntNum = 1;
		while ($crntNum <= $splineSize)
		{
			$nPd = "_0";
			if ($crntNum >= 10)
			{$nPd = "_";}
			$prvNPad = "_0";
			if ($crntNum > 10)
			{$prvNPad = "_";}		
			int $testNum = $crntNum;
		
			RRM_SplineFkControl($twistAxis, $crntSide, $behavior, ($modCore + $nPd + $crntNum + "Fk_Ctrl"), $ea);
			group -n ($modCore + $nPd + $crntNum + "Fk_CtrlGrp") ($modCore + $nPd + $crntNum + "Fk_Ctrl"); xform -os -piv 0 0 0;
			delete `parentConstraint ("RRM_" + $prfx + $core + $nPd + $crntNum) ($modCore + $nPd + $crntNum + "Fk_CtrlGrp")`;
			
			if ($twistAxis == 0)
			{
				rotate -r -os -90 0 90 ($modCore + $nPd + $crntNum + "Fk_CtrlGrp");
				if ($crntSide == "right" && $behavior == 0)
				{
					rotate -r -os 0 0 180 ($modCore + $nPd + $crntNum + "Fk_CtrlGrp");
				}
			}
			else if ($twistAxis == 1)
			{
				if ($crntSide == "right")
				{
					if ($behavior == 0)
					{
						rotate -r -os 180 0 0 ($modCore + $nPd + $crntNum + "Fk_CtrlGrp");
					}
				}
			}			
			$parentNodeLoc = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Parent")`;
			$topNodeLoc = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Top")`; 
			$scale = ((($getSplineLength + $getSplineLength / $splineSize))/3);
			scale -r $scale $scale $scale ($modCore + $nPd + $crntNum + "Fk_CtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + $nPd + $crntNum + "Fk_CtrlGrp");
			
			parent ($modCore + $nPd + $crntNum + "Fk_CtrlGrp") ($modCore + "_ScaleGrp");
			if ($crntNum == 1)
			{
				spaceLocator -n ($modCore + $nPd + $crntNum + "FkCFlipLctr");
				setAttr ($modCore + $nPd + $crntNum + "FkCFlipLctr.v") 0;
				parent ($modCore + $nPd + $crntNum + "FkCFlipLctr") ($modCore + "_ScaleGrp");
	
				delete `orientConstraint ($modCore + "_OffsetLctr") ($modCore + $nPd + $crntNum + "FkCFlipLctr")`;
				delete `pointConstraint ($modCore) ($modCore + $nPd + $crntNum + "FkCFlipLctr")`;
				parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore) ($modCore + $nPd + $testNum + "Fk_CtrlGrp");
				orientConstraint -mo ($modCore + $nPd + $crntNum + "FkCFlipLctr") ($modCore + "_OffsetLctr") ($modCore + $nPd + $testNum + "Fk_CtrlGrp");
				parentConstraint -mo ($modCore) ($modCore + $nPd + $crntNum + "FkCFlipLctr");
				
				//PARENT ORIENT
				addAttr -ln "orient" -at double -min 0 -max 1 -dv 1 ($modCore + $nPd + $testNum + "Fk_Ctrl");
				setAttr -e -k 1 ($modCore + $nPd + $testNum + "Fk_Ctrl.orient");
				connectAttr -force ($modCore + $nPd + $testNum + "Fk_Ctrl.orient") ($modCore + $nPd + $testNum + "Fk_CtrlGrp_orientConstraint1." + $modCore + $nPd + $crntNum + "FkCFlipLctrW0");
				
				shadingNode -asUtility reverse -n ($modCore + $nPd + $testNum + "FkParentOrientReverse");
				connectAttr -force ($modCore + $nPd + $testNum + "Fk_Ctrl.orient") ($modCore + $nPd + $testNum + "FkParentOrientReverse.inputX");
				connectAttr -force ($modCore + $nPd + $testNum + "FkParentOrientReverse.outputX") ($modCore + $nPd + $testNum + "Fk_CtrlGrp_orientConstraint1." + $modCore + "_OffsetLctrW1");
			}
			else
			{
				spaceLocator -n ($modCore + $nPd + $crntNum + "FkCFlipLctr");
				setAttr ($modCore + $nPd + $crntNum + "FkCFlipLctr.v") 0;
				parent ($modCore + $nPd + $crntNum + "FkCFlipLctr") ($modCore + "_ScaleGrp");
				
				delete `orientConstraint ($modCore + "_OffsetLctr") ($modCore + $nPd + $crntNum + "FkCFlipLctr")`;
				delete `pointConstraint ($modCore + $prvNPad + ($crntNum - 1) + "Fk_Ctrl") ($modCore + $nPd + $crntNum + "FkCFlipLctr")`;
				parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + $prvNPad + ($crntNum - 1) + "Fk_Ctrl") ($modCore + $nPd + $testNum + "Fk_CtrlGrp");
				orientConstraint -mo ($modCore + $nPd + $crntNum + "FkCFlipLctr") ($modCore + "_OffsetLctr") ($modCore + $nPd + $testNum + "Fk_CtrlGrp");
				parentConstraint -mo ($modCore + $prvNPad + ($crntNum - 1) + "Fk_Ctrl") ($modCore + $nPd + $crntNum + "FkCFlipLctr");
				
				//PARENT ORIENT
				addAttr -ln "orient" -at double -min 0 -max 1 -dv 1 ($modCore + $nPd + $testNum + "Fk_Ctrl");
				setAttr -e -k 1 ($modCore + $nPd + $testNum + "Fk_Ctrl.orient");
				connectAttr -force ($modCore + $nPd + $testNum + "Fk_Ctrl.orient") ($modCore + $nPd + $testNum + "Fk_CtrlGrp_orientConstraint1." + $modCore + $nPd + $crntNum + "FkCFlipLctrW0");
				
				shadingNode -asUtility reverse -n ($modCore + $nPd + $testNum + "FkParentOrientReverse");
				connectAttr -force ($modCore + $nPd + $testNum + "Fk_Ctrl.orient") ($modCore + $nPd + $testNum + "FkParentOrientReverse.inputX");
				connectAttr -force ($modCore + $nPd + $testNum + "FkParentOrientReverse.outputX") ($modCore + $nPd + $testNum + "Fk_CtrlGrp_orientConstraint1." + $modCore + "_OffsetLctrW1");	
			}
			$crntNum++;
		}
		//select "break";
		
		//Ik SPLINE CONTROLS
		if ($ea == 0)
		{
			if ($twistAxis == 1)
			{
				curve -n ($modCore + "_TopIk_Ctrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
				-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
				-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
				-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
				-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
				-k 23 -k 24 ;
				rotate 90 0 0 ($modCore + "_TopIk_Ctrl");			
			}
			else
			{
				curve -n ($modCore + "_TopIk_Ctrl") -d 1 -p 0 1 1 -p 0 3 1 -p 0 3 2-p 0 5 0
				-p 0 3 -2 -p 0 3 -1 -p 0 1 -1 -p 0 1 -3 -p 0 2 -3 -p 0 0 -5 -p 0 -2 -3
				-p 0 -1 -3 -p 0 -1 -1 -p 0 -3 -1 -p 0 -3 -2 -p 0 -5 0 -p 0 -3 2 -p 0 -3 1
				-p 0 -1 1 -p 0 -1 3 -p 0 -2 3 -p 0 0 5 -p 0 2 3 -p 0 1 3 -p 0 1 1 -k 0
				-k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13
				-k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 ;
			}
		}
		else
		{
			RRM_BasicControl(($modCore + "_TopIk_Ctrl"), "y", 4, 0, 1);
		}

		rename `listRelatives -c ($modCore + "_TopIk_Ctrl")` ($modCore + "_TopIk_CtrlShape");
		$splineScaleRatio = ($getSplineLength + $getSplineLength / $splineSize);
		setAttr (($modCore + "_TopIk_Ctrl.scale"), ($splineScaleRatio/14), ($splineScaleRatio/14), ($splineScaleRatio/14));
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_TopIk_Ctrl");
		group -n ($modCore + "_TopIk_CtrlGrp") ($modCore + "_TopIk_Ctrl"); xform -os -piv 0 0 0;
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_TopIk_CtrlGrp")`;
		if ($ea == 0)
		{
			if ($twistAxis == 1)
			{
				curve -n ($modCore + "_MidIk_Ctrl") -d 1 -p 0 0 2.5 -p -1.5 0 1 -p -3 0 1
				-p -3 0 -1 -p 3 0 -1 -p 3 0 1 -p 1.5 0 1 -p 0 0 2.5
				-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			}
			else
			{
				rotate -r -os -90 0 90 ($modCore + "_TopIk_CtrlGrp");
				curve -n ($modCore + "_MidIk_Ctrl") -d 1 -p 0 -2.5 0 -p 0 -1 1.5 -p 0 -1 3
				-p 0 1 3 -p 0 1 -3 -p 0 -1 -3 -p 0 -1 -1.5 -p 0 -2.5 0
				-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			}
		}
		else
		{
			RRM_BasicControl(($modCore + "_MidIk_Ctrl"), "y", 2, 0, 1);
		}
		
		if ($crntSide == "right" && $behavior == 0)
		{
			$rz = `getAttr ($modCore + "_TopIk_CtrlGrp.rz")`;
			if ($twistAxis == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_TopIk_CtrlGrp");
			}
			else
			{
				rotate -r -os 0 0 180 ($modCore + "_TopIk_CtrlGrp");				
			}
		}

		rename `listRelatives -c ($modCore + "_MidIk_Ctrl")` ($modCore + "_MidIk_CtrlShape");
		setAttr (($modCore + "_MidIk_Ctrl.scale"), ($splineScaleRatio/8), ($splineScaleRatio/8), ($splineScaleRatio/8));
		
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MidIk_Ctrl");
		group -n ($modCore + "_MidIk_CtrlGrp") ($modCore + "_MidIk_Ctrl"); xform -os -piv 0 0 0;
		spaceLocator -n ($modCore + "_MidIk_CtrlLctr");
		spaceLocator -n ($modCore + "_MidIk_CtrlWSLctr");
		group -n ($modCore + "_MidIk_CtrlLctrGrp") ($modCore + "_MidIk_CtrlLctr"); xform -os -piv 0 0 0;
		group -n ($modCore + "_MidIk_CtrlLctrGrp2") ($modCore + "_MidIk_CtrlLctrGrp");
		if ($twistAxis == 0)
		{
			rotate -r -90 0 90 ($modCore + "_MidIk_CtrlLctrGrp2");
		}
		if ($crntSide == "right" && $behavior == 0)
		{
			$rz = `getAttr ($modCore + "_MidIk_CtrlGrp.rz")`;
			if ($twistAxis == 1)
			{
				rotate -r -os 180 0 ($rz * -1) ($modCore + "_MidIk_CtrlGrp");
				rotate -r -os -180 0 ($rz * -1) ($modCore + "_MidIk_Ctrl");
			}
			else
			{
				rotate -r -os 90 0 (-90 + $rz * -1) ($modCore + "_MidIk_CtrlGrp");
				rotate -r -os 180 0 0 ($modCore + "_MidIk_Ctrl");
			}
			makeIdentity -apply true -r 1 ($modCore + "_MidIk_Ctrl");
		}
		
		parent ($modCore + "_TopIk_CtrlGrp") ($modCore + "_MidIk_CtrlGrp") ($modCore + "_MidIk_CtrlLctrGrp2") ($modCore + "_MidIk_CtrlWSLctr") ($modCore);
		
		//HIDE LOCATORS
		setAttr ($modCore + "_MidIk_CtrlLctr.v") 0;
		setAttr ($modCore + "_MidIk_CtrlWSLctr.v") 0;
		
		
		//LOCATOR TO PREVENT FLIPPING OF Ik CONTROL
		spaceLocator -n ($modCore + "_TopIk_Ctrl_FlipLctr1");
		delete `orientConstraint ($modCore + "_TopIk_Ctrl") ($modCore + "_TopIk_Ctrl_FlipLctr1")`;
		parentConstraint -mo ($modCore + "_OffsetLctr") ($modCore + "_TopIk_Ctrl_FlipLctr1");
		
		spaceLocator -n ($modCore + "_TopIk_Ctrl_FlipLctr2");
		delete `orientConstraint ($modCore + "_TopIk_Ctrl") ($modCore + "_TopIk_Ctrl_FlipLctr2")`;
		setAttr ($modCore + "_TopIk_Ctrl_FlipLctr1.v") 0;
		setAttr ($modCore + "_TopIk_Ctrl_FlipLctr2.v") 0;
		parent ($modCore + "_TopIk_Ctrl_FlipLctr1") ($modCore + "_TopIk_Ctrl_FlipLctr2") ($modCore + "_ScaleGrp");

		//CONSTRAIN TO FK CONTROLS
		//NUMBER OF SPLINE JOINTS
		$spineDums = `ls ("RRM" + "_" + $oppPrfx + $core + "_??") ("RRM" + "_" + $oppPrfx + $core + "_Top")`;
		$spineNum = `size $spineDums`;
		
		//GET SECOND FROM TOP
		int $splineNumTop = ($spineNum - 1);
		$nPd = "_0";
		if ($splineNumTop >=10)
			{$nPd = "_";}
			
		//GET HALF WAY POINT FOR MID Ik_CtrlGrp TO ATTACH TO. IF UNEVEN NUMBER, NEED TWO TARGETS
		int $midSpline = ($spineNum/2);
		int $midSpline2 = ($midSpline + 1);
		$nPdMid = "_0";
		$nPdMid2 = "_0";
		if ($midSpline >=10)
		{$nPdMid = "_";}
		if ($midSpline2 >=10)
		{$nPdMid2 = "_";}
		
		//CONSTRAIN MID IkC ASSETS TO THE CENTER
		if ($spineNum % 2 == 0)
		{
			parentConstraint ($modCore + $nPdMid + $midSpline + "Fk_Ctrl") ($modCore + "_MidIk_CtrlLctrGrp");
			delete `parentConstraint ($modCore + $nPdMid + $midSpline + "Fk_Ctrl") ($modCore + "_MidIk_CtrlWSLctr")`;
		}
		else
		{
			parentConstraint ($modCore + $nPdMid + $midSpline + "Fk_Ctrl") ($modCore + $nPdMid2 + $midSpline2 + "Fk_Ctrl") ($modCore + "_MidIk_CtrlLctrGrp");
			setAttr ($modCore + "_MidIk_CtrlLctrGrp_parentConstraint1.interpType") 2;
			delete `parentConstraint ($modCore + $nPdMid + $midSpline + "Fk_Ctrl") ($modCore + $nPdMid2 + $midSpline2 + "Fk_Ctrl") ($modCore + "_MidIk_CtrlWSLctr")`;
		}
		
		parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_MidIk_CtrlWSLctr");
		parentConstraint -skipRotate x -skipRotate y -skipRotate z ($modCore + "_MidIk_CtrlLctr") ($modCore + "_MidIk_CtrlWSLctr")($modCore + "_MidIk_CtrlGrp");
		orientConstraint ($modCore + "_MidIk_CtrlLctr") ($modCore + "_MidIk_CtrlWSLctr")($modCore + "_MidIk_CtrlGrp");
		setAttr ($modCore + "_MidIk_CtrlGrp_orientConstraint1.interpType") 2;
		
		//PARENT ORIENT/TRANSLATE MID IkCG
		addAttr -ln "midTranslate" -at double -min 0 -max 1 -dv 1 ($modCore + "_MidIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_MidIk_Ctrl.midTranslate");
		connectAttr -force ($modCore + "_MidIk_Ctrl.midTranslate") ($modCore + "_MidIk_CtrlGrp_parentConstraint1." + $modCore + "_MidIk_CtrlLctrW0");

		shadingNode -asUtility reverse -n ($modCore + "_MidIkCParentTranslateReverse");
		connectAttr -force ($modCore + "_MidIk_Ctrl.midTranslate") ($modCore + "_MidIkCParentTranslateReverse.inputX");
		connectAttr -force ($modCore + "_MidIkCParentTranslateReverse.outputX") ($modCore + "_MidIk_CtrlGrp_parentConstraint1." + $modCore + "_MidIk_CtrlWSLctrW1");


		addAttr -ln "midOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_MidIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_MidIk_Ctrl.midOrient");
		connectAttr -force ($modCore + "_MidIk_Ctrl.midOrient") ($modCore + "_MidIk_CtrlGrp_orientConstraint1." + $modCore + "_MidIk_CtrlLctrW0");
		
		shadingNode -asUtility reverse -n ($modCore + "_MidIkCParentOrientReverse");
		connectAttr -force ($modCore + "_MidIk_Ctrl.midOrient") ($modCore + "_MidIkCParentOrientReverse.inputX");
		connectAttr -force ($modCore + "_MidIkCParentOrientReverse.outputX") ($modCore + "_MidIk_CtrlGrp_orientConstraint1." + $modCore + "_MidIk_CtrlWSLctrW1");

		
		//TOP IkC
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "MAIN_Inner_Ctrl") ($modCore + $nPd + $splineNumTop + "Fk_Ctrl") ($modCore + "_TopIk_CtrlGrp");
		parentConstraint -mo ($modCore + $nPd + $splineNumTop + "Fk_Ctrl") ($modCore + "_TopIk_Ctrl_FlipLctr2");
		orientConstraint -mo ($modCore + "_TopIk_Ctrl_FlipLctr1") ($modCore + "_TopIk_Ctrl_FlipLctr2") ($modCore + "_TopIk_CtrlGrp");
			
		//PARENT ORIENT/TRANSLATE TOP IkCG
		addAttr -ln "topTranslate" -at double -min 0 -max 1 -dv 1 ($modCore + "_TopIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_TopIk_Ctrl.topTranslate");
		connectAttr -force ($modCore + "_TopIk_Ctrl.topTranslate") ($modCore + "_TopIk_CtrlGrp_parentConstraint1." + $modCore + $nPd + $splineNumTop + "Fk_CtrlW1");

		shadingNode -asUtility reverse -n ($modCore + "_TopIkCParentTranslateReverse");
		connectAttr -force ($modCore + "_TopIk_Ctrl.topTranslate") ($modCore + "_TopIkCParentTranslateReverse.inputX");
		connectAttr -force ($modCore + "_TopIkCParentTranslateReverse.outputX") ($modCore + "_TopIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");


		addAttr -ln "topOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_TopIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_TopIk_Ctrl.topOrient");
		connectAttr -force ($modCore + "_TopIk_Ctrl.topOrient") ($modCore + "_TopIk_CtrlGrp_orientConstraint1." + $modCore + "_TopIk_Ctrl_FlipLctr2W1");
		
		shadingNode -asUtility reverse -n ($modCore + "_TopIkCParentOrientReverse");
		connectAttr -force ($modCore + "_TopIk_Ctrl.topOrient") ($modCore + "_TopIkCParentOrientReverse.inputX");
		connectAttr -force ($modCore + "_TopIkCParentOrientReverse.outputX") ($modCore + "_TopIk_CtrlGrp_orientConstraint1." + $modCore + "_TopIk_Ctrl_FlipLctr1W0");

		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////RIBBON SPLINE////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		
		//GET SPLINE LENGTH
		spaceLocator -n ($modCore + "_StartLctr");
		parent ($modCore + "_StartLctr") ($modCore + "Grp");
		spaceLocator -n ($modCore + "_EndLctr");
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
		pointConstraint ($modCore) ($modCore + "_StartLctr");
		if ($twistAxis == 1)
		{
			aimConstraint -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_TopIk_Ctrl") ($modCore + "_StartLctr");			
		}
		else
		{
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_TopIk_Ctrl") ($modCore + "_StartLctr");
		}
		pointConstraint ($modCore + "_TopIk_Ctrl") ($modCore + "_EndLctr");
		
		//SPLINE START POSITION
		nurbsPlane -n ($modCore + "_ribbon") -p 0 0 0 -ax 0 0 1 -w 1 -lr 3 -u 1 -v ($splineSize) -ch 1;
		rebuildSurface -ch 1 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kc 0 -su 1 -du 1 -sv 2 -dv 3 -fr 0 -dir 0 ($modCore + "_ribbon");
		delete -ch ($modCore + "_ribbon");
		parent ($modCore + "_ribbon") ($modCore + "Grp");
		
		//RIBBON BLENDSHAPE
		duplicate -rr -n ($modCore + "_ribbonBlend") ($modCore + "_ribbon");
		select ($modCore + "_ribbonBlend.cv[1][*]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_ribbonBlend_lCluster");
		move 0 0 0 ($modCore + "_ribbonBlend_lCluster.scalePivot") ($modCore + "_ribbonBlend_lCluster.rotatePivot") ;
		select ($modCore + "_ribbonBlend.cv[0][*]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_ribbonBlend_rCluster");
		move 0 0 0 ($modCore + "_ribbonBlend_rCluster.scalePivot") ($modCore + "_ribbonBlend_rCluster.rotatePivot") ;
		
		select ($modCore + "_ribbonBlend") ($modCore + "_ribbon") ;
		blendShape -n ($modCore + "_ribbonBlendShape") -tc 0;
		setAttr ($modCore + "_ribbonBlendShape1." + $modRigName + "" + $prfx + $core + "_ribbonBlend") 1;
		
		group -n ($modCore + "_ribbonBlend_lClusterGrp") ($modCore + "_ribbonBlend_lCluster");xform -os -piv 0 0 0;
		group -n ($modCore + "_ribbonBlend_rClusterGrp") ($modCore + "_ribbonBlend_rCluster");xform -os -piv 0 0 0;
		parent ($modCore + "_ribbonBlend_lClusterGrp") ($modCore + "_ribbonBlend_rClusterGrp") ($modCore + "Grp");
		
		//CHECK FOR NUCLEUS
		int $nucleusCheck;
		if (`objExists "nucleus1"`)
		{
			$nucleusCheck = 1;
		}

		//ORIENT RIBBON
		//HAIR
		select ($modCore + "_ribbon");
		createHair 1 ($splineSize) 10 0 0 0 0 5 0 2 1 1;

		
		//DELETE NUCLEUS IF IT WAS JUST CREATED
		$hairSystemShape = `ls -sl`;
		$nucleus = `listConnections -type "nucleus"`;
		if ($nucleusCheck == 0 && `size $nucleus` > 0)
		{
			delete $nucleus;
		}
		
		string $hairSystem[] = `listRelatives -parent $hairSystemShape`;
		
		delete $hairSystem[0] ($hairSystem[0] + "OutputCurves");
		select ($hairSystem[0] + "Follicles");
		rename ($hairSystem[0] + "Follicles") ($modCore + "_hairSystemFollicles");
		parent ($modCore + "_hairSystemFollicles") ($modCore + "Grp");
	
		select -hi ($modCore + "_hairSystemFollicles");
		select -d ($modCore + "_hairSystemFollicles");
		$follicles = `ls -sl`;
		float $folliclesNum = `size $follicles`;
		$folliclesNum = $folliclesNum/3;		
		int $hierarchySize = 2;
		select ($modCore + "_hairSystemFollicles");
		pickWalk -d down;
		rename ($modCore + "_01F");
		while ($hierarchySize <= $folliclesNum)
		{
			pickWalk -d right;
			$previous = `ls -sl`;
			if ($hierarchySize < 10)
			{
				rename ($modCore + "_0" + $hierarchySize + "F");
			}
			else
			{
				rename ($modCore + "_" + $hierarchySize + "F");
			}
			$hierarchySize++;
		}
		
		//GROUP AND SCALE
		group -n ($modCore + "_ribbonSplineGrp") ($modCore + "_ribbon");
		
		$splineLength = `xform -q -t ($modCore + "_EndLctr")`;
		if ($twistAxis == 1)
		{
			setAttr (($modCore + "_ribbonSplineGrp.scale"), ($splineLength[1] / 4), ($splineLength[1] / 4), ($splineLength[1] / 4));
		}
		else
		{
			setAttr (($modCore + "_ribbonSplineGrp.scale"), ($splineLength[0] / 4), ($splineLength[0] / 4), ($splineLength[0] / 4));
		}
		//CONNECT TO RIG
		delete `parentConstraint ($modCore + "_OrientLctr") ($modCore + "_ribbonSplineGrp")`;
		if ($twistAxis == 0)
		{
			rotate -r -os 0 0 -90 ($modCore + "_ribbonSplineGrp");
		}
		delete `pointConstraint ($modCore + "_OrientLctr") ($modCore + "_OrientLengthLctr") ($modCore + "_ribbonSplineGrp")`;

		select ($modCore + "_??F");
		pickWalk -d down;
		pickWalk -d right;
		delete;
		
		select -cl;
		
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//LOCATORS FOR POSITIONS
	
		//JOINT LOCATIONS
		$ParentPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Parent")`;
		$spineTopPos = `xform -q -ws -rp ($modCore + "_TopIk_Ctrl")`;
		
		$splineProxies = `ls -type "transform" ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = `size $splineProxies`;
		
		$vertebrae = ($splineSize + 1);
	
		//PATHS
		curve -n ($modCore + "_SplineBtm") -d 1 -p $ParentPos[0] $ParentPos[1] $ParentPos[2] -p $spineTopPos[0] $spineTopPos[1] $spineTopPos[2];
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s ($vertebrae - 2) ($modCore + "_SplineBtm");
	
		int $i = 1;
		for ($each in $splineProxies)
		{
			$splinePos = `xform -q -ws -rp $each`;
			move -ws $splinePos[0] $splinePos[1] $splinePos[2] ($modCore + "_SplineBtm.cv[" + $i + "]");
			$i++;
		}
		rename `listRelatives -c ($modCore + "_SplineBtm")` ($modCore + "_SplineBtmShape");
		
		float $vertebraeFloat = $vertebrae;
		
		//CUT CURVE IN HALF
		detachCurve -ch 0 -cos on -rpo 1 -n ($modCore + "_SplineTop") ($modCore + "_SplineBtm.u[0.5]");
		rename ($modCore + "_SplineTop1") ($modCore + "_SplineTop");
		
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 1 ($modCore + "_SplineBtm");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 1 ($modCore + "_SplineTop");
		
		parent ($modCore + "_SplineTop") ($modCore + "_SplineBtm") ($modCore + "Grp");

		addAttr -ln "nonControl" -dt "string" ($modCore + "_SplineTop");
		setAttr -e -k 1 ($modCore + "_SplineTop.nonControl");
		setAttr -l 1 ($modCore + "_SplineTop.nonControl");

		addAttr -ln "nonControl" -dt "string" ($modCore + "_SplineBtm");
		setAttr -e -k 1 ($modCore + "_SplineBtm.nonControl");
		setAttr -l 1 ($modCore + "_SplineBtm.nonControl");
		
		//LOCK AND HIDE CHANNELS
		setAttr ($modCore + "_SplineTop.v") 0;
		setAttr ($modCore + "_SplineBtm.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.tx");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.ty");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.tz");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.rx");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.ry");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.rz");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.sx");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.sy");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.sz");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.v");

		setAttr -l 1 -k 0 ($modCore + "_SplineTop.tx");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.ty");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.tz");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.rx");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.ry");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.rz");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.sx");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.sy");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.sz");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.v");

		
		//ATTACH LOCATORS TO PATHS
		int $i = 1;
		float $uValueComp = 1;
		string $crntUnit = `currentUnit -query -linear`;
		if ($crntUnit == "m")
		{
			$uValueComp = 0.01;
		}
		else if ($crntUnit == "mm")
		{
			$uValueComp = 10.0;
		}
		else if ($crntUnit == "in")
		{
			$uValueComp = 0.393701;
		}
		else if ($crntUnit == "ft")
		{
			$uValueComp = 0.0328084;
		}
		else if ($crntUnit == "yd")
		{
			$uValueComp = 0.0109361;
		}

		string $nPd = "_0"; 
		for ($each in $splineProxies)
		{
			if ($i >= 10)
			{
				$nPd = "_";
			}
			spaceLocator -n ($modCore + $nPd + $i + "CurveLctr");
			group -n ($modCore + $nPd + $i + "CurveLctrGrp");
			if ($i <= (($splineSize + 1)/2))
			{
				pathAnimation -n ($modCore + $nPd + $i + "Lctr_MP") -fractionMode true -follow true -followAxis x -upAxis z
				-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + $nPd + $i + "F") -inverseUp false -inverseFront false -bank false
				($modCore + $nPd + $i + "CurveLctrGrp") ($modCore + "_SplineBtm");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $nPd + $i + "Lctr_MP");
				float $uValue = ((float)$i/(((float)$splineSize + 1.0)/2.0));
				if ($uValue > 0.99999)
				{
					$uValue = (0.99999 * $uValueComp);
				}
				else
				{
					$uValue = ($uValue * $uValueComp);
				}
				setAttr ($modCore + $nPd + $i + "Lctr_MP.uValue") $uValue;
			}
			else
			{
				pathAnimation -n ($modCore + $nPd + $i + "Lctr_MP") -fractionMode true -follow true -followAxis x -upAxis z
				-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + $nPd + $i + "F") -inverseUp false -inverseFront false -bank false
				($modCore + $nPd + $i + "CurveLctrGrp") ($modCore + "_SplineTop");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $nPd + $i + "Lctr_MP");
				float $uValue = (((float)$i - (((float)$splineSize + 1.0)/2.0))/(((float)$splineSize + 1.0)/2.0));
				if ($uValue > 0.99999)
				{
					$uValue = (0.99999 * $uValueComp);
				}
				else
				{
					$uValue = ($uValue * $uValueComp);
				}
				setAttr ($modCore + $nPd + $i + "Lctr_MP.uValue") $uValue;
			}
			delete `parentConstraint ($modCore + $nPd + $i + "Fk_Ctrl") ($modCore + $nPd + $i + "CurveLctr")`;
			$i++;
		}

		$curveLctrGrp = `ls ($modCore + "_??CurveLctrGrp")`;
		parent $curveLctrGrp ($modCore + "Grp");
		//CONNECT TO MAIN_Ctrl SCALE
		for ($each in $curveLctrGrp)
		{
			connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($each + ".scale");
		}
		
		//GET POSITIONS
		$modAttachNodePos = `xform -q -ws -rp ($modCore)`;
		$spineTopJPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Top")`;
		$SpineCenter = `xform -q -ws -t ($modCore + "_SplineTop.cv[0]")`;
		
		//CREATE CLUSTERS SPLINE SPLINE
		select ($modCore + "_SplineBtm.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineBtm_BtmClstr");
		group -n ($modCore + "_SplineBtm_ClusterGrp") ($modCore + "_SplineBtm_BtmClstr");
		xform -os -piv $modAttachNodePos[0] $modAttachNodePos[1] $modAttachNodePos[2];
		if ($modAttachNode != "ROOT")
		{
			parentConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_SplineBtm_ClusterGrp");
		}
		else
		{
			parentConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_SplineBtm_ClusterGrp");
		}
		
		select ($modCore + "_SplineBtm.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineBtm_TopClstr");
	
		select ($modCore + "_SplineTop.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineTop_BtmClstr");
		
		group -n ($modCore + "_SplineMid_ClusterGrp") ($modCore + "_SplineBtm_TopClstr")($modCore + "_SplineTop_BtmClstr");
		xform -os -piv $SpineCenter[0] $SpineCenter[1] $SpineCenter[2];
		parentConstraint -mo ($modCore + "_MidIk_Ctrl") ($modCore + "_SplineMid_ClusterGrp");
		
		select ($modCore + "_SplineTop.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineTop_TopClstr");
		group -n ($modCore + "_SplineTop_ClusterGrp") ($modCore + "_SplineTop_TopClstr");
		xform -os -piv $spineTopJPos[0] $spineTopJPos[1] $spineTopJPos[2];
		parentConstraint -mo ($modCore + "_TopIk_Ctrl") ($modCore + "_SplineTop_ClusterGrp");
											 
		parent ($modCore + "_SplineTop_ClusterGrp") ($modCore + "_SplineMid_ClusterGrp") ($modCore + "_SplineBtm_ClusterGrp") ($modCore + "_ScaleGrp");
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//TOP AND BOTTOM JOINTS
		select -cl;
		joint -n ($modCore + "_TopJnt");
		delete `parentConstraint ($modCore + "_TopIk_Ctrl") ($modCore + "_TopJnt")`;
		if ($twistAxis == 1)
		{
			rotate -r -os -90 0 90 ($modCore + "_TopJnt");
		}
		makeIdentity -apply true -r 1 ($modCore + "_TopJnt");
		parentConstraint -mo ($modCore + "_TopIk_Ctrl") ($modCore + "_TopJnt");
		//CONNECT SCALE
		connectAttr -f ($modCore + "_TopIk_Ctrl.scaleX") ($modCore + "_TopJnt.scaleY");
		connectAttr -f ($modCore + "_TopIk_Ctrl.scaleY") ($modCore + "_TopJnt.scaleX");
		connectAttr -f ($modCore + "_TopIk_Ctrl.scaleZ") ($modCore + "_TopJnt.scaleZ");
			
		parent ($modCore + "_TopJnt") ($modCore + "_ScaleGrp");
			
		select -cl;
		joint -n ($modCore + "_TopJntIk") -p 0 2 0 ;
		
		select -cl;
		joint -n ($modCore + "_BtmJntIk") -p 0 -2 0 ;
		
		select -cl;
		joint -n ($modCore + "_MidJntIk") -p 0 0 0 ;

		parent ($modCore + "_BtmJntIk") ($modCore + "_MidJntIk") ($modCore + "_TopJntIk") ($modCore + "_ScaleGrp");
		
		string $selectedList[] = `ls ($modCore + "_TopJntIk") ($modCore + "_BtmJntIk") ($modCore + "_MidJntIk")`;
				
		for ($crntObject in $selectedList)		
		{
			if ($twistAxis == 0)
			{
				setAttr (($crntObject + ".jointOrient"), -90, 0, 90);
			}
			setAttr ($crntObject + ".radius") .5;
		}
		
		parentConstraint ($modCore + "_TopIk_Ctrl") ($modCore + "_TopJntIk") ;
		
		parentConstraint ($modCore + "_MidIk_Ctrl") ($modCore + "_MidJntIk") ;
		
		if ($modAttachNode != "ROOT")
		{
			parentConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_BtmJntIk") ;
		}
		else
		{
			parentConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_BtmJntIk") ;
		}

		select ($modCore + "_ribbon") ($modCore + "_TopJntIk") ($modCore + "_BtmJntIk") ($modCore + "_MidJntIk");
		//DETERMINE VERSION NUMBER
		//$versionNum = `getApplicationVersionAsFloat`;
		if (`getApplicationVersionAsFloat` >= 2013)
		{
			skinCluster -n ($modCore + "_ribbonSkinClstr") -bindMethod 1 -toSelectedBones -nw 1 -mi 3 -dr 4 -rui 0;
		}
		else
		{
			skinCluster -n ($modCore + "_ribbonSkinClstr") -toSelectedBones -ignoreHierarchy -mi 3 -dr 1 -rui 0;
		}
		//GENERATE JOINTS
		//string $splineJoints[];
		int $crntNum = 0;
		float $splineLoc[];
		for ($crntProxy in $splineProxies)
		{
			$crntNum++;
			$numPadding = "_0";
			if ($crntNum >= 10)
			{$numPadding = "_";}

			curve -n ($modCore + $numPadding + $crntNum + "Curve_Ctrl") -d 1 -p -4 0 0 -p 4 0 0 -k 0 -k 1;
			rename `listRelatives ($modCore + $numPadding + $crntNum + "Curve_Ctrl")` ($modCore + $numPadding + $crntNum + "Curve_CtrlShape");

			circle -n ($modCore + $numPadding + $crntNum + "Curve_Ctrl2") -c 5 0 0 -nr 0 1 0 -r 1 -ch 0;
			circle -n ($modCore + $numPadding + $crntNum + "Curve_Ctrl3") -c -5 0 0 -nr 0 1 0 -r 1 -ch 0;				

			parent -r -s ($modCore + $numPadding + $crntNum + "Curve_Ctrl2Shape") ($modCore + $numPadding + $crntNum + "Curve_Ctrl3Shape") ($modCore + $numPadding + $crntNum + "Curve_Ctrl");
			delete ($modCore + $numPadding + $crntNum + "Curve_Ctrl2") ($modCore + $numPadding + $crntNum + "Curve_Ctrl3");
			
			if ($twistAxis == 0)
			{
				rotate -r -os 90 90 0 ($modCore + $numPadding + $crntNum + "Curve_Ctrl");
			}
			setAttr (($modCore + $numPadding + $crntNum + "Curve_Ctrl.scale"), ($getSplineLength*.06),($getSplineLength*.06),($getSplineLength*.06));
			makeIdentity -apply true -r 1 -s 1 ($modCore + $numPadding + $crntNum + "Curve_Ctrl");
				
			group -n ($modCore + $numPadding + $crntNum + "Curve_CtrlGrp") ($modCore + $numPadding + $crntNum + "Curve_Ctrl");

			delete `parentConstraint ("RRM_" + $prfx + $core + $numPadding + $crntNum) ($modCore + $numPadding + $crntNum + "Curve_CtrlGrp")`;
			pointConstraint -mo ($modCore + $numPadding + $crntNum + "CurveLctr") ($modCore + $numPadding + $crntNum + "Fk_Ctrl") ($modCore + $numPadding + $crntNum + "Curve_CtrlGrp");
			orientConstraint -mo ($modCore + $numPadding + $crntNum + "F") ($modCore + $numPadding + $crntNum + "CurveLctr");
			orientConstraint ($modCore + $numPadding + $crntNum + "CurveLctr") ($modCore + $numPadding + $crntNum + "Fk_Ctrl") ($modCore + $numPadding + $crntNum + "Curve_CtrlGrp");
			setAttr ($modCore + $numPadding + $crntNum + "CurveLctr_orientConstraint1.interpType") 2;
			setAttr ($modCore + $numPadding + $crntNum + "Curve_CtrlGrp_orientConstraint1.interpType") 2;
			
			select -cl;
			joint -n ($modCore + $numPadding + $crntNum + "Jnt");

			parent ($modCore + $numPadding + $crntNum + "Curve_CtrlGrp") ($modCore + $numPadding + $crntNum + "Jnt") ($modCore + "_ScaleGrp");

			delete `parentConstraint ($modCore + $numPadding + $crntNum + "Curve_Ctrl") ($modCore + $numPadding + $crntNum + "Jnt")`;
			if ($twistAxis == 1)
			{
				rotate -r -os -90 0 90 ($modCore + $numPadding + $crntNum + "Jnt");
			}
			makeIdentity -apply true -r 1 ($modCore + $numPadding + $crntNum + "Jnt");
			parentConstraint -mo ($modCore + $numPadding + $crntNum + "Curve_Ctrl") ($modCore + $numPadding + $crntNum + "Jnt");
			//$splineJoints = `ls ($modCore + $numPadding + $crntNum + "Jnt")`;
		}	

		//SPLINE FOLLOW Fk
		addAttr -ln "followFk_Ctrl" -at double -min 0 -max 1 -dv 0 ($modCore + "_TopIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_TopIk_Ctrl.followFk_Ctrl");
		
		//SELECT Fk_Ctrl
		$spineGrp = `ls ($modCore + "_??Curve_CtrlGrp")`;
		string $nPd = "0";
		$i = 1;
		for ($each in $spineGrp)
		{
			if ($i >= 10)
			{
				$nPd = "";
			}
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1") 0;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1") 0;
	 
			setDrivenKeyframe -currentDriver ($modCore + "_TopIk_Ctrl.followFk_Ctrl")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1");
			
			setAttr ($modCore + "_TopIk_Ctrl.followFk_Ctrl") 1;
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0") 0;
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1") 1;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0") 0;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1") 1;
	 
			setDrivenKeyframe -currentDriver ($modCore + "_TopIk_Ctrl.followFk_Ctrl")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "Fk_CtrlW1");
			
			//selectKey -k ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY") ;
			keyTangent -itt spline -ott spline ($each + "_pointConstraint1_" + $modCore + "_" + $nPd + $i + "CurveLctrW0") ($each + "_pointConstraint1_" + $modCore + "_" + $nPd + $i + "Fk_CtrlW1");
			
			setAttr ($modCore + "_TopIk_Ctrl.followFk_Ctrl") 0;
			
			$i++;
		}
		
		//CREATE CURVE FOR SPLINE LENGTH
		$Parent_Pos = `xform -q -ws -t ("RRM_" + $prfx + $core + "_Parent")`;
		$spineMidJntIk_Pos = `xform -q -ws -t ($modCore + "_MidJntIk")`;
		$spineTop_Pos = `xform -q -ws -t ($modCore + "_TopJntIk")`;
		
		curve -n ($modCore + "_LengthCurve")
		-p $Parent_Pos[0] $Parent_Pos[1] $Parent_Pos[2]
		-p (( $spineMidJntIk_Pos[0] - $Parent_Pos[0]) /3.4 + $Parent_Pos[0])
		(( $spineMidJntIk_Pos[1] - $Parent_Pos[1]) /3.4 + $Parent_Pos[1])
		(( $spineMidJntIk_Pos[2] - $Parent_Pos[2]) /3.4 + $Parent_Pos[2])
		
		-p (( $spineMidJntIk_Pos[0] - $Parent_Pos[0]) /1.35 + $Parent_Pos[0])
		(( $spineMidJntIk_Pos[1] - $Parent_Pos[1]) /1.35 + $Parent_Pos[1])
		(( $spineMidJntIk_Pos[2] - $Parent_Pos[2]) /1.35 + $Parent_Pos[2])
		
		-p (($spineTop_Pos[0] - $spineMidJntIk_Pos[0]) /3.7 + $spineMidJntIk_Pos[0])
		(($spineTop_Pos[1] - $spineMidJntIk_Pos[1]) /3.7 + $spineMidJntIk_Pos[1])
		(($spineTop_Pos[2] - $spineMidJntIk_Pos[2]) /3.7 + $spineMidJntIk_Pos[2])
		
		-p (($spineTop_Pos[0] - $spineMidJntIk_Pos[0]) /1.4 + $spineMidJntIk_Pos[0])
		(($spineTop_Pos[1] - $spineMidJntIk_Pos[1]) /1.4 + $spineMidJntIk_Pos[1])
		(($spineTop_Pos[2] - $spineMidJntIk_Pos[2]) /1.4 + $spineMidJntIk_Pos[2])
		-p $spineTop_Pos[0] $spineTop_Pos[1] $spineTop_Pos[2]
		-k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 3 -k 3;
		rename `listRelatives -c ($modCore + "_LengthCurve")` ($modCore + "_Length_CtrlShape");
		select ($modCore + "_LengthCurve");
		arclen -ch 1;
		string $curveInfoNode[] = `listConnections -t curveInfo -d 1 -s 0 ($modCore + "_Length_CtrlShape")`;
		rename $curveInfoNode[0] ($modCore + "_LengthInfo");	
		
		parent ($modCore + "_LengthCurve") ($modCore + "Grp");
		
		//ATTACH CURVE TO RIG
		select ($modCore + "_LengthCurve.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr01");
		
		select ($modCore + "_LengthCurve.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr02");
		
		select ($modCore + "_LengthCurve.cv[4:5]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr03");
		
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modRigName + "" + $modAttachNode + "Jnt.matrix") ($modCore + "_LengthClstr01Shape.weightedNode");
			setAttr ($modCore + "_LengthClstr01Cluster.relative") 0;
			parent ($modCore + "_LengthClstr01") ($modCore + "_ScaleGrp");
			parentConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_LengthClstr01");
		}
		else
		{
			connectAttr -f ($modRigName + "" + $modAttachNode + "Secondary_Ctrl.matrix") ($modCore + "_LengthClstr01Shape.weightedNode");
			setAttr ($modCore + "_LengthClstr01Cluster.relative") 0;
			parent ($modCore + "_LengthClstr01") ($modCore + "_ScaleGrp");
			parentConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_LengthClstr01");
		}

		connectAttr -f ($modCore + "_MidIk_Ctrl.matrix") ($modCore + "_LengthClstr02Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr02Cluster.relative") 0;
		parent ($modCore + "_LengthClstr02") ($modCore + "_MidIk_Ctrl");
		
		connectAttr -f ($modCore + "_TopIk_Ctrl.matrix") ($modCore + "_LengthClstr03Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr03Cluster.relative") 0;
		parent ($modCore + "_LengthClstr03") ($modCore + "_TopIk_Ctrl");
		
		//SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HierarchyCompensate_MD");
		setAttr ($modCore + "_HierarchyCompensate_MD.operation") 2;
		connectAttr -f ($modCore + "_LengthInfo.arcLength") ($modCore + "_HierarchyCompensate_MD.input1X");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modCore + "_HierarchyCompensate_MD.input2X");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthRatio_MD");
		connectAttr -f ($modCore + "_HierarchyCompensate_MD.outputX") ($modCore + "_LengthRatio_MD.input1X");
		setAttr ($modCore + "_LengthRatio_MD.operation") 2;
		
		float $SpineLengthValue = `getAttr ($modCore + "_LengthInfo.arcLength")`;
		setAttr ($modCore + "_LengthRatio_MD.input2X") $SpineLengthValue;
		
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_TopJntIk.scaleY");
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_MidJntIk.scaleY");
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_BtmJntIk.scaleY");
		
		//INVERSE SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthRatioInverse_MD");
		connectAttr -f ($modCore + "_HierarchyCompensate_MD.outputX") ($modCore + "_LengthRatioInverse_MD.input2X");
		setAttr ($modCore + "_LengthRatioInverse_MD.operation") 2;
		
		setAttr ($modCore + "_LengthRatioInverse_MD.input1X") $SpineLengthValue;
		
		shadingNode -asUtility blendColors -n ($modCore + "_LengthRatioInverse_Blnd");
		setAttr ($modCore + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_LengthRatioInverse_MD.outputX") ($modCore + "_LengthRatioInverse_Blnd.color1R");
	
		$spineJnt = `ls ($modCore + "_??Jnt")`;
		int $i= 0;
		for ($crntJnt in $spineJnt)
		{
			$i++;
			string $numPad = "_0";
			if ($i >= 10)
			{
				$numPad = "_";
			}
			//CONNECT MICRO CONTROL TO SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD");
			connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl.scaleX") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input2X");
			connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl.scaleY") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input2Y");
			connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl.scaleZ") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input2Z");
		
			if ($twistAxis == 1)
			{
				connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input1Y");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input1X");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input1Z");
				connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.output") ($crntJnt + ".scale");
			}
			else
			{
				connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input1X");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input1Y");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.input1Z");
			}
			
			connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.outputX") ($crntJnt + ".sy");
			connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.outputY") ($crntJnt + ".sx");
			connectAttr -f ($modCore + $numPad + $i + "Curve_Ctrl_Scale_MD.outputZ") ($crntJnt + ".sz");
		}
		
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_TopJntIk.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_TopJntIk.scaleZ");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_MidJntIk.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_MidJntIk.scaleZ");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_BtmJntIk.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_BtmJntIk.scaleZ");
		
		//ADD ATTRIBUTES TO TOPIkC
		//PARENT ORIENT
		$parentOrient = ($modCore + "_TopIk_Ctrl");
		RRM_ParentOrient($modRigName, $modCore, $modAttachNode, $parentOrient); 
			
		//AUTO VOLUME
		addAttr -ln "autoVolume" -at double -min 0 -max 1 -dv 1 ($modCore + "_TopIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_TopIk_Ctrl.autoVolume");
		connectAttr -force ($modCore + "_TopIk_Ctrl.autoVolume") ($modCore + "_LengthRatioInverse_Blnd.blender");
		setAttr ($modCore + "_TopIk_Ctrl.autoVolume") 1;
	
		//SPLINE CURVE
		addAttr -ln "splineCurve" -at double -min 0.001 -max 5 -dv 1 ($modCore + "_TopIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_TopIk_Ctrl.splineCurve");
		
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//RIBBON SPLINE
		
		//CREATE LOCATORS FOR TX
		spaceLocator -n ($modCore + "_BtmTX_Lctr") -p 0 0 0;
		parent ($modCore + "_BtmTX_Lctr") ($modCore + "_ScaleGrp");
		pointConstraint ($modCore + "_MidIk_Ctrl") ($modCore + "_BtmTX_Lctr");
		
		spaceLocator -n ($modCore + "_TopTX_Lctr") -p 0 0 0;
		parent ($modCore + "_TopTX_Lctr") ($modCore + "_TopIk_Ctrl");
		pointConstraint ($modCore + "_MidIk_Ctrl") ($modCore + "_TopTX_Lctr");
		
		//SET DRIVEN KEY
		setDrivenKeyframe -currentDriver ($modCore + "_MidIk_Ctrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIk_Ctrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIk_Ctrl.translateX") -4;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") .8;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") 1.2;
		setDrivenKeyframe -currentDriver ($modCore + "_MidIk_Ctrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIk_Ctrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIk_Ctrl.translateX") 4;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") 1.2;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") .8;
		setDrivenKeyframe -currentDriver ($modCore + "_MidIk_Ctrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIk_Ctrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIk_Ctrl.translateX") 0;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") 1;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") 1;
		
		//selectKey -k ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY") ;
		keyTangent -itt spline -ott spline ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY");
		
		//ATTACH NODE LOCATOR WITH ZEROED VALUES
		spaceLocator -n ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr");
		group -n ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp");
		delete `pointConstraint ($modCore) ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp")`;
		delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_MidIk_Ctrl")
		($modCore + "_TopIk_Ctrl") ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp")`;
		parent ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp") ($modCore + "_ScaleGrp");
		makeIdentity -apply true -t 1 -r 0 -s 1 ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp");
		parentConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr");
		
	
		//CONNECT SPLINE Ik MIDDLE TO TOP AND BOTTOM SPLINE Ik
		shadingNode -n ($modCore + "_SplineMid_Blnd") -asUtility blendColors;
		connectAttr -f ($modCore + "_TopIk_Ctrl.translate") ($modCore + "_SplineMid_Blnd.color1");
		connectAttr -f ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.translate") ($modCore + "_SplineMid_Blnd.color2");

		
		spaceLocator -n ($modCore + "_MidSplineAimLctr");
		spaceLocator -n ($modCore + "_MidSplineTargetLctr");
		group -n ($modCore + "_MidSplineLctrGrp") ($modCore + "_MidSplineAimLctr") ($modCore + "_MidSplineTargetLctr");
		parent ($modCore + "_MidSplineLctrGrp") ($modCore + "_ScaleGrp");
		delete `pointConstraint ($modCore) ($modCore + "_MidSplineLctrGrp")`;
		if ($twistAxis == 1)
		{
			delete `aimConstraint -aimVector 0 ($behaviorMultiplier * 1) 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_MidIk_Ctrl")
			($modCore + "_TopIk_Ctrl") ($modCore + "_MidSplineLctrGrp")`;
		}
		else
		{
			delete `aimConstraint -aimVector ($behaviorMultiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectRotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_MidIk_Ctrl")
			($modCore + "_TopIk_Ctrl") ($modCore + "_MidSplineLctrGrp")`;
		}			
		delete `pointConstraint ($modCore + "_TopIk_Ctrl") ($modCore + "_MidSplineTargetLctr")`;
		
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MidSplineAimLctr") ($modCore + "_MidSplineTargetLctr");

		connectAttr -f ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.translate") ($modCore + "_MidSplineAimLctr.translate");
		connectAttr -f ($modCore + "_TopIk_Ctrl.translate") ($modCore + "_MidSplineTargetLctr.translate");
		
		if ($twistAxis == 1)
		{
			aimConstraint -aimVector 0 ($behaviorMultiplier * 1) 0 -upVector 0 1 0 -worldUpType "none" -skip y ($modCore + "_MidSplineTargetLctr") ($modCore + "_MidSplineAimLctr");
		}
		else
		{		
			aimConstraint -aimVector ($behaviorMultiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ($modCore + "_MidSplineTargetLctr") ($modCore + "_MidSplineAimLctr");
		}

		//CREATE ATTRIBUTES FOR Ik/Fk MIDIk_CtrlGrp INFLUENCE
		addAttr -ln "topIkInfPos" -at double -min 0 -max 1 -dv 0.5 ($modCore + "_MidIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_MidIk_Ctrl.topIkInfPos");
		addAttr -ln "topIkInfRot" -at double -min 0 -max 1 -dv 0.5 ($modCore + "_MidIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_MidIk_Ctrl.topIkInfRot");
		
		//CREATE LOCATOR FOR Ik/Fk MIDIk_CtrlGrp INFLUENCE
		spaceLocator -n ($modCore + "_MidIk_CtrlLctrGrp_InfLctr");
		group -n ($modCore + "_MidIk_CtrlLctrGrp_InfLctrGrp");
		delete `parentConstraint ($modCore + "_MidIk_Ctrl") ($modCore + "_MidIk_CtrlLctrGrp_InfLctrGrp")`;
		parent ($modCore + "_MidIk_CtrlLctrGrp_InfLctrGrp") ($modCore + "_ScaleGrp");
		makeIdentity -apply true -t 1 ($modCore + "_MidIk_CtrlLctrGrp_InfLctr");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_TopIk_Ctrl") ($modCore + "_MidIk_CtrlLctrGrp_InfLctr");
		if ($twistAxis == 1)
		{
			aimConstraint -weight 1 -aimVector 0 $behaviorMultiplier 0 -upVector 0 0 1 -worldUpType "none" -skip y ($modCore + "_TopIk_Ctrl") ($modCore + "_MidIk_CtrlLctrGrp_InfLctr");
		}
		else
		{	
			aimConstraint -weight 1 -aimVector $behaviorMultiplier 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ($modCore + "_TopIk_Ctrl") ($modCore + "_MidIk_CtrlLctrGrp_InfLctr");
		}
		setAttr ($modCore + "_MidIk_CtrlLctrGrp_InfLctr.v") 0;
		
		//ROTATE BLEND
		shadingNode -asUtility blendColors -n ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend");
		connectAttr -force ($modCore + "_MidSplineAimLctr.rotate") ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend.color2");
		connectAttr -force ($modCore + "_MidIk_CtrlLctrGrp_InfLctr.rotate") ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend.color1");
		connectAttr -force ($modCore + "_MidIk_Ctrl.topIkInfRot") ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend.blender");
		

		connectAttr -force ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend.outputR") ($modCore + "_MidIk_CtrlLctr.rotateX");
		connectAttr -force ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend.outputG") ($modCore + "_MidIk_CtrlLctr.rotateY");
		connectAttr -force ($modCore + "_MidIk_CtrlLctrGrp_Inf_Rot_Blend.outputB") ($modCore + "_MidIk_CtrlLctr.rotateZ");
		
		
		//TRANSLATE BLEND
		shadingNode -asUtility blendColors -n ($modCore + "_MidIk_CtrlLctrGrp_Inf_Trn_Blend");
		connectAttr -force ($modCore + "_SplineMid_Blnd.output") ($modCore + "_MidIk_CtrlLctrGrp_Inf_Trn_Blend.color2");
		connectAttr -force ($modCore + "_MidIk_CtrlLctrGrp_InfLctr.translate") ($modCore + "_MidIk_CtrlLctrGrp_Inf_Trn_Blend.color1");
		connectAttr -force ($modCore + "_MidIk_Ctrl.topIkInfPos") ($modCore + "_MidIk_CtrlLctrGrp_Inf_Trn_Blend.blender");
		
		connectAttr -force ($modCore + "_MidIk_CtrlLctrGrp_Inf_Trn_Blend.output") ($modCore + "_MidIk_CtrlLctr.translate");
	
		//SPLINE LENGTH
		addAttr -ln "splineLength" -at double ($modCore + "_MidIk_Ctrl");
		setAttr -e-channelBox true ($modCore + "_MidIk_Ctrl.splineLength");
		addAttr -ln "splineLength" -at double ($modCore + "_TopIk_Ctrl");
		setAttr -e-channelBox true ($modCore + "_TopIk_Ctrl.splineLength");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_Length_MD");
		setAttr ($modCore + "_Length_MD.operation") 2;
		$splineLength[0] = `getAttr ($modCore + "_LengthInfo.arcLength")`;
		setAttr ($modCore + "_Length_MD.input2X") $splineLength[0];
		connectAttr -f ($modCore + "_LengthInfo.arcLength") ($modCore + "_Length_MD.input1X");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthComp_MD");
		setAttr ($modCore + "_LengthComp_MD.operation") 2;
		connectAttr -force ($modCore + "_Length_MD.outputX") ($modCore + "_LengthComp_MD.input1X");
		connectAttr -force ($modRigName + "MAIN_Ctrl.scaleY") ($modCore + "_LengthComp_MD.input2X");
		
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_MidIk_Ctrl.splineLength");
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_TopIk_Ctrl.splineLength");
	
		shadingNode -asUtility blendColors -n ($modCore + "_Spline_Blnd");
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_Spline_Blnd.color1R");
		connectAttr -f ($modCore + "_TopIk_Ctrl.splineCurve") ($modCore + "_Spline_Blnd.color2R");
		
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineBtm_ClusterGrp.sy");
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineMid_ClusterGrp.sy");
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineTop_ClusterGrp.sy");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
	
		//VISIBILITY
		$SpineCurveLctrs = `ls ($modCore + "_??CurveLctr")`;
		for ($crntLctr in $SpineCurveLctrs)
		{
			setAttr ($crntLctr + ".v") 0;
		}
		
	
		//SPLINE MICROS
		addAttr -ln "splineMicro" -at bool ($modCore + "_TopIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_TopIk_Ctrl.splineMicro");
		
		$splineCurve_CtrlGrp = `ls ($modCore + "_??Curve_CtrlGrp")`;
		for ($crnt_CtrlGrp in $splineCurve_CtrlGrp)
		{
			connectAttr -f ($modCore + "_TopIk_Ctrl.splineMicro") ($crnt_CtrlGrp + ".v");
		}
	
		setAttr ($modCore + "_StartLctr.v") 0;
		setAttr ($modRigName + "" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.v") 0;
	
		setAttr ($modCore + "_SplineBtm_BtmClstr.v") 0;
		setAttr ($modCore + "_SplineBtm_TopClstr.v") 0;
		setAttr ($modCore + "_SplineTop_BtmClstr.v") 0;
		setAttr ($modCore + "_SplineTop_TopClstr.v") 0;
	
		setAttr ($modCore + "_LengthClstr01.v") 0;
		setAttr ($modCore + "_LengthClstr02.v") 0;
		setAttr ($modCore + "_LengthClstr03.v") 0;
	
	
		setAttr ($modCore + "_ribbon.v") 0;
		setAttr ($modCore + "_ribbonBlend.v") 0;
		setAttr ($modCore + "_ribbonBlend_rCluster.v") 0;
		setAttr ($modCore + "_ribbonBlend_lCluster.v") 0;
		setAttr ($modCore + "_BtmTX_Lctr.v") 0;
		setAttr ($modCore + "_TopTX_Lctr.v") 0;
		setAttr ($modCore + "_BtmJntIk.v") 0;
		setAttr ($modCore + "_MidJntIk.v") 0;
		setAttr ($modCore + "_TopJntIk.v") 0;
		setAttr ($modCore + "_LengthCurve.template") 1;
		
		setAttr -l 1 -k 0 ($modCore + "_BtmJntIk.v");
		setAttr -l 1 -k 0 ($modCore + "_MidJntIk.v");
		setAttr -l 1 -k 0 ($modCore + "_TopJntIk.v");
		
	
		addAttr -ln "nonControl" -dt "string" ($modCore + "_LengthCurve");
		setAttr -e -k 1 ($modCore + "_LengthCurve.nonControl");
		setAttr -l 1 ($modCore + "_LengthCurve.nonControl");
		
		$spineF = `ls ($modCore + "_??F")`;
		for ($crntF in $spineF)
		{
			setAttr ($crntF + ".v") 0;
		}
		
		setAttr ($modCore + "_MidSplineTargetLctr.v") 0;
		setAttr ($modCore + "_MidSplineAimLctr.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_TopIk_Ctrl.v");

		setAttr -l 1 -k 0 ($modCore + "_MidIk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_MidIk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_MidIk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_MidIk_Ctrl.v");
		
	
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*_Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("" + $prfx + $core);
			setAttr -e-l 1 ($crntModControl + ".modCoreName");

			addAttr -ln "moduleType" -dt "string" ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "spline";
			setAttr -l true ($crntModControl + ".moduleType");
			setAttr -l 1 -k 0 ($crntF + ".v"); 
		}
		
		//CLEAN UP
		delete ($modCore + "_OrientLctr");
		
		select -cl;
		
		//SETUP FOR RIGHT SIDE
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
	}
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Parent")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Parent")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Parent");}
	else if (`objExists ("RRM_" + $modRigName + "Parent")`)
		{select ("RRM_" + $modRigName + "Parent");}
}


//////////////////////////////////////////////////////////////////////////////
/////////////////////////////// TOON LIMB ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////

global proc RRM_ToonLimbs(string $modRigName, string $rigGrp, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode, float $behavior, float $behaviorMultiplier, string $lPrfx, string $rPrfx, int $ea)
{
	string $crntUnit = `currentUnit -query -linear`;
	$uValComp = 1.0;
	if ($crntUnit == "m")
	{
		$uValComp = 0.01;
		//$uValComp = 1;
	}

	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $Fk_CtrlGrp = "Fk_CtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFk_CtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$Fk_CtrlGrp = "Fk_CtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	else
	{
		select ("RRM_" + $prfx + $core + "_Shoulder") ("RRM_" + $prfx + $core + "_Wrist");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow1") ("RRM_" + $prfx + $core + "_Elbow1");
		}
	}
	$segments = `ls -sl`;
		
	float $middleLimbLength;

	if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")` && !`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".tx")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	else
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}			
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$middleLimbLength = `getAttr ($modCore + $elbow2 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".tx")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	
	//ADD CURVE ATTRIBUTES TO Ik Fk SWITCH
	addAttr -ln ($elbowType + "Curve") -at double -min 0 -max 1 -dv 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + $elbowType + "Curve");
	
	addAttr -ln "curve" -at double -min 0 -max 1 -dv 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl.curve");
	
	shadingNode -asUtility multiplyDivide -n ($modCore + "_Curve_MD1");
	connectAttr -force ($modCore + "_Switch_Ctrl.curve") ($modCore + "_Curve_MD1.input1X");
	setAttr ($modCore + "_Curve_MD1.input2X") 2;
	shadingNode -asUtility multiplyDivide -n ($modCore + "_Curve_MD2");
	connectAttr -force ($modCore + "_Curve_MD1.outputX") ($modCore + "_Curve_MD2.input1X");
	connectAttr -force ($modCore + $shoulder + "Fk_Ctrl.scaleX") ($modCore + "_Curve_MD2.input2X");
	
	//ADD VISIBILITY ATTRIBUTES FOR CURVE CONTROLLERS
	addAttr -ln ($limbType + "Twist") -at bool -min 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + $limbType + "Twist");

	addAttr -ln ($limbType + "CurveMacro") -at bool -min 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + $limbType + "CurveMacro");
	
	addAttr -ln ($limbType + "CurveMicro") -at bool -min 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + $limbType + "CurveMicro");

	
	//GROUP FOR NODES
	group -em -n ($modCore + "_curveNodesGrp");
	parent ($modCore + "_curveNodesGrp") ($modCore + "_ScaleGrp");
	group -em -n ($modCore + "_extraCurveNodesGrp");
	setAttr ($modCore + "_extraCurveNodesGrp.inheritsTransform") 0; 
	parent ($modCore + "_extraCurveNodesGrp") ($modCore + "Grp");
	
	
	while ($segInteger < `size $segments` || $segInteger <= 3)
	{
		//UPPER
		$seg = "_Upper";
		$segStart = $shoulder;
		$segEnd = $elbow1;
		$startPos = `xform -q -ws -rp ($modCore + $segStart + "Jnt")`;
		$endPos = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		string $segParentStartOrient = ($modCore + $clavicle + "Jnt");
		if ($limbType == "leg")
		{
			$segParentStartOrient = $modAttachNode;
		}
		string $segEndOrient = ($modCore + $elbow1 + "Jnt");
		
		string $topSegPosAttach = ($modCore + $shoulder + "Jnt");
		string $topSegRotAttach = ($modCore + $parentNode);
		string $btmSegPosAttach = ($modCore + $elbow1 + "_Curve_Ctrl");
		string $btmSegRotAttach = ($modCore + $elbow1 + "_Curve_Ctrl");
		string $ikSplineUpObject2 = ($modCore + $shoulder + "Jnt");
		string $segStartUpOrientControl = ($modCore + $seg + "_Twist_Ctrl");
		string $segEndUpOrientControl = ($modCore + $elbow1 + "_Curve_Ctrl");
		
		if ($segInteger == 2)
		{//LOWER
			$seg = "_Lower";
			$segStart = $elbow2;
			$segEnd = $wrist;
			$startPos = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
			$endPos = `xform -q -ws -rp ($modCore + $wrist + "Jnt")`;
			$segParentStartOrient = ($modCore + $elbow2 + "Jnt");
			$segEndOrient = ($modCore + $wrist + "Jnt");

			$topSegPosAttach = ($modCore + $elbow2 + "_Curve_Ctrl");
			$topSegRotAttach = ($modCore + $elbow2 + "_Curve_Ctrl");
			$btmSegPosAttach = ($modCore + $wrist + "Jnt");
			$btmSegRotAttach = ($modCore + $wrist + "Jnt");
			$ikSplineUpObject2 = ($modCore + $wrist + "JntGrp1");
			if ($limbType == "leg")
			{
				$ikSplineUpObject2 = ($modCore + $wrist + "Jnt");
			}
			$segStartUpOrientControl = ($modCore + $elbow2 + "_Curve_Ctrl");
			$segEndUpOrientControl = ($modCore + $seg + "_Twist_Ctrl");
		}
		else if ($segInteger == 3)
		{//MIDDLE
			$seg = "_Middle";
			$segStart = $elbow1;
			$segEnd = $elbow2;
			$startPos = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
			$endPos = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
			$segParentStartOrient = ($modCore + $elbow1 + "Jnt");
			$segEndOrient = ($modCore + $elbow2 + "Jnt");

			$topSegPosAttach = ($modCore + $elbow1 + "_Curve_Ctrl");
			$topSegRotAttach = ($modCore + $elbow1 + "_Curve_Ctrl");
			$btmSegPosAttach = ($modCore + $elbow2 + "_Curve_Ctrl");
			$btmSegRotAttach = ($modCore + $elbow2 + "_Curve_Ctrl");
			$ikSplineUpObject2 = ($modCore + $elbow2 + "_Curve_Ctrl");
			$segStartUpOrientControl = ($modCore + $elbow1 + "_Curve_Ctrl");
			$segEndUpOrientControl = ($modCore + $elbow2 + "_Curve_Ctrl");
		}
		
		float $segLength;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			if ($segInteger != 2)
			{
				$segLength = `getAttr ($modCore + $segEnd + "Jnt.tx")`;
			}
			else
			{
				$segLength = `getAttr ($modCore + $wristDummy + ".tx")`;
			}
		}
		else
		{
			$elbow1TX = `getAttr ($modCore + $elbow1 + "Jnt.tx")`;
			$elbow2TX = `getAttr ($modCore + $elbow2 + "Jnt.tx")`;
			$segLength = (($elbow1TX + $elbow2TX)*.667);
		}

		// SEGMENTS CHECK
		if (`objExists ("RRM_" + $prfx + $core + $seg + "1")`)
		{
			//CREATE MAIN SPLINE CURVES FOR CONTROL GROUP ATTACHMENT
			curve -n ($modCore + $seg + "CurveAttach") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1;
			rename `listRelatives -c ($modCore + $seg + "CurveAttach")` ($modCore + $seg + "CurveShape");
	
			rebuildCurve -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 ($modCore + $seg + "CurveAttach");
				
			//CREATE GUIDE SPLINE CURVES FOR MACRO CONTROL ATTACHMENT
			curve -n ($modCore + $seg + "CurveGuide") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1 ;
			pickWalk -d down;
			rename `listRelatives -c ($modCore + $seg + "CurveGuide")` ($modCore + $seg + "CurveGuideShape");
			
			rebuildCurve -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 1 ($modCore + $seg + "CurveGuide");
			delete -ch ($modCore + $seg + "CurveAttach") ($modCore + $seg + "CurveGuide");
			
			parent ($modCore + $seg + "CurveAttach") ($modCore + $seg + "CurveGuide") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "CurveAttach.template") 1;
			setAttr ($modCore + $seg + "CurveGuide.v") 0;
			
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.tx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.ty");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.tz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.rx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.ry");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.rz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.sx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.sy");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.sz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.v");
				
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.tx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.ty");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.tz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.rx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.ry");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.rz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.sx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.sy");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.sz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveGuide.v");

			addAttr -ln "nonControl" -dt "string" ($modCore + $seg + "CurveGuide");
			setAttr -e -k 1 ($modCore + $seg + "CurveGuide.nonControl");
			setAttr -l 1 ($modCore + $seg + "CurveGuide.nonControl");

			addAttr -ln "nonControl" -dt "string" ($modCore + $seg + "CurveAttach");
			setAttr -e -k 1 ($modCore + $seg + "CurveAttach.nonControl");
			setAttr -l 1 ($modCore + $seg + "CurveAttach.nonControl");

			//HIDE SHOULDER AND ELBOW JOINTS SO THEY DON'T GET CONFUSED WITH THE TOON JOINTS
			//DETERMINE VERSION NUMBER
			$versionNum = `getApplicationVersionAsFloat`;
			if ($versionNum >= 2011)
			{
				setAttr ($modCore + $segStart + "Jnt.drawStyle") 2;
				if ($segInteger != 2)
				{
					setAttr ($modCore + $segEnd + "Jnt.drawStyle") 2;
				}
			}
			else
			{
				setAttr ($modCore + $segStart + "Jnt.visibility") 0;
				if ($segInteger != 2)
				{
					setAttr ($modCore + $segEnd + "Jnt.visibility") 0;
				}				
			}
			curve -n ($modCore + $seg + "_Curve_Ctrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
			setAttr ($modCore + $seg + "_Curve_Ctrl.rotateOrder") 1;
			rename `listRelatives -c ($modCore + $seg + "_Curve_Ctrl")` ($modCore + $seg + "_Curve_CtrlShape");
			
			setAttr (($modCore + $seg + "_Curve_Ctrl.scale"), ($limbLength*.75), ($limbLength*.75), ($limbLength*.75));
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $seg + "_Curve_Ctrl");
			connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "CurveMacro") ($modCore + $seg + "_Curve_Ctrl.v");
			
			group -n ($modCore + $seg + "_Curve_CtrlGrp") ($modCore + $seg + "_Curve_Ctrl");
			setAttr ($modCore + $seg + "_Curve_CtrlGrp.rotateOrder") 1;
			pathAnimation -n ($modCore + $seg + "Guide_MP") -fractionMode true -followAxis x -upAxis y -worldUpType "objectrotation"
			-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $segStart + "Jnt") ($modCore + $seg + "_Curve_CtrlGrp") ($modCore + $seg + "CurveGuide");
			cutKey -cl -t ":" -f ":" -at "u" ($modCore + $seg + "Guide_MP");
			setAttr ($modCore + $seg + "Guide_MP.uValue") (.5 * $uValComp);

			connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + $seg + "_Curve_CtrlGrp.scale");
			parent ($modCore + $seg + "_Curve_CtrlGrp") ($modCore + "_extraCurveNodesGrp");
			
			setAttr -l 1 -k 0 ($modCore + $seg + "_Curve_Ctrl.rx");
			setAttr -l 1 -k 0 ($modCore + $seg + "_Curve_Ctrl.ry");
			setAttr -l 1 -k 0 ($modCore + $seg + "_Curve_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + $seg + "_Curve_Ctrl.v");

			//select "break";
			if (($segInteger == 1) || ($segInteger == 3 && !`objExists ($modCore + $segEnd + "_Curve_Ctrl")`))
			{//ELBOW1 CONTROL
				curve -n ($modCore + $segEnd + "_Curve_Ctrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segEnd + "_Curve_Ctrl.rotateOrder") 1;
				rename `listRelatives -c ($modCore + $segEnd + "_Curve_Ctrl")` ($modCore + $segEnd + "_Curve_CtrlShape");
				setAttr (($modCore + $segEnd + "_Curve_Ctrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segEnd + "_Curve_Ctrl");
	
				group -n ($modCore + $segEnd + "_Curve_CtrlGrp") ($modCore + $segEnd + "_Curve_Ctrl");
				parent ($modCore + $segEnd + "_Curve_CtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_Curve_CtrlGrp");
				delete `orientConstraint ($modCore + $segStart + "Jnt") ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_Curve_CtrlGrp")`;
				orientConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_Curve_CtrlGrp");
				setAttr ($modCore + $segEnd + "_Curve_CtrlGrp_orientConstraint1.interpType") 2;
				
				connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + $segEnd + "_Curve_CtrlGrp.scale");
				parent ($modCore + $segEnd + "_Curve_CtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				connectAttr -f ($modCore + "_Switch_Ctrl." + $elbowType + "Curve") ($modCore + $segEnd + "_Curve_CtrlGrp_orientConstraint1." + $modCore + $segStart + "JntW0");

				connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "CurveMacro") ($modCore + $segEnd + "_Curve_Ctrl.v");				
				setAttr -l 1 -k 0 ($modCore + $segEnd + "_Curve_Ctrl.v");
			}//ELBOW1 CONTROL
			
			if (($segInteger == 2 && !`objExists ($modCore + $segStart + "_Curve_Ctrl")`) || ($segInteger == 3 && !`objExists ($modCore + $segStart + "_Curve_Ctrl")`))
			{//ELBOW1 CONTROL IF NOT CREATED IN SEG 1 DUE TO NO TWIST JOINTS
				curve -n ($modCore + $segStart + "_Curve_Ctrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segStart + "_Curve_Ctrl.rotateOrder") 1;
				rename `listRelatives -c ($modCore + $segStart + "_Curve_Ctrl")` ($modCore + $segStart + "_Curve_CtrlShape");
				setAttr (($modCore + $segStart + "_Curve_Ctrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segStart + "_Curve_Ctrl");
	
				group -n ($modCore + $segStart + "_Curve_CtrlGrp") ($modCore + $segStart + "_Curve_Ctrl");
				parent ($modCore + $segStart + "_Curve_CtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_Curve_CtrlGrp");
				$topJnt = `listRelatives -p -type "joint" ($modCore + $segStart + "Jnt")`;
				delete `orientConstraint  $topJnt[0] ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_Curve_CtrlGrp")`;
				orientConstraint -mo  $topJnt ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_Curve_CtrlGrp");
				setAttr ($modCore + $segStart + "_Curve_CtrlGrp_orientConstraint1.interpType") 2;
				
				connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + $segStart + "_Curve_CtrlGrp.scale");
				parent ($modCore + $segStart + "_Curve_CtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				connectAttr -f ($modCore + "_Switch_Ctrl." + $elbowType + "Curve") ($modCore + $segStart + "_Curve_CtrlGrp_orientConstraint1." + $topJnt[0] + "W0");

				connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "CurveMacro") ($modCore + $segStart + "_Curve_Ctrl.v");				
				setAttr -l 1 -k 0 ($modCore + $segStart + "_Curve_Ctrl.v");
			}//ELBOW1 CONTROL IF NOT CREATED IN SEG 1 DUE TO NO TWIST JOINTS			
			
			if (($segInteger == 2 && $elbow2 == "_Elbow2") || ($segInteger != 1 && !`objExists ($modCore + $segStart + "_Curve_Ctrl")`))
			{//ELBOW2 CONTROL
				curve -n ($modCore + $segStart + "_Curve_Ctrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segStart + "_Curve_Ctrl.rotateOrder") 1;
				rename `listRelatives -c ($modCore + $segStart + "_Curve_Ctrl")` ($modCore + $segStart + "_Curve_CtrlShape");
				setAttr (($modCore + $segStart + "_Curve_Ctrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segStart + "_Curve_Ctrl");
	
				group -n ($modCore + $segStart + "_Curve_CtrlGrp") ($modCore + $segStart + "_Curve_Ctrl");
				parent ($modCore + $segStart + "_Curve_CtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_Curve_CtrlGrp");
				delete `orientConstraint ($modCore + $elbow1 + "Jnt") ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_Curve_CtrlGrp")`;
				orientConstraint -mo ($modCore + $elbow1 + "Jnt") ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_Curve_CtrlGrp");
				setAttr ($modCore + $segStart + "_Curve_CtrlGrp_orientConstraint1.interpType") 2;
				//print "elbow2\n";
				//print ($modCore + $elbow1 + "Jnt\n") ;
				//print  ($modCore + $segStart + "Jnt\n");
				
				connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + $segStart + "_Curve_CtrlGrp.scale");
				parent ($modCore + $segStart + "_Curve_CtrlGrp") ($modCore + "_extraCurveNodesGrp");

				connectAttr -f ($modCore + "_Switch_Ctrl." + $elbowType + "Curve") ($modCore + $segStart + "_Curve_CtrlGrp_orientConstraint1." + $modCore + $elbow1 + "JntW0");
				connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "CurveMacro") ($modCore + $segStart + "_Curve_Ctrl.v");				
				setAttr -l 1 -k 0 ($modCore + $segStart + "_Curve_Ctrl.v");
			}//ELBOW2 CONTROL
				
			//CURVE CLUSTERS
			select ($modCore + $seg + "CurveAttach.cv[0:1]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopClstr");
			group -em -n ($modCore + $seg + "TopClstrGrp");
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + "TopClstrGrp")`;
			parent ($modCore + $seg + "TopClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "TopClstrGrp");
			parent -w ($modCore + $seg + "TopClstrGrp");
			parent ($modCore + $seg + "TopClstr") ($modCore + $seg + "TopClstrGrp");
	
			pointConstraint -mo $topSegPosAttach ($modCore + $seg + "TopClstrGrp");
			orientConstraint -mo $topSegRotAttach ($modCore + $seg + "TopClstrGrp");
			
			select ($modCore + $seg + "CurveAttach.cv[3:4]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmClstr");
			group -em -n ($modCore + $seg + "BtmClstrGrp");
			delete `pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmClstrGrp")`;
			parent ($modCore + $seg + "BtmClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "BtmClstrGrp");
			parent -w ($modCore + $seg + "BtmClstrGrp");
			parent ($modCore + $seg + "BtmClstr") ($modCore + $seg + "BtmClstrGrp");
				
			delete `orientConstraint $segEndOrient ($modCore + $seg + "BtmClstrGrp")`;

			pointConstraint -mo $btmSegPosAttach ($modCore + $seg + "BtmClstrGrp");
			orientConstraint -mo $btmSegRotAttach ($modCore + $seg + "BtmClstrGrp");
			
			select ($modCore + $seg + "CurveAttach.cv[2]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "MidClstr");
			
			//parentConstraint ($modCore + $seg + "_Curve_Ctrl") ($modCore + $seg + "MidClstr");
			//parent ($modCore + $seg + "MidClstr") ($modCore + "_extraCurveNodesGrp");
			parent ($modCore + $seg + "MidClstr") ($modCore + $seg + "_Curve_Ctrl");
			setAttr ($modCore + $seg + "MidClstr.v") 0;
	
			//GUIDE CURVE CLUSTERS
			select ($modCore + $seg + "CurveGuide.cv[0:1]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopGuideClstr");
			group -em -n ($modCore + $seg + "TopGuideClstrGrp");
			delete `pointConstraint ($modCore + $segStart + "Fk_Ctrl") ($modCore + $seg + "TopGuideClstrGrp")`;
			parent ($modCore + $seg + "TopGuideClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "TopGuideClstrGrp");
			parent -w ($modCore + $seg + "TopGuideClstrGrp");
			parent ($modCore + $seg + "TopGuideClstr") ($modCore + $seg + "TopGuideClstrGrp"); 
			
			pointConstraint -mo $topSegPosAttach ($modCore + $seg + "TopGuideClstrGrp");
			orientConstraint -mo $topSegRotAttach ($modCore + $seg + "TopGuideClstrGrp");
	
			select ($modCore + $seg + "CurveGuide.cv[2:3]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmGuideClstr");
			group -em -n ($modCore + $seg + "BtmGuideClstrGrp");
			delete `pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmGuideClstrGrp")`;
			parent ($modCore + $seg + "BtmGuideClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "BtmGuideClstrGrp");
			parent -w ($modCore + $seg + "BtmGuideClstrGrp");
			parent ($modCore + $seg + "BtmGuideClstr") ($modCore + $seg + "BtmGuideClstrGrp");

			//if ($crntSide == "right" && $limbType == "arm")
			//{
			//	select "break";
			//}	
			delete `orientConstraint $segEndOrient ($modCore + $seg + "BtmGuideClstrGrp")`;
			
			pointConstraint -mo $btmSegPosAttach ($modCore + $seg + "BtmGuideClstrGrp");
			orientConstraint -mo $btmSegRotAttach ($modCore + $seg + "BtmGuideClstrGrp");
	
			//CONNECT SCALE TO OF THE CLUSTER GROUPS TO CURVE ATTRIBUTE TO MAKE THE ARM CURVES STRAIGHT	
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "TopClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "BtmClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "TopGuideClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "BtmGuideClstrGrp.scaleX");
			
			//PARENT CLUSTERS
			parent ($modCore + $seg + "TopClstrGrp") ($modCore + $seg + "BtmClstrGrp")
			($modCore + $seg + "TopGuideClstrGrp") ($modCore + $seg + "BtmGuideClstrGrp")
			($modCore + "_curveNodesGrp");
			
			//HIDE CLUSTERS
			setAttr ($modCore + $seg + "TopClstrGrp.v") 0;
			setAttr ($modCore + $seg + "BtmClstrGrp.v") 0;
			setAttr ($modCore + $seg + "TopGuideClstrGrp.v") 0;
			setAttr ($modCore + $seg + "BtmGuideClstrGrp.v") 0;
			
			//CREATE NON-FLIP JOINT CHAIN
			select -cl;
			joint -n ($modCore + $seg + $segStart + "_NoFlipJnt");
			joint -n ($modCore + $seg + $segEnd + "_NoFlipJnt") -p $segLength 0 0;
			setAttr ($modCore + $seg + $segStart + "_NoFlipJnt.v") 0;
			setAttr ($modCore + $seg + $segEnd + "_NoFlipJnt.v") 0;
			group -n ($modCore + $seg + $segStart + "_NoFlipJntGrp") ($modCore + $seg + $segStart + "_NoFlipJnt"); 
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoFlipJntGrp")`;
			delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoFlipJnt")`;
			makeIdentity -apply true -r 1 ($modCore + $seg + $segStart + "_NoFlipJnt");
			parentConstraint -mo $segParentStartOrient ($modCore + $seg + $segStart + "_NoFlipJntGrp");
			pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoFlipJnt");
			select -cl;
			
			setAttr (($modCore + $seg + $segEnd + "_NoFlipJnt.rotate"), 0, 0, 0);
			setAttr (($modCore + $seg + $segEnd + "_NoFlipJnt.jointOrient"), 0, 0, 0);
			$segNoFlipLength = `getAttr ($modCore + $seg + $segEnd + "_NoFlipJnt.translateX")`;
			
			//CREATE Ik RP HANDLE
			select ($modCore + $seg + $segStart + "_NoFlipJnt.rotatePivot") ($modCore + $seg + $segEnd + "_NoFlipJnt.rotatePivot") ;
			ikHandle -n ($modCore + $seg + $segStart + "_NoFlipIkHandle") -sol ikRPsolver;
			setAttr (($modCore + $seg + $segStart + "_NoFlipIkHandle.poleVector"), 0, 0, 0);
			parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segStart + "_NoFlipIkHandle");
			
			parent ($modCore + $seg + $segStart + "_NoFlipJntGrp") ($modCore + $seg + $segStart + "_NoFlipIkHandle") ($modCore + "_curveNodesGrp");
			setAttr ($modCore + $seg + $segStart + "_NoFlipIkHandle.v") 0;

			//CREATE TWIST JOINT CHAIN
			select -cl;
			joint -n ($modCore + $seg + $segStart + "_TwistStartJnt");
			setAttr ($modCore + $seg + $segStart + "_TwistStartJnt.v") 0;
			delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistStartJnt")`;
			if ($prfx == $rPrfx && $limbType == "arm")
			{
				rotate -r -os 0 180 0 ($modCore + $seg + $segStart + "_TwistStartJnt");
			}
			//if ($prfx == $rPrfx && $limbType == "arm")
			else if ($prfx == $rPrfx && $behavior == 0 && $limbType == "leg")
			{
				rotate -r -os 0 180 0 ($modCore + $seg + $segStart + "_TwistStartJnt");
			}
			pointConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistStartJnt");
			select -cl;
			
			joint -n ($modCore + $seg + $segStart + "_TwistEndJnt") -p $endPos[0] $endPos[1] $endPos[2];
			setAttr ($modCore + $seg + $segStart + "_TwistEndJnt.v") 0;
			parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistStartJnt");
			setAttr (($modCore + $seg + $segStart + "_TwistEndJnt.jointOrient"), 0, 0, 0);
			$segNoFlipLength = `getAttr ($modCore + $seg + $segStart + "_TwistEndJnt.translateX")`;
			
			group -em -n ($modCore + $seg + $segStart + "_TwistJointsGrp");
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistJointsGrp")`;
			makeIdentity -apply true -t 1 ($modCore + $seg + $segStart + "_TwistJointsGrp");
			parentConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistJointsGrp");
			parent ($modCore + $seg + $segStart + "_TwistStartJnt") ($modCore + $seg + $segStart + "_TwistJointsGrp");
			
			parent ($modCore + $seg + $segStart + "_TwistJointsGrp") ($modCore + "_curveNodesGrp");
			
			
			//CREATE NON-FLIP SETUP FOR WRIST/ANKLE TWIST CTRL
			if ($segInteger == 2)
			{
				//ROLL JOINT CHAIN
				select -cl;
				joint -n ($modCore + $segEnd + "_TwistBtmStartJnt");
				setAttr ($modCore + $segEnd + "_TwistBtmStartJnt.v") 0;
				group -n ($modCore + $segEnd + "_TwistBtmStartJntGrp"); 
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_TwistBtmStartJntGrp")`;

				parent ($modCore + $segEnd + "_TwistBtmStartJntGrp") ($modCore + $segEnd + "Jnt");
				
				select -cl;
				joint -n ($modCore + $segEnd + "_TwistBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_TwistBtmEndJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_TwistBtmEndJnt")`;
				setAttr (($modCore + $segEnd + "_TwistBtmEndJnt.translate"), 2, 0, 0);
				parent ($modCore + $segEnd + "_TwistBtmEndJnt") ($modCore + $segEnd + "_TwistBtmStartJnt");
				setAttr (($modCore + $segEnd + "_TwistBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_TwistBtmEndJnt.translate"), 2, 0, 0);				
				
				
				//NO ROLL SINGLE CHAIN RP
				select -cl;
				joint -n ($modCore + $segEnd + "_NoFlipBtmStartJnt");
				setAttr ($modCore + $segEnd + "_NoFlipBtmStartJnt.v") 0;
				group -n ($modCore + $segEnd + "_NoFlipBtmStartJntGrp"); 
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoFlipBtmStartJntGrp")`;
				
				select -cl;
				joint -n ($modCore + $segEnd + "_NoFlipBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_NoFlipBtmEndJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoFlipBtmEndJnt")`;
				setAttr (($modCore + $segEnd + "_NoFlipBtmEndJnt.translate"), 2, 0, 0);
				parent ($modCore + $segEnd + "_NoFlipBtmEndJnt") ($modCore + $segEnd + "_NoFlipBtmStartJnt");
				setAttr (($modCore + $segEnd + "_NoFlipBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_NoFlipBtmEndJnt.translate"), 2, 0, 0);
				
				//CREATE Ik RP HANDLE
				select ($modCore + $segEnd + "_NoFlipBtmStartJnt.rotatePivot") ($modCore + $segEnd + "_NoFlipBtmEndJnt.rotatePivot") ;
				ikHandle -n ($modCore + $segEnd + "_NoFlipBtmIkHandle") -sol ikRPsolver;
				setAttr (($modCore + $segEnd + "_NoFlipBtmIkHandle.poleVector"), 0, 0, 0);
				parent ($modCore + $segEnd + "_NoFlipBtmIkHandle") ($modCore + $segEnd + "_TwistBtmEndJnt");
				//parentConstraint -mo ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoFlipBtmIkHandle");
				
				//parent ($modCore + $segEnd + "_NoFlipBtmStartJntGrp") /*($modCore + $seg + $segStart + "_NoFlipIkHandle")*/ ($modCore + $seg + "_Twist_CtrlGrp");
				parent ($modCore + $seg + $segStart + "_NoFlipIkHandle") ($modCore + $segEnd + "_TwistBtmStartJntGrp");
				
				//SPLINE JOINT CHAIN
				select -cl;
				joint -n ($modCore + $segEnd + "_SplineIkBtmStartJnt");
				group -n ($modCore + $segEnd + "_SplineIkBtmStartJntGrp");
				parent ($modCore + $segEnd + "_SplineIkBtmStartJntGrp") ($modCore + "_ScaleGrp");
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIkBtmStartJntGrp")`;

				parentConstraint -mo ($modCore + $segEnd + "JntDummy") ($modCore + $segEnd + "_SplineIkBtmStartJntGrp");

				select -cl;
				
				joint -n ($modCore + $segEnd + "_SplineIkBtmTwistValJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_SplineIkBtmTwistValJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIkBtmTwistValJnt")`;
				parent ($modCore + $segEnd + "_SplineIkBtmTwistValJnt") ($modCore + $segEnd + "_SplineIkBtmStartJnt");
				setAttr (($modCore + $segEnd + "_SplineIkBtmTwistValJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIkBtmTwistValJnt.rotate"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIkBtmTwistValJnt.translate"), 1, 0, 0);
				
				select -cl;
				joint -n ($modCore + $segEnd + "_SplineIkBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_SplineIkBtmEndJnt.v") 0; //-p $endPos[0] $endPos[1] $endPos[2];
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIkBtmEndJnt")`;
				parent ($modCore + $segEnd + "_SplineIkBtmEndJnt") ($modCore + $segEnd + "_SplineIkBtmTwistValJnt");
				setAttr (($modCore + $segEnd + "_SplineIkBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIkBtmEndJnt.translate"), 1, 0, 0);
				
				//CREATE SPLINE Ik HANDLE
				select ($modCore + $segEnd + "_SplineIkBtmStartJnt.rotatePivot") ($modCore + $segEnd + "_SplineIkBtmEndJnt.rotatePivot");
				ikHandle -n ($modCore + $segEnd + "_SplineIkBtmIkHandle") -sol ikSplineSolver;
				$splineIkCurve = `listConnections -s 1 -d 0 -type "nurbsCurve" ($modCore + $segEnd + "_SplineIkBtmIkHandle")`;
				rename $splineIkCurve ($modCore + $segEnd + "_SplineIkBtmIkCurve");
					
				setAttr ($modCore + $segEnd + "_SplineIkBtmIkHandle.dTwistControlEnable") 1;
				setAttr ($modCore + $segEnd + "_SplineIkBtmIkHandle.dWorldUpType") 4;
				setAttr ($modCore + $segEnd + "_SplineIkBtmIkHandle.dWorldUpAxis") 3;
				setAttr (($modCore + $segEnd + "_SplineIkBtmIkHandle.dWorldUpVector"), 0, 0, 1);
				setAttr (($modCore + $segEnd + "_SplineIkBtmIkHandle.dWorldUpVectorEnd"), 0, 0, 1);
				
				//FIRST ROTATION LOCATOR
				spaceLocator -n ($modCore + $segEnd + "_SplineIkUpLctr1");
				parent ($modCore + $segEnd + "_SplineIkUpLctr1") ($modCore + "_ScaleGrp");
				setAttr ($modCore + $segEnd + "_SplineIkUpLctr1.inheritsTransform") 0;
				parentConstraint ($modCore + $segEnd + "_NoFlipBtmStartJnt") ($modCore + $segEnd + "_SplineIkUpLctr1");
				setAttr ($modCore + $segEnd + "_SplineIkUpLctr1_parentConstraint1.interpType") 2;

				//SECOND ROTATION LOCATOR
				spaceLocator -n ($modCore + $segEnd + "_SplineIkUpLctr2");
				parent ($modCore + $segEnd + "_SplineIkUpLctr2") ($modCore + "_ScaleGrp");
				setAttr ($modCore + $segEnd + "_SplineIkUpLctr2.inheritsTransform") 0;
				parentConstraint ($modCore + $segEnd + "_TwistBtmStartJnt") ($modCore + $segEnd + "_SplineIkUpLctr2");
				setAttr ($modCore + $segEnd + "_SplineIkUpLctr2_parentConstraint1.interpType") 2;

				connectAttr -f ($modCore + $segEnd + "_SplineIkUpLctr1.xformMatrix") ($modCore + $segEnd + "_SplineIkBtmIkHandle.dWorldUpMatrix");
				connectAttr -f ($modCore + $segEnd + "_SplineIkUpLctr2.xformMatrix") ($modCore + $segEnd + "_SplineIkBtmIkHandle.dWorldUpMatrixEnd");

				parent ($modCore + $segEnd + "_SplineIkBtmIkHandle") ($modCore + $segEnd + "_NoFlipBtmStartJntGrp");
				parent ($modCore + $segEnd + "_SplineIkBtmIkCurve") ($modCore + $segEnd + "_TwistBtmStartJntGrp");

				//HIDE AND LOCK ATTRIBUTES
				setAttr ($modCore + $segEnd + "_NoFlipBtmStartJnt.v") 0;
				setAttr ($modCore + $segEnd + "_TwistBtmStartJnt.v") 0;
				setAttr ($modCore + $segEnd + "_NoFlipBtmIkHandle.v") 0;
				setAttr ($modCore + $segEnd + "_SplineIkBtmStartJnt.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIkUpLctr1.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIkUpLctr2.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIkBtmIkHandle.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIkBtmIkCurve.visibility") 0;
			}
	
	
			//////////////////////////////////////////////////////////////////////////////
			////////////////////////////CREATE ARM ROLL JOINTS////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
		
			$rollProxies = `ls ("RRM_" + $prfx + $core + $seg + "?")`;
			$sizeTwistProxies = `size $rollProxies`;
			int $rpNum = 1;
			for ($eachRP in $rollProxies)
			{//CREATE TWIST JOINTS
				$rpNumRev = (($sizeTwistProxies + 1) - $rpNum);
				
				//EXTRA TWIST JOINTS
				float $rpNumFloat = $rpNum;
				float $sizeTwistProxiesFloat = $sizeTwistProxies;
				
				duplicate -n ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum) ($modCore + $seg + $segStart + "_TwistEndJnt");
				float $noFlipSpacing = ($segNoFlipLength /($sizeTwistProxiesFloat + 1));
				setAttr ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum + ".tx") $noFlipSpacing;
				parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum);
				
				if ($rpNum == $sizeTwistProxies)
				{
					//ADD TWIST
					//CREATE TWIST CONTROLS
					if ($segInteger == 1)
					{
						circle -n ($modCore + $seg + "_Twist_Ctrl") -nr 0 1 0 -sw 45 -r 0.8 -ch 0;
						rotate -r 0 -22.5 0 ($modCore + $seg + "_Twist_Ctrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_Twist_Ctrl");
						curve -n ($modCore + $seg + $segStart + "_Wedge_Ctrl") -d 1 -p -0.306147 0 -0.739104 -p 0 0 -0.432436 -p 0.306147 0 -0.739104 -k 0 -k 1 -k 2 ;
						rename `listRelatives -c ($modCore + $seg + $segStart + "_Wedge_Ctrl")` ($modCore + $seg + $segStart + "_Wedge_CtrlShape");
						curve -n ($modCore + $seg + $segStart + "_line_Ctrl") -d 1 -p 0 0 -0.432436 -p 0 0 0 -k 0 -k 1 ;
						rename `listRelatives -c ($modCore + $seg + $segStart + "_line_Ctrl")` ($modCore + $seg + $segStart + "_line_CtrlShape");
						parent -r -s ($modCore + $seg + $segStart + "_Wedge_CtrlShape") ($modCore + $seg + $segStart + "_line_CtrlShape") ($modCore + $seg + "_Twist_Ctrl");
						delete ($modCore + $seg + $segStart + "_Wedge_Ctrl") ($modCore + $seg + $segStart + "_line_Ctrl");
						setAttr (($modCore + $seg + "_Twist_Ctrl.rotate"), 0, -90, (90*$multiplier));
						setAttr (($modCore + $seg + "_Twist_Ctrl.scale"), ($limbLength/2), ($limbLength/2), ($limbLength/2));
						makeIdentity -apply true -r 1 -s 1 ($modCore + $seg + "_Twist_Ctrl");
						connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "Twist") ($modCore + $seg + "_Twist_Ctrl.v");				
						spaceLocator -n ($modCore + $seg + $segEnd + "_TwistLctr");
						group -n ($modCore + $seg + "_Twist_CtrlGrp") ($modCore + $seg + "_Twist_Ctrl"); xform -os -piv 0 0 0;
						setAttr ($modCore + $seg + "_Twist_CtrlGrp.rotateOrder") 1;
						group -n ($modCore + $seg + $segStart + "_TwistGrp") ($modCore + $seg + "_Twist_CtrlGrp") ($modCore + $seg + $segEnd + "_TwistLctr"); xform -os -piv 0 0 0;
						
						parent ($modCore + $seg + $segStart + "_TwistGrp") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $seg + $segEnd + "_TwistLctr.v") 0;
						
						delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistGrp")`;
						orientConstraint -mo ($modCore + $shoulder + $Fk_CtrlGrp) ($modCore + $seg + $segStart + "_TwistGrp");
						pointConstraint -mo ($modCore + $shoulder + "Fk_Ctrl") ($modCore + $seg + $segStart + "_TwistGrp");
						orientConstraint -mo ($modCore + $seg + $segStart + "_NoFlipJnt") ($modCore + $seg + "_Twist_CtrlGrp");
						parentConstraint $ikSplineUpObject2 ($modCore + $seg + $segEnd + "_TwistLctr");
					}
					else if ($segInteger == 2)
					{
						circle -n ($modCore + $seg + "_Twist_Ctrl") -nr 0 1 0 -sw 45 -r 0.8 -ch 0;
						rotate -r 0 -22.5 0 ($modCore + $seg + "_Twist_Ctrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_Twist_Ctrl");
						curve -n ($modCore + $seg + $segEnd + "_Wedge_Ctrl") -d 1 -p -0.306147 0 -0.739104 -p 0 0 -0.432436 -p 0.306147 0 -0.739104 -k 0 -k 1 -k 2 ;
						rename `listRelatives -c ($modCore + $seg + $segEnd + "_Wedge_Ctrl")` ($modCore + $seg + $segEnd + "_Wedge_CtrlShape");
						curve -n ($modCore + $seg + $segEnd + "_line_Ctrl") -d 1 -p 0 0 -0.432436 -p 0 0 0 -k 0 -k 1 ;
						rename `listRelatives -c ($modCore + $seg + $segEnd + "_line_Ctrl")` ($modCore + $seg + $segEnd + "_line_CtrlShape");
						parent -r -s ($modCore + $seg + $segEnd + "_Wedge_CtrlShape") ($modCore + $seg + $segEnd + "_line_CtrlShape") ($modCore + $seg + "_Twist_Ctrl");
						delete ($modCore + $seg + $segEnd + "_Wedge_Ctrl") ($modCore + $seg + $segEnd + "_line_Ctrl");
						setAttr (($modCore + $seg + "_Twist_Ctrl.rotate"), 0, -90, (90*$multiplier));
						setAttr (($modCore + $seg + "_Twist_Ctrl.scale"), ($limbLength/2.5), ($limbLength/2.5), ($limbLength/2.5));
						makeIdentity -apply true -r 1 -s 1 ($modCore + $seg + "_Twist_Ctrl");
						connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "Twist") ($modCore + $seg + "_Twist_Ctrl.v");				
						spaceLocator -n ($modCore + $seg + $segEnd + "_TwistLctr");
						group -n ($modCore + $seg + "_Twist_CtrlGrp") ($modCore + $seg + "_Twist_Ctrl"); xform -os -piv 0 0 0;
						setAttr ($modCore + $seg + "_Twist_CtrlGrp.rotateOrder") 1;
						group -n ($modCore + $seg + $segEnd + "_TwistGrp") ($modCore + $seg + "_Twist_CtrlGrp") ($modCore + $seg + $segEnd + "_TwistLctr"); xform -os -piv 0 0 0;
						
						parent ($modCore + $seg + $segEnd + "_TwistGrp") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $seg + $segEnd + "_TwistLctr.v") 0;
						
						delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp")`;
						pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp");
						parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + $segStart + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp");
						connectAttr -f ($modCore + $segEnd + "_SplineIkBtmTwistValJnt.rotateX") ($modCore + $seg + "_Twist_CtrlGrp.rotateX");
						parentConstraint $ikSplineUpObject2 ($modCore + $seg + $segEnd + "_TwistLctr");
					}
					
					if (`objExists ($modCore + $segEnd + "_NoFlipBtmStartJntGrp")`)
					{
						parent ($modCore + $segEnd + "_NoFlipBtmStartJntGrp") ($modCore + $segEnd + "_SplineIkBtmStartJntGrp") ($modCore + $seg + $segEnd + "_TwistGrp");
					}
					
					if ($limbType == "leg" && $crntSide == "right" && `objExists ($modCore + $seg + "_Twist_Ctrl")`)
					{
						rotate -r -os 180 0 0 ($modCore + $seg + "_Twist_Ctrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_Twist_Ctrl");
					}
					if ($crntSide == "right" && $behavior == 0 && `objExists ($modCore + $seg + "_Twist_Ctrl")`)
					{
						rotate -r -os 180 0 0 ($modCore + $seg + "_Twist_Ctrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_Twist_Ctrl");
					}
					if (`objExists ($modCore + $seg + "_Twist_Ctrl")`)
					{
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.tx");
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.ty");
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.tz");
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.sx");
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.sy");
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.sz");
						setAttr -l 1 -k 0 ($modCore + $seg + "_Twist_Ctrl.v");
					}
					
					spaceLocator -n ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr");
					spaceLocator -n ($modCore + $seg + $segStart + "_TwistSplineIk_Up2Lctr");
					parentConstraint $segStartUpOrientControl ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr");
					parentConstraint $segEndUpOrientControl ($modCore + $seg + $segStart + "_TwistSplineIk_Up2Lctr");
					
					parent ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr") ($modCore + $seg + $segStart + "_TwistSplineIk_Up2Lctr") ($modCore + "Grp");
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr.v") 0;
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIk_Up2Lctr.v") 0;
					
					
					//SPLINE SETUP/////
					//CREATE ONE EXTRA JOINT TO BETTER DISTRIBUTE THE ROLL
					duplicate -n ($modCore + $seg + $segStart + "_TwistJointExtraJnt") ($modCore + $seg + $segStart + "_TwistEndJnt");
					setAttr ($modCore + $seg + $segStart + "_TwistJointExtraJnt.v") 0;
					float $noFlipSpacing = ($segNoFlipLength /(($sizeTwistProxiesFloat + 1)*2));
					setAttr ($modCore + $seg + $segStart + "_TwistJointExtraJnt" + ".tx") $noFlipSpacing;
					parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistJointExtraJnt");
					
					//SPLINE Ik
					select ($modCore + $seg + $segStart + "_TwistStartJnt.rotatePivot") ($modCore + $seg + $segStart + "_TwistEndJnt.rotatePivot") ;
					//if ($crntSide == "right")
					//{
					//	select "break";
					//}
					ikHandle -n ($modCore + $seg + $segStart + "_TwistSplineIkHandle") -sol ikSplineSolver;
					$splineIkCurve = `listConnections -s 1 -d 0 -type "nurbsCurve" ($modCore + $seg + $segStart + "_TwistSplineIkHandle")`;
					rename $splineIkCurve ($modCore + $seg + $segStart + "_TwistSplineIkCurve");
					parentConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistSplineIkCurve");
					
					parent ($modCore + $seg + $segStart + "_TwistSplineIkHandle") ($modCore + "_curveNodesGrp");
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIkHandle.v") 0;
	
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIkHandle.dTwistControlEnable") 1;
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIkHandle.dWorldUpType") 4;
	
					//if ($crntSide == "right")
					//{
					//	select "break";
					//}
					connectAttr -f ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr.xformMatrix") ($modCore + $seg + $segStart + "_TwistSplineIkHandle.dWorldUpMatrix");
					connectAttr -f ($modCore + $seg + $segStart + "_TwistSplineIk_Up2Lctr.xformMatrix") ($modCore + $seg + $segStart + "_TwistSplineIkHandle.dWorldUpMatrixEnd");

					addAttr -ln "nonControl" -dt "string" ($modCore + $seg + $segStart + "_TwistSplineIkCurve");
					setAttr -e -k 1 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.nonControl");
					setAttr -l 1 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.nonControl");

					setAttr ($modCore + $seg + $segStart + "_TwistSplineIkCurve.v") 0;
					
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.tx");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.ty");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.tz");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.rx");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.ry");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.rz");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.sx");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.sy");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.sz");
					setAttr -l 1 -k 0 ($modCore + $seg + $segStart + "_TwistSplineIkCurve.v");

					//if ($crntSide == "right")
					//{
					//	select "break";
					//}	
				}
		
				////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////
				//INDIVIDUAL ARM JOINTS AND CONTROLS
				////////////////////////////////////////////////////////////////////////////////////////////////
				circle -n ($modCore + $seg + "_Curve" + $rpNum + "_CtrlB") -c 0 0 2.5 -nr 1 0 0 -r 0.5 -ch 0;
				circle -n ($modCore + $seg + "_Curve" + $rpNum + "_CtrlC") -c 0 0 -2.5 -nr 1 0 0 -r 0.5 -ch 0;
				curve -n ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl") -d 1 -p 0 0 -2 -p 0 0 2 -k 0 -k 1 ;
				rename `listRelatives -c ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl")` ($modCore + $seg + "_Curve" + $rpNum + "_CtrlShape");
	
				parent -r -s ($modCore + $seg + "_Curve" + $rpNum + "_CtrlBShape") ($modCore + $seg + "_Curve" + $rpNum + "_CtrlCShape") ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl");
				delete ($modCore + $seg + "_Curve" + $rpNum + "_CtrlB") ($modCore + $seg + "_Curve" + $rpNum + "_CtrlC");
				
				setAttr ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl.rotateOrder") 1;
				connectAttr -f ($modCore + "_Switch_Ctrl." + $limbType + "CurveMicro") ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl.v");
				setAttr -l 1 -k 0 ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl.v");
				
	
				scale -r ($segLength/6) ($segLength/6) ($segLength/6) ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl");
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl");
					
				group -n ($modCore + $seg + "_Curve" + $rpNum + "_CtrlGrp") ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl");
				setAttr ($modCore + $seg + "_Curve" + $rpNum + "_CtrlGrp.rotateOrder") 1;
				
				connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + $seg + "_Curve" + $rpNum + "_CtrlGrp.scale");
				parent ($modCore + $seg + "_Curve" + $rpNum + "_CtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				select -cl;
				joint -n ($modCore + $seg + "_Curve" + $rpNum + "Jnt");
				parentConstraint ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl") ($modCore + $seg + "_Curve" + $rpNum + "Jnt");
				
				shadingNode -asUtility multiplyDivide -n ($modCore + $seg + "_Curve" + $rpNum + "JntMD");
				connectAttr -f ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl.scale") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input1");
				connectAttr -f ($modCore + $segStart + "JntIkFk_BlndScale.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2X");
				connectAttr -f ($modCore + $segStart + "JntIkFk_AutoBlnd.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2Y");
				connectAttr -f ($modCore + $segStart + "JntIkFk_AutoBlnd.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2Z");

				connectAttr -f ($modCore + $seg + "_Curve" + $rpNum + "JntMD.output") ($modCore + $seg + "_Curve" + $rpNum + "Jnt.scale");
				
				parent ($modCore + $seg + "_Curve" + $rpNum + "Jnt") ($modCore + "_curveNodesGrp");
	
				//ATTACH TO PATH
				float $segDivider = ($sizeTwistProxies + 1);
				float $percentage = ($rpNumFloat/$segDivider);
	
				//NO FLIP JOINTS UP
				pathAnimation -n ($modCore + $seg + "" + $rpNum + "_MP") -fractionMode true -followAxis x -upAxis y-worldUpType "objectrotation"
				-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum) ($modCore + $seg + "_Curve" + $rpNum + "_CtrlGrp") ($modCore + $seg + "CurveAttach");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $seg + "" + $rpNum + "_MP");
				setAttr ($modCore + $seg + "" + $rpNum + "_MP.uValue") ($percentage * $uValComp);

				//MOVE CURVE AND JOINT TO THE PROXY
				delete `pointConstraint ("RRM_" + $prfx + $core + $seg + $rpNum) ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl")`;
				makeIdentity -apply true -t 1 ($modCore + $seg + "_Curve" + $rpNum + "_Ctrl");
	
				select -cl;
				$rpNum++;
			}//CREATE TWIST JOINTS
			
			//CREATE TOP CURVE JOINT
			if (!`objExists ($modCore + $segStart + "_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + $segStart + "_CurveJnt");
				delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveJnt")`;
				makeIdentity -apply true -r 1 ($modCore + $segStart + "_CurveJnt");
				if ($segInteger == 1)
				{
					//TARGET LOCATOR
					spaceLocator -n ($modCore + $segStart + "_CurveJnt_AimLctr");
					group -n ($modCore + $segStart + "_CurveJnt_AimLctrGrp");
					pathAnimation -n ($modCore + $segStart + "_CurveJnt_AimLctr_MP") -fractionMode true -followAxis x -upAxis y-worldUpType "objectrotation"
					-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $seg + $segStart + "_NoFlipJnt") ($modCore + $segStart + "_CurveJnt_AimLctrGrp") ($modCore + $seg + "CurveAttach");
					cutKey -cl -t ":" -f ":" -at "u" ($modCore + $segStart + "_CurveJnt_AimLctr_MP");
					setAttr ($modCore + $segStart + "_CurveJnt_AimLctr_MP.uValue") (0.002 * $uValComp);
					
					parent ($modCore + $segStart + "_CurveJnt_AimLctrGrp") ($modCore + "_extraCurveNodesGrp");
					setAttr ($modCore + $segStart + "_CurveJnt_AimLctrGrp.v") 0;
					
					pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveJnt");
					if (($limbType == "leg") && $crntSide == "right")
					{
						aimConstraint -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
					-worldUpVector 0 1 0 -worldUpObject ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr") ($modCore + $segStart + "_CurveJnt_AimLctr") ($modCore + $segStart + "_CurveJnt");						
					}
					else
					{
						aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
					-worldUpVector 0 1 0 -worldUpObject ($modCore + $seg + $segStart + "_TwistSplineIk_Up1Lctr") ($modCore + $segStart + "_CurveJnt_AimLctr") ($modCore + $segStart + "_CurveJnt");
					}

					connectAttr -f ($modCore + $segStart + "JntIkFk_BlndScale.outputR") ($modCore + $segStart + "_CurveJnt.scaleX");
					connectAttr -f ($modCore + $segStart + "JntIkFk_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJnt.scaleY");
					connectAttr -f ($modCore + $segStart + "JntIkFk_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJnt.scaleZ");
				}
				else
				{
					parentConstraint ($modCore + $segStart + "_Curve_Ctrl") ($modCore + $segStart + "_CurveJnt");
					shadingNode -asUtility multiplyDivide -n ($modCore + $segStart + "_CurveJntMD");
					connectAttr -f ($modCore + $segStart + "_Curve_Ctrl.scale") ($modCore + $segStart + "_CurveJntMD.input1");
					connectAttr -f ($modCore + $segStart + "JntIkFk_BlndScale.outputR") ($modCore + $segStart + "_CurveJntMD.input2X");
					connectAttr -f ($modCore + $segStart + "JntIkFk_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJntMD.input2Y");
					connectAttr -f ($modCore + $segStart + "JntIkFk_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJntMD.input2Z");
	
					connectAttr -f ($modCore + $segStart + "_CurveJntMD.output") ($modCore + $segStart + "_CurveJnt.scale");
				}
				parent ($modCore + $segStart + "_CurveJnt") ($modCore + "_curveNodesGrp");
			}
			//CREATE BOTTOM CURVE JOINT
			if (($segInteger != 2) && (!`objExists ($modCore + $segEnd + "_CurveJnt")`))
			{
				select -cl;
				joint -n ($modCore + $segEnd + "_CurveJnt");
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveJnt")`;
				makeIdentity -apply true -r 1 ($modCore + $segEnd + "_CurveJnt");
				if ($segInteger == 1)
				{				
					parentConstraint ($modCore + $segEnd + "_Curve_Ctrl") ($modCore + $segEnd + "_CurveJnt");
				}
				else
				{
					parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveJnt");
				}
				shadingNode -asUtility multiplyDivide -n ($modCore + $segEnd + "_CurveJntMD");
				connectAttr -f ($modCore + $segEnd + "_Curve_Ctrl.scale") ($modCore + $segEnd + "_CurveJntMD.input1");
				connectAttr -f ($modCore + $segEnd + "JntIkFk_BlndScale.outputR") ($modCore + $segEnd + "_CurveJntMD.input2X");
				connectAttr -f ($modCore + $segEnd + "JntIkFk_AutoBlnd.outputR") ($modCore + $segEnd + "_CurveJntMD.input2Y");
				connectAttr -f ($modCore + $segEnd + "JntIkFk_AutoBlnd.outputR") ($modCore + $segEnd + "_CurveJntMD.input2Z");

				connectAttr -f ($modCore + $segEnd + "_CurveJntMD.output") ($modCore + $segEnd + "_CurveJnt.scale");

				parent ($modCore + $segEnd + "_CurveJnt") ($modCore + "_curveNodesGrp");
			}
	 }//CREATE JOINTS AND CONTROLS FOR EACH PROXY
	 else
	 {//CREATE CONNECTOR LINES ONLY
			//CREATE GUIDE SPLINE CURVES FOR MACRO CONTROL ATTACHMENT
			curve -n ($modCore + $seg + "CurveAttach") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1 ;
			rename `listRelatives -c ($modCore + $seg + "CurveAttach")` ($modCore + $seg + "CurveAttachShape");
			
			//CREATE CLUSTERS FOR EACH END
			select ($modCore + $seg + "CurveAttach.cv[0]");
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopGuideClstr");
			
			pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + "TopGuideClstr");
			
			select ($modCore + $seg + "CurveAttach.cv[1]");
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmGuideClstr");
						
			pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmGuideClstr");

			parent ($modCore + $seg + "CurveAttach") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "CurveAttach.template") 1;
			
			parent ($modCore + $seg + "TopGuideClstr") ($modCore + $seg + "BtmGuideClstr") ($modCore + "_curveNodesGrp");
			setAttr ($modCore + $seg + "TopGuideClstr.v") 0;
			setAttr ($modCore + $seg + "BtmGuideClstr.v") 0;
				
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.tx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.ty");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.tz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.rx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.ry");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.rz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.sx");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.sy");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.sz");
			setAttr -l 1 -k 0 ($modCore + $seg + "CurveAttach.v");
	 }
		$segInteger ++;
	}
}

//////////////////////////////////////////////////////////////////////////////
/////////////////////////////// ROLL LIMB ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////

global proc RRM_TwistLimbs(string $modRigName, string $rigGrp, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode, float $behavior, float $behaviorMultiplier, string $lPrfx, string $rPrfx, int $ea)
{
	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $Fk_CtrlGrp = "Fk_CtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFk_CtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$Fk_CtrlGrp = "Fk_CtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	
	if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")` || `objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}
	}

	//UPPER TWIST
	if (`objExists ("RRM_" + $prfx + $core + "_Upper1")`)
	{
		select -cl;
		joint -n ($modCore + $shoulder + "_CurveJnt");
		setAttr ($modCore + $shoulder + "_CurveJnt.radius") 2;
		delete `parentConstraint ($modCore + $shoulder + "Jnt") ($modCore + $shoulder + "_CurveJnt")`;
		parent ($modCore + $shoulder + "_CurveJnt") ($modCore + "_ClavicleJnt");
		makeIdentity -apply 1 -r 1 ($modCore + $shoulder + "_CurveJnt");
		connectAttr -f ($modCore + $shoulder + "Jnt.translate") ($modCore + $shoulder + "_CurveJnt.translate");
		connectAttr -f ($modCore + $shoulder + "Jnt.scale") ($modCore + $shoulder + "_CurveJnt.scale");
	
		select -cl;
		joint -n ($modCore + $shoulder + "_CurveEndJnt");
		setAttr ($modCore + $shoulder + "_CurveEndJnt.radius") 2;
		delete `parentConstraint ($modCore + $elbow1 + "Jnt") ($modCore + $shoulder + "_CurveEndJnt")`;
		parent ($modCore + $shoulder + "_CurveEndJnt") ($modCore + $shoulder + "_CurveJnt");
		makeIdentity -apply 1 -r 1 ($modCore + $shoulder + "_CurveEndJnt"); 
		 
		$prev = 0;
		$i = 1;
		$upperArmCurve = `ls ("RRM_" + $prfx + $core + "_Upper?")`;
		
		//DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "Curve_MD");
		setAttr ($modCore + $shoulder + "Curve_MD.operation") 2;
		setAttr ($modCore + $shoulder + "Curve_MD.input2X") `size $upperArmCurve`;
		connectAttr -f ($modCore + $shoulder + "Jnt.rotateX") ($modCore + $shoulder + "Curve_MD.input1X");
		
		for ($each in $upperArmCurve)
		{
			select -cl;
			joint -n ($modCore + "_Upper_Curve" + $i + "Jnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Upper" + $i) ($modCore + "_Upper_Curve" + $i + "Jnt")`;
			if ($prev == 0)
			{
				parent ($modCore + "_Upper_Curve" + $i + "Jnt") ($modCore + $shoulder + "_CurveJnt");
			}
			else
			{
				parent ($modCore + "_Upper_Curve" + $i + "Jnt") ($modCore + "_Upper_Curve" + $prev + "Jnt");
	
			}
			setAttr (($modCore + "_Upper_Curve" + $i + "Jnt.rotate"), 0, 0, 0);
			setAttr (($modCore + "_Upper_Curve" + $i + "Jnt.jointOrient"), 0, 0, 0);
			connectAttr -f ($modCore + $shoulder + "Curve_MD.outputX") ($modCore + "_Upper_Curve" + $i + "Jnt.rotateX");
			connectAttr -f ($modCore + $shoulder + "Jnt.scale")($modCore + "_Upper_Curve" + $i + "Jnt.scale");
			
			$prev++;
			$i++;
		}
		
		//CREATE Ik HANDLE
		select ($modCore + $shoulder + "_CurveJnt.rotatePivot") ($modCore + $shoulder + "_CurveEndJnt.rotatePivot");
		ikHandle -n ($modCore + "_Upper_CurveIkHandle") -sol ikSCsolver;
		parent ($modCore + "_Upper_CurveIkHandle") ($modCore + "_Clavicle_Ctrl");
		pointConstraint ($modCore + $elbow1 + "Jnt") ($modCore + "_Upper_CurveIkHandle");
		setAttr ($modCore + "_Upper_CurveIkHandle.visibility") 0;
		
		//DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "Curve_MD");
		setAttr ($modCore + $shoulder + "Curve_MD.operation") 2;

		//HIDE SHOULDER AND ELBOW JOINTS SO THEY DON'T GET CONFUSED WITH THE TOON JOINTS
		//DETERMINE VERSION NUMBER
		$versionNum = `getApplicationVersionAsFloat`;
		if ($versionNum >= 2011)
		{
			setAttr ($modCore + $shoulder + "_CurveJnt.drawStyle") 2;
			setAttr ($modCore + $shoulder + "_CurveEndJnt.drawStyle") 2;

		}
		else
		{
			setAttr ($modCore + $shoulder + "_CurveJnt.visibility") 0;
			setAttr ($modCore + $shoulder + "_CurveEndJnt.visibility") 0;
		}
	}
	
	//MIDDLE TWIST
	if (`objExists ("RRM_" + $prfx + $core + "_Middle1")`)
	{
		$prev = 0;
		$i = 1;
		$midArmCurve = `ls ("RRM_" + $prfx + $core + "_Middle?")`;
		
		////DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		//shadingNode -asUtility multiplyDivide -n ($modCore + $elbow1 + "Curve_MD");
		//setAttr ($modCore + $elbow1 + "Curve_MD.operation") 2;
		//setAttr ($modCore + $elbow1 + "Curve_MD.input2X") `size $upperArmCurve`;
		//connectAttr -f ($modCore + "_WristJntGrp1.rotateX") ($modCore + $elbow1 + "Curve_MD.input1X");
		
		for ($each in $midArmCurve)
		{
			select -cl;
			joint -n ($modCore + "_Middle_Curve" + $i + "Jnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Middle" + $i) ($modCore + "_Middle_Curve" + $i + "Jnt")`;
			if ($prev == 0)
			{
				parent ($modCore + "_Middle_Curve" + $i + "Jnt") ($modCore + $elbow1 + "Jnt");
			}
			else
			{
				parent ($modCore + "_Middle_Curve" + $i + "Jnt") ($modCore + "_Middle_Curve" + $prev + "Jnt");
	
			}
			setAttr (($modCore + "_Middle_Curve" + $i + "Jnt.rotate"), 0, 0, 0);
			setAttr (($modCore + "_Middle_Curve" + $i + "Jnt.jointOrient"), 0, 0, 0);
			//connectAttr -f ($modCore + $elbow1 + "Curve_MD.outputX") ($modCore + "_Middle_Curve" + $i + "Jnt.rotateX");
			//connectAttr -f ($modCore + $elbow1 + "Jnt.scale")($modCore + "_Middle_Curve" + $i + "Jnt.scale");
 
			$prev++;
			$i++;			
		}
	}	
	
	//LOWER TWIST
	if (`objExists ("RRM_" + $prfx + $core + "_Lower1")`)
	{
		$prev = 0;
		$i = 1;
		$lowerArmCurve = `ls ("RRM_" + $prfx + $core + "_Lower?")`;
		
		//DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		shadingNode -asUtility multiplyDivide -n ($modCore + $elbow2 + "Curve_MD");
		setAttr ($modCore + $elbow2 + "Curve_MD.operation") 2;
		setAttr ($modCore + $elbow2 + "Curve_MD.input2X") `size $lowerArmCurve`;
		connectAttr -f ($modCore + "_WristJntGrp1.rotateX") ($modCore + $elbow2 + "Curve_MD.input1X");
		
		for ($each in $lowerArmCurve)
		{
			select -cl;
			joint -n ($modCore + "_Lower_Curve" + $i + "Jnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Lower" + $i) ($modCore + "_Lower_Curve" + $i + "Jnt")`;
			if ($prev == 0)
			{
				parent ($modCore + "_Lower_Curve" + $i + "Jnt") ($modCore + $elbow2 + "Jnt");
			}
			else
			{
				parent ($modCore + "_Lower_Curve" + $i + "Jnt") ($modCore + "_Lower_Curve" + $prev + "Jnt");
	
			}
			setAttr (($modCore + "_Lower_Curve" + $i + "Jnt.rotate"), 0, 0, 0);
			setAttr (($modCore + "_Lower_Curve" + $i + "Jnt.jointOrient"), 0, 0, 0);
			connectAttr -f ($modCore + $elbow2 + "Curve_MD.outputX") ($modCore + "_Lower_Curve" + $i + "Jnt.rotateX");
			connectAttr -f ($modCore + $elbow2 + "Jnt.scale")($modCore + "_Lower_Curve" + $i + "Jnt.scale");

			$prev++;
			$i++;			
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////ROLL JOINTS////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_TwistJoints(string $modRigName, string $rigGrp, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode, int $ea)
{
	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $Fk_CtrlGrp = "Fk_CtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFk_CtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$Fk_CtrlGrp = "Fk_CtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	else
	{
		select ("RRM_" + $prfx + $core + "_Shoulder") ("RRM_" + $prfx + $core + "_Wrist");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow1") ("RRM_" + $prfx + $core + "_Elbow1");
		}
	}
	$segments = `ls -sl`;
		
	float $middleLimbLength;

	if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")` && !`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".tx")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	else
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}			
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$middleLimbLength = `getAttr ($modCore + $elbow2 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".tx")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////STRETCH AND SOFT Ik/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_LimbStretch(string $modRigName, string $rigGrp, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, float $behavior, float $behaviorMultiplier, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow2";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $endIk = "_WristIk";
	string $elbowIk = "_ElbowIk";
	string $lowerLimbIk = "_LowerArmIk";
	string $wristDummy = "_WristJntDummy";
	string $Fk_CtrlGrp = "Fk_CtrlGrp2";
	string $lockAttr = "elbowLock";
	int $segInteger = 1;
	float $limbLength;
	float $upperLimbLength;
	float $lowerLimbLength;
	float $middleLimbLength;
	
	if (`objExists ("RRM_" + $prfx + $core + $elbow2)`)
	{
		$elbow1 = "_Elbow1";
	}
	
	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee2";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFk_CtrlGrp";
		$wrist = "_Ankle";
		$endIk = "_FootIk";
		$elbowIk = "_KneeIk";
		$lowerLimbIk = "_LowerLegIk";
		$wristDummy = "_AnkleJnt";
		$Fk_CtrlGrp = "Fk_CtrlGrp";
		$lockAttr = "kneeLock";
		select ("RRM_" + $prfx + $core + $shoulder) ("RRM_" + $prfx + $core + $wrist);
		if (`objExists ("RRM_" + $prfx + $core + $elbow2)`)
		{
			$elbow1 = "_Knee1";
		}
	}
		

	if (!`objExists ("RRM_" + $prfx + $core + $elbow2)`)
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".tx")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	else
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$middleLimbLength = `getAttr ($modCore + $elbow2 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".tx")`;
		$limbLength = (($upperLimbLength + $middleLimbLength)/2);
	}
	
	if ($limbLength < 0)
	{
		$limbLength = ($limbLength * -1);
	}
	
	//AIM LOCATORS
	spaceLocator -n ($modCore + $elbowIk + "_Ctrl_TargetLctr");
	spaceLocator -n ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr");
	spaceLocator -n ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr");
	delete `pointConstraint ("RRM_" + $prfx + $core + $shoulder) ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr")`;
	parentConstraint -mo ($modCore + "_ScaleGrp") ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr");
	
	delete `pointConstraint ("RRM_" + $prfx + $core + $wrist) ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr")`;
	if ($limbType == "arm")
	{
		parentConstraint -mo ($modCore + $wrist + "Pivot_Lctr") ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr");
	}
	else
	{
		parentConstraint -mo ($modCore + "_BallIk_Ctrl") ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr");
	}
	
	parent ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr") ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr") ($modCore + "_ScaleGrp");
	setAttr ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr.v") 0;
	setAttr ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr.v") 0;
		
	if (!`objExists ("RRM_" + $prfx + $core + $elbow2)`)
	{	
		delete `pointConstraint ($modCore + $elbow1 + "Jnt") ($modCore + $elbowIk + "_Ctrl_TargetLctr")`;
		pointConstraint -mo ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr") ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr") ($modCore + $elbowIk + "_Ctrl_TargetLctr");
		//aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
		//($modCore + $elbowIk + "_Ctrl_TargetLctr") ($modCore + $elbowIk + "_Ctrl");
	}
	else
	{
		pointConstraint ($modCore + $elbowIk + "_Ctrl" + $shoulder + "Lctr") ($modCore + "_Lower" + $elbowIk + "OffsetLctr") ($modCore + $elbowIk + "_Ctrl_TargetLctr");
		//aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
		//($modCore + $elbowIk + "_Ctrl_TargetLctr") ($modCore + $elbowIk + "_Ctrl");
	}
		

	//Ik SCALE

	//ADD STRETCH TO Ik CONTROL
	if (!`objExists ($modCore + $endIk + "_Ctrl.dampen_softness")`)
	{
		addAttr -ln "dampen_softness" -at double -min 0 -dv 0 ($modCore + $endIk + "_Ctrl");
	}
	if (!`objExists ($modCore + $endIk + "_Ctrl.stretch")`)
	{
		addAttr -ln "stretch" -at double -min 0 -max 1 -dv 0 ($modCore + $endIk + "_Ctrl");
	}
		if (!`objExists ($modCore + $endIk + "_Ctrl." + $lockAttr)`)
	{
		addAttr -ln $lockAttr -at double -min 0 -max 1 -dv 0 ($modCore + $endIk + "_Ctrl");
	}
	
	//NODES
	spaceLocator -n ($modCore + "_LimbLengthOriginLctr");
	
	spaceLocator -n ($modCore + "_LimbLengthEndLctr");
	parent ($modCore + "_LimbLengthEndLctr") ($modCore + "_LimbLengthOriginLctr");
	
	spaceLocator -n ($modCore + "_LimbLengthSoftLctr");
	parent ($modCore + "_LimbLengthSoftLctr") ($modCore + "_LimbLengthOriginLctr");

	spaceLocator -n ($modCore + "_LimbLengthAttachLctr");
	parent ($modCore + "_LimbLengthAttachLctr") ($modCore + "_LimbLengthOriginLctr");

	
	pointConstraint ($modCore + $shoulder + "JntIk") ($modCore + "_LimbLengthOriginLctr");

	shadingNode -n ($modCore + "_stretch_" + $lockAttr + "_PMA") -asUtility plusMinusAverage;
	connectAttr -f ($modCore + $endIk + "_Ctrl.stretch") ($modCore + "_stretch_" + $lockAttr + "_PMA.input1D[0]");		
	connectAttr -f ($modCore + $endIk + "_Ctrl." + $lockAttr) ($modCore + "_stretch_" + $lockAttr + "_PMA.input1D[1]");

	shadingNode -asUtility clamp -n ($modCore + "_stretch_" + $lockAttr + "_Clamp");
	setAttr ($modCore + "_stretch_" + $lockAttr + "_Clamp.maxR") 1;
	connectAttr -f ($modCore + "_stretch_" + $lockAttr + "_PMA.output1D") ($modCore + "_stretch_" + $lockAttr + "_Clamp.inputR");


	shadingNode -asUtility blendColors -n ($modCore + "_LimbLengthSoft_Blnd");
	connectAttr -f ($modCore + "_stretch_" + $lockAttr + "_Clamp.outputR") ($modCore + "_LimbLengthSoft_Blnd.blender");
	connectAttr -f ($modCore + "_LimbLengthEndLctr.tx ") ($modCore + "_LimbLengthSoft_Blnd.color1R");
	connectAttr -f ($modCore + "_LimbLengthSoftLctr.tx ") ($modCore + "_LimbLengthSoft_Blnd.color2R");
	connectAttr -f ($modCore + "_LimbLengthSoft_Blnd.outputR") ($modCore + "_LimbLengthAttachLctr.tx ");

	
	if (!`objExists ("RRM_" + $prfx + $core + $elbow2)`)
	{
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr") ($modCore + "_LimbLengthOriginLctr");
		delete `pointConstraint ($modCore + $endIk + "_Ctrl") ($modCore + "_LimbLengthEndLctr")`;
		delete `pointConstraint ($modCore + $endIk + "_Ctrl") ($modCore + "_LimbLengthSoftLctr")`;
		parentConstraint -mo ($modCore + $elbowIk + "_Ctrl" + $wrist + "Lctr") ($modCore + "_LimbLengthEndLctr");
	}
	else
	{
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_Lower" + $elbowIk + "OffsetLctr") ($modCore + "_LimbLengthOriginLctr");
		spaceLocator -n ($modCore + "_LowerLimbIkCLctr");
		setAttr ($modCore + "_LowerLimbIkCLctr.v") 0;
		delete `parentConstraint ($modCore + $elbow2 + "Jnt") ($modCore + "_LowerLimbIkCLctr")`;
		delete `parentConstraint ($modCore + $elbow2 + "Jnt") ($modCore + "_LimbLengthSoftLctr")`;
		parent ($modCore + "_LowerLimbIkCLctr") ($modCore + $lowerLimbIk + "_Ctrl");
		pointConstraint ($modCore + "_LowerLimbIkCLctr") ($modCore + "_LimbLengthEndLctr");
	}
	
	
	//SOFT Ik
	//Non-zero check
	shadingNode -n ($modCore + "_SoftZeroCondition") -asUtility condition;
	connectAttr -f ($modCore + $endIk + "_Ctrl.dampen_softness") ($modCore + "_SoftZeroCondition.firstTerm");
	connectAttr -f ($modCore + $endIk + "_Ctrl.dampen_softness") ($modCore + "_SoftZeroCondition.colorIfFalseR");
	setAttr ($modCore + "_SoftZeroCondition.colorIfTrueR") 0.0001;

	//Ratio
	shadingNode -n ($modCore + "_SoftRatio_MD") -asUtility multiplyDivide;
	setAttr ($modCore + "_SoftRatio_MD.input1X") (($limbLength * 2)* .01);
	connectAttr -f ($modCore + "_SoftZeroCondition.outColorR") ($modCore + "_SoftRatio_MD.input2X");


	//1. da PMA
	shadingNode -n ($modCore + "_da_PMA") -asUtility plusMinusAverage;
	setAttr ($modCore + "_da_PMA.operation") 2;
	setAttr ($modCore + "_da_PMA.input1D[0]") ($limbLength * 2);
	connectAttr -f ($modCore + "_SoftRatio_MD.outputX") ($modCore + "_da_PMA.input1D[1]");

	//2. len PMA
	shadingNode -n ($modCore + "_len_da_PMA") -asUtility plusMinusAverage;
	setAttr ($modCore + "_len_da_PMA.operation") 2;
	connectAttr -f ($modCore + "_da_PMA.output1D") ($modCore + "_len_da_PMA.input1D[0]");
	connectAttr -f ($modCore + "_LimbLengthEndLctr.tx") ($modCore + "_len_da_PMA.input1D[1]");
	
	//3. zero check condition
	shadingNode -n ($modCore + "_SoftZeroCondition2") -asUtility condition;
	setAttr ($modCore + "_SoftZeroCondition2.colorIfTrueR") 0.001;
	connectAttr -f ($modCore + "_SoftRatio_MD.outputX") ($modCore + "_SoftZeroCondition2.firstTerm");
	connectAttr -f ($modCore + "_SoftRatio_MD.outputX") ($modCore + "_SoftZeroCondition2.colorIfFalseR");

	//4. md divide by dsoft
	shadingNode -n ($modCore + "_div_dSoft_MD") -asUtility multiplyDivide;
	setAttr ($modCore + "_div_dSoft_MD.operation") 2;
	connectAttr -f ($modCore + "_len_da_PMA.output1D") ($modCore + "_div_dSoft_MD.input1X");
	connectAttr -f ($modCore + "_SoftZeroCondition2.outColorR") ($modCore + "_div_dSoft_MD.input2X");

	//5. zero check condition
	shadingNode -n ($modCore + "_SoftZeroCondition3") -asUtility condition;
	connectAttr -f ($modCore + "_SoftRatio_MD.outputX") ($modCore + "_SoftZeroCondition3.firstTerm");
	connectAttr -f ($modCore + "_div_dSoft_MD.outputX") ($modCore + "_SoftZeroCondition3.colorIfFalseR");

	//6. to power of e
	shadingNode -n ($modCore + "_ePower_MD") -asUtility multiplyDivide;
	setAttr ($modCore + "_ePower_MD.operation") 3;
	setAttr ($modCore + "_ePower_MD.input1X") 2.71828;
	connectAttr -f ($modCore + "_div_dSoft_MD.outputX") ($modCore + "_ePower_MD.input2X");

	//7. Connect back to softZeroCondition
	shadingNode -n ($modCore + "_SoftZeroCondition4") -asUtility condition;
	connectAttr -f ($modCore + $endIk + "_Ctrl.dampen_softness") ($modCore + "_SoftZeroCondition4.firstTerm");
	connectAttr -f ($modCore + "_ePower_MD.outputX") ($modCore + "_SoftZeroCondition4.colorIfFalseR");

	//8. subtract e power
	shadingNode -n ($modCore + "_MinusE_PMA") -asUtility plusMinusAverage;
	setAttr ($modCore + "_MinusE_PMA.operation") 2;
	setAttr ($modCore + "_MinusE_PMA.input1D[0]") 1;
	connectAttr -f ($modCore + "_SoftZeroCondition4.outColorR") ($modCore + "_MinusE_PMA.input1D[1]");

	//9. md dsoft to result
	shadingNode -n ($modCore + "_Result_dSoft_MD") -asUtility multiplyDivide;
	connectAttr -f ($modCore + "_SoftRatio_MD.outputX") ($modCore + "_Result_dSoft_MD.input1X");
	connectAttr -f ($modCore + "_MinusE_PMA.output1D") ($modCore + "_Result_dSoft_MD.input2X");

	//10. da final PMA
	shadingNode -n ($modCore + "_da_final_PMA") -asUtility plusMinusAverage;
	connectAttr -f ($modCore + "_Result_dSoft_MD.outputX") ($modCore + "_da_final_PMA.input1D[0]");
	connectAttr -f ($modCore + "_da_PMA.output1D") ($modCore + "_da_final_PMA.input1D[1]");


	//11. conditional
	shadingNode -n ($modCore + "_SoftIk_Condition") -asUtility condition;
	connectAttr -f ($modCore + "_LimbLengthEndLctr.tx") ($modCore + "_SoftIk_Condition.firstTerm");
	connectAttr -f ($modCore + "_da_PMA.output1D") ($modCore + "_SoftIk_Condition.secondTerm");
	setAttr ($modCore + "_SoftIk_Condition.operation") 4;
	connectAttr -f ($modCore + "_LimbLengthEndLctr.tx") ($modCore + "_SoftIk_Condition.colorIfTrueR");
	connectAttr -f ($modCore + "_da_final_PMA.output1D") ($modCore + "_SoftIk_Condition.colorIfFalseR");

	connectAttr -f ($modCore + "_SoftIk_Condition.outColorR") ($modCore + "_LimbLengthSoftLctr.translateX");

	setAttr ($modCore + "_LimbLengthSoftLctr.translateY") 0;
	setAttr ($modCore + "_LimbLengthSoftLctr.translateZ") 0;

	//SOFT STRETCH
	shadingNode -n ($modCore + "_soft_diff_PMA") -asUtility plusMinusAverage;
	setAttr ($modCore + "_soft_diff_PMA.operation") 2;
	connectAttr -f ($modCore + "_LimbLengthEndLctr.tx") ($modCore + "_soft_diff_PMA.input1D[0]");
	connectAttr -f ($modCore + "_LimbLengthSoftLctr.tx") ($modCore + "_soft_diff_PMA.input1D[1]");

	shadingNode -n ($modCore + "_soft_diff_ratio_MD") -asUtility multiplyDivide;
	setAttr ($modCore + "_soft_diff_ratio_MD.operation") 2;
	connectAttr -f ($modCore + "_soft_diff_PMA.output1D") ($modCore + "_soft_diff_ratio_MD.input1X");
	setAttr ($modCore + "_soft_diff_ratio_MD.input2X") ($limbLength * 2);

	shadingNode -n ($modCore + "_soft_add_ratio_PMA") -asUtility plusMinusAverage;
	setAttr ($modCore + "_soft_add_ratio_PMA.input1D[0]") 1;
	connectAttr -f ($modCore + "_soft_diff_ratio_MD.outputX") ($modCore + "_soft_add_ratio_PMA.input1D[1]");

	shadingNode -asUtility blendColors -n ($modCore + "_soft_scale_blnd");
	connectAttr -f ($modCore + $endIk + "_Ctrl.stretch") ($modCore + "_soft_scale_blnd.blender");
	connectAttr -f ($modCore + "_soft_add_ratio_PMA.output1D") ($modCore + "_soft_scale_blnd.color1R");
	setAttr ($modCore + "_soft_scale_blnd.color2") -type double3 1 0 1 ;

	shadingNode -asUtility blendColors -n ($modCore + "_LimbLength_Blnd");
	connectAttr -f ($modCore + "_soft_scale_blnd.outputR") ($modCore + "_LimbLength_Blnd.color1R");
	setAttr ($modCore + "_LimbLength_Blnd.color2") -type double3 1 0 1 ;

	//LEG Ik LOCK
	
	//LEG Ik LOCK LOCATORS
	spaceLocator -n ($modCore + $shoulder + "IkLockLctr");
	spaceLocator -n ($modCore + $elbow1 + "IkLockLctr");
	spaceLocator -n ($modCore + $wrist + "IkLockLctr");
	parent ($modCore + $elbow1 + "IkLockLctr") ($modCore + $shoulder + "IkLockLctr");
	parent ($modCore + $wrist + "IkLockLctr") ($modCore + $elbow1 + "IkLockLctr");
	pointConstraint ($modCore + $shoulder + "JntIk") ($modCore + $shoulder + "IkLockLctr");
	aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + $elbowIk + "_Ctrl") ($modCore + $shoulder + "IkLockLctr");
	pointConstraint ($modCore + $elbowIk + "_Ctrl") ($modCore + $elbow1 + "IkLockLctr");
	
	if (!`objExists ("RRM_" + $prfx + $core + $elbow2)`)
	{
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + $endIk + "_Ctrl") ($modCore + $elbow1 + "IkLockLctr");
		delete `pointConstraint ($modCore + $endIk + "_Ctrl") ($modCore + $wrist + "IkLockLctr")`;
		if ($limbType == "arm")
		{
			pointConstraint ($modCore + $wrist + "Pivot_Lctr") ($modCore + $wrist + "IkLockLctr");
		}
		else
		{
			parentConstraint -mo ($modCore + "_BallIk_Ctrl") ($modCore + $wrist + "IkLockLctr");			
		}

		shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "LockLength_MD");
		setAttr ($modCore + $shoulder + "LockLength_MD.operation") 2;
		connectAttr -f ($modCore + $elbow1 + "IkLockLctr.translateX") ($modCore + $shoulder + "LockLength_MD.input1X");
		setAttr ($modCore + $shoulder + "LockLength_MD.input2X") $upperLimbLength;
		
		shadingNode -asUtility multiplyDivide -n ($modCore + $elbow1 + "LockLength_MD");
		setAttr ($modCore + $elbow1 + "LockLength_MD.operation") 2;
		connectAttr -f ($modCore + $wrist + "IkLockLctr.translateX") ($modCore + $elbow1 + "LockLength_MD.input1X");
		setAttr ($modCore + $elbow1 + "LockLength_MD.input2X") $lowerLimbLength;
		
		shadingNode -asUtility blendColors -n ($modCore + $shoulder + "Lock_Blnd");
		connectAttr -f ($modCore + $shoulder + "LockLength_MD.outputX") ($modCore + $shoulder + "Lock_Blnd.color1R");
		connectAttr -f ($modCore + "_LimbLength_Blnd.outputR") ($modCore + $shoulder + "Lock_Blnd.color2R");
		
		shadingNode -asUtility blendColors -n ($modCore + $elbow1 + "Lock_Blnd");
		connectAttr -f ($modCore + $elbow1 + "LockLength_MD.outputX") ($modCore + $elbow1 + "Lock_Blnd.color1R");
		connectAttr -f ($modCore + "_LimbLength_Blnd.outputR") ($modCore + $elbow1 + "Lock_Blnd.color2R");
	}
	else
	{
		parent ($modCore + "_Lower" + $elbowIk + "OffsetLctr") ($modCore + $shoulder + "IkLockLctr");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + $lowerLimbIk + "_Ctrl") ($modCore + "_Lower" + $elbowIk + "OffsetLctr");
		
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_Lower" + $elbowIk + "OffsetLctr") ($modCore + $elbow1 + "IkLockLctr");
		pointConstraint ($modCore + "_Lower" + $elbowIk + "OffsetLctr") ($modCore + $wrist + "IkLockLctr");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "LockLength_MD");
		setAttr ($modCore + $shoulder + "LockLength_MD.operation") 2;
		connectAttr -f ($modCore + $elbow1 + "IkLockLctr.translateX") ($modCore + $shoulder + "LockLength_MD.input1X");
		setAttr ($modCore + $shoulder + "LockLength_MD.input2X") $upperLimbLength;
		
		shadingNode -asUtility multiplyDivide -n ($modCore + $elbow1 + "LockLength_MD");
		setAttr ($modCore + $elbow1 + "LockLength_MD.operation") 2;
		connectAttr -f ($modCore + $wrist + "IkLockLctr.translateX") ($modCore + $elbow1 + "LockLength_MD.input1X");
		setAttr ($modCore + $elbow1 + "LockLength_MD.input2X") $middleLimbLength;
		
		shadingNode -asUtility blendColors -n ($modCore + $shoulder + "Lock_Blnd");
		connectAttr -f ($modCore + $shoulder + "LockLength_MD.outputX") ($modCore + $shoulder + "Lock_Blnd.color1R");
		connectAttr -f ($modCore + "_LimbLength_Blnd.outputR") ($modCore + $shoulder + "Lock_Blnd.color2R");
		
		shadingNode -asUtility blendColors -n ($modCore + $elbow1 + "Lock_Blnd");
		connectAttr -f ($modCore + $elbow1 + "LockLength_MD.outputX") ($modCore + $elbow1 + "Lock_Blnd.color1R");
		connectAttr -f ($modCore + "_LimbLength_Blnd.outputR") ($modCore + $elbow1 + "Lock_Blnd.color2R");

		//AUTO STRETCH ON LOWER LEG Ik CONTROL
		addAttr -ln "lowerScale" -at double -min 0.01 -dv 1 ($modCore + $lowerLimbIk + "_Ctrl");
		setAttr -e -k 1 ($modCore + $lowerLimbIk + "_Ctrl.lowerScale");
		
		//GET LEG LENGTH
		
		$Knee1Length2 = `getAttr ($modCore + $elbow1 + "Jnt.tx")`;
		$Knee2Length2 = `getAttr ($modCore + $elbow2 + "Jnt.tx")`;
		$AnkleLength2 = `getAttr ($modCore + $wristDummy + ".tx")`;
		$FullLimbLength = (($Knee1Length2 + $Knee2Length2 + $AnkleLength2) * $multiplier);
		
		//LEG LENGTH LOCATORS
		spaceLocator -n ($modCore + "_FullLimbLengthAimLctr");
		spaceLocator -n ($modCore + "_FullLimbLengthEndLctr");
		parent ($modCore + "_FullLimbLengthEndLctr") ($modCore + "_FullLimbLengthAimLctr");
		parent ($modCore + "_FullLimbLengthAimLctr") ($modCore + "_ScaleGrp");
		pointConstraint ($modCore + $shoulder + "JntIk") ($modCore + "_FullLimbLengthAimLctr");
		pointConstraint ($modCore + $lowerLimbIk + "_CtrlGrp2_LctrOffset") ($modCore + "_FullLimbLengthEndLctr");
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + $endIk + "_Ctrl") ($modCore + "_FullLimbLengthAimLctr");

		shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLimbLength_MD");
		setAttr ($modCore + "_FullLimbLength_MD.operation") 2;
		connectAttr -force ($modCore + "_FullLimbLengthEndLctr.translateX") ($modCore + "_FullLimbLength_MD.input1X");
		setAttr ($modCore + "_FullLimbLength_MD.input2X") $FullLimbLength;
		
		shadingNode -asUtility condition -n ($modCore + "_FullLimbLength_Condition");
		connectAttr -force ($modCore + "_FullLimbLength_MD.outputX") ($modCore + "_FullLimbLength_Condition.firstTerm");
		setAttr ($modCore + "_FullLimbLength_Condition.secondTerm") 1;
		setAttr ($modCore + "_FullLimbLength_Condition.operation") 2;
		connectAttr -force ($modCore + "_FullLimbLength_MD.outputX") ($modCore + "_FullLimbLength_Condition.colorIfTrueR");

		shadingNode -asUtility blendColors -n ($modCore + "_FullLimbLength_Blnd");
		connectAttr -force ($modCore + $endIk + "_Ctrl.stretch") ($modCore + "_FullLimbLength_Blnd.blender");
		connectAttr -force ($modCore + "_FullLimbLength_Condition.outColorR") ($modCore + "_FullLimbLength_Blnd.color1R");
		setAttr ($modCore + "_FullLimbLength_Blnd.color2R") 1;
		
		setAttr ($modCore + "_FullLimbLengthAimLctr.v") 0;
		
		//MULTIPLY STRETCH WITH LOWER SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLimbLength2_MD");
		connectAttr -force ($modCore + $lowerLimbIk + "_Ctrl.lowerScale") ($modCore + "_FullLimbLength2_MD.input1X");
		connectAttr -force ($modCore + "_FullLimbLength_Blnd.outputR") ($modCore + "_FullLimbLength2_MD.input2X");
		if ($limbType == "arm")
		{
			connectAttr -force ($modCore + "_FullLimbLength2_MD.outputX") ($modCore + $lowerLimbIk + "_Ctrl.scaleX");
		}
		else
		{
			connectAttr -force ($modCore + "_FullLimbLength2_MD.outputX") ($modCore + $lowerLimbIk + "_Ctrl.scaleY");
		}

		//CREATE MULTIPLY/DIVIDE TO CONNECT TO THE KNEE2JntIk
		shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLimbLength2_Inv_MD");
		setAttr ($modCore + "_FullLimbLength2_Inv_MD.operation") 2;
		setAttr ($modCore + "_FullLimbLength2_Inv_MD.input1X") 1;
		connectAttr ($modCore + "_FullLimbLength2_MD.outputX") ($modCore + $elbow2 + "JntIk.scaleX");
		connectAttr ($modCore + "_FullLimbLength2_MD.outputX") ($modCore + "_FullLimbLength2_Inv_MD.input2X");
	}
	
		
	//ADD STRETCH AND SOFT TO Ik ANKLE CONTROL
	setAttr -e -k 1 ($modCore + $endIk + "_Ctrl.stretch");
	connectAttr -f ($modCore + $endIk + "_Ctrl.stretch") ($modCore + "_LimbLength_Blnd.blender");
	
	setAttr -e -k 1 ($modCore + $endIk + "_Ctrl.dampen_softness");
	
	//ADD KNEE LOCK TO Ik ANKLE CONTROL
	setAttr -e -k 1 ($modCore + $endIk + "_Ctrl." + $lockAttr);
	connectAttr -f ($modCore + $endIk + "_Ctrl." + $lockAttr) ($modCore + $shoulder + "Lock_Blnd.blender");
	connectAttr -f ($modCore + $endIk + "_Ctrl." + $lockAttr) ($modCore + $elbow1 + "Lock_Blnd.blender");
	
	//ADD LIMB SCALE
	if (! `objExists ($modCore + $endIk + "_Ctrl.limbScale")`)
	{
		addAttr -ln "limbScale" -at double -min 0.01 -dv 1 ($modCore + $endIk + "_Ctrl");
		setAttr -e -k 1 ($modCore + $endIk + "_Ctrl.limbScale");
	}
	
	shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "Scale_MD");
	connectAttr -force ($modCore + $shoulder + "Lock_Blnd.outputR") ($modCore + $shoulder + "Scale_MD.input1X");
	connectAttr -force ($modCore + $endIk + "_Ctrl.limbScale") ($modCore + $shoulder + "Scale_MD.input2X");
	connectAttr -force ($modCore + $shoulder + "Scale_MD.outputX") ($modCore + $shoulder + "JntIk.scaleX");
	
	shadingNode -asUtility multiplyDivide -n ($modCore + $elbow1 + "Scale_MD");
	connectAttr -force ($modCore + $elbow1 + "Lock_Blnd.outputR") ($modCore + $elbow1 + "Scale_MD.input1X");
	connectAttr -force ($modCore + $endIk + "_Ctrl.limbScale") ($modCore + $elbow1 + "Scale_MD.input2X");

	//if (!`objExists ("RRM_" + $prfx + $core + $elbow2)`)
	//{
		connectAttr -force ($modCore + $elbow1 + "Scale_MD.outputX") ($modCore + $elbow1 + "JntIk.scaleX");
	//}
	//else
	//{
	//	connectAttr -force ($modCore + $elbow1 + "Scale_MD.outputX") ($modCore + $elbow1 + "JntIk.scaleX");
	//}
	

	//////////////////////////////////FOOT IkFk SWITCH CONTROL///////////////////////////////////////////
	curve -n ($modCore + "_Switch_Ctrl") -d 1 -p 0 0 0 -p -2 0 -2 -p -1 0 -2 -p -1 0 -5 -p 1 0 -5 -p 1 0 -2
	-p 2 0 -2 -p 0 0 0 -p 0 2 -2 -p 0 1 -2 -p 0 1 -5 -p 0 -1 -5 -p 0 -1 -2
	-p 0 -2 -2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10
	-k 11 -k 12 -k 13 -k 14 ;
	rename `listRelatives -c ($modCore + "_Switch_Ctrl")` ($modCore + "_Switch_CtrlShape");
	
	move -r -os -wd 0 0 -8 ($modCore + "_Switch_Ctrl");
	group -n ($modCore + "_Switch_CtrlGrp") ($modCore + "_Switch_Ctrl"); xform -os -piv 0 0 0;
	scale -r 0.2 0.2 0.2 ($modCore + "_Switch_CtrlGrp");
	makeIdentity -apply true -t 0 -r 1 -s 1 ($modCore + "_Switch_CtrlGrp");
	delete `parentConstraint ($modCore + $endIk + "_CtrlGrp") ($modCore + "_Switch_CtrlGrp")`;
	//delete `pointConstraint ($modCore + $wrist + "Jnt") ($modCore + "_Switch_CtrlGrp")`;
	//parent ($modCore + "_Switch_CtrlGrp") ($modCore + $endIk + "_CtrlGrp");
	//makeIdentity -apply false -r 1 ($modCore + "_Switch_CtrlGrp");
	//parent -w ($modCore + "_Switch_CtrlGrp");
	if ($crntSide == "right" && $behavior == 0 && $limbType == "arm")
	{
		//$rz = `getAttr ($modCore + "_Switch_CtrlGrp.rz")`;
		//rotate -r -os 180 0 ($rz * -1) ($modCore + "_Switch_CtrlGrp");
	}
	if ($crntSide == "right")
	{
		//rotate -r -os 0 180 0 ($modCore + "_Switch_CtrlGrp");
	}

	setAttr (($modCore + "_Switch_CtrlGrp.scale"), ($limbLength / 3.5), ($limbLength / 3.5), ($limbLength / 3.5));
	
	addAttr -ln "switchIkFk" -at double -min 0 -max 1 -dv 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl.switchIkFk");
	addAttr -ln "autoVolume" -at double -min 0 -max 1 -dv 0 ($modCore + "_Switch_Ctrl");
	setAttr -e -k 1 ($modCore + "_Switch_Ctrl.autoVolume");
	setAttr ($modCore + "_Switch_Ctrl.autoVolume") 1;
	
	xform -cp ($modCore + "_Switch_Ctrl");
	
	parentConstraint -mo ($modCore + $wrist + "Jnt") ($modCore + "_Switch_CtrlGrp");

	
	//PARENT ORIENT
	$parentOrient = ($modCore + "_Switch_Ctrl");
	RRM_ParentOrient($modRigName, $modCore, $modAttachNode, $parentOrient);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRigArm(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	$core = `getAttr ($topNode + ".core")`;

	$core = `getAttr ($topNode + ".core")`;
	int $inverseFront = 0;


	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	float $behavior = 1;
	float $behaviorMultiplier = 1;
	
	if (!`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "";
		$rPrfx = "";
	}
	else if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
	{
		if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
		{	
			$behavior = 0;
		}
	}

	$i = 0;

	//ARM
	while ($i !=2)
	{
		if (!`objExists ($topNode + ".pair")`)
		{
			$prfx = "";
			$oppPrfx = "";
			$prfx = "";
			$oppPrfx = "";
			select $topNode;
			
			$crntSide = `getAttr ($topNode + ".single")`;
			if ($crntSide == "right")
			{
				$multiplier = -1;
				$inverseFront = 1;
			}
		}
		
		if ($crntSide == "right" && `objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behaviorMultiplier = -1;
			}
		}
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$modOppCore = ($modRigName + "" + $oppPrfx + $core);
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "arm";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		//UPPER ROLL JOINTS
		string $UpperCJnt[];
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
		}
		addAttr -ln "upperTwist" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.upperTwist") ;
		setAttr -type "string" ($modCore + "Grp.upperTwist") `size $UpperCJnt`;
		setAttr -l true ($modCore + "Grp.upperTwist");
		
		string $LowerCJnt[];
		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
		}
		addAttr -ln "lowerTwist" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.lowerTwist") ;
		setAttr -type "string" ($modCore + "Grp.lowerTwist") `size $LowerCJnt`;
		setAttr -l true ($modCore + "Grp.lowerTwist");
	
	
		addAttr -ln "elbowNum" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.elbowNum") ;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr -type "string" ($modCore + "Grp.elbowNum") "1";
		}
		else
		{
			setAttr -type "string" ($modCore + "Grp.elbowNum") "2";
		}		
		setAttr -l true ($modCore + "Grp.elbowNum");
		
	
		int $sizeMiddleCJnt = 0;
		string $MiddleCJnt[];
		if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
		{
			$MiddleCJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
		}
		addAttr -ln "midTwist" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.midTwist") ;
		setAttr -type "string" ($modCore + "Grp.midTwist") $MiddleCJnt;
		setAttr -l true ($modCore + "Grp.midTwist");
		
		
	
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");
		
		
		//CONTROLS
		
		//SCALE
		float $ArmLength;
		float $ShoulderLength[];
		float $elbowLength[];
		float $elbow1Length[];
		float $elbow2Length[];
		float $wristLength[];
		
		spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
		spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_StartLctr")`;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
		("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_EndLctr")`;
		$ShoulderLength = `xform -q -t ($modCore + "_EndLctr")`;
			
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_EndLctr")`;
			$elbowLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_EndLctr")`;
			$wristLength = `xform -q -t ($modCore + "_EndLctr")`;
		}
		else
		{
			//spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			//spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			//parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");

			delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_EndLctr")`;
			$elbow1Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_EndLctr")`;
			$elbow2Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_EndLctr")`;
			$wristLength = `xform -q -t ($modCore + "_EndLctr")`;
		}	
		$ArmLength = (($elbowLength[0] + $wristLength[0]) /2);
		delete ($modCore + "_StartLctr");
		
		//CLAVICLE CONTROL
		//circle -n ($modCore + "_Clavicle_Ctrl") -nr 0 1 0 -r 1 -ch 0;
		//setAttr ($modCore + "_Clavicle_Ctrl.rotateOrder") 1;
		//move -r ($multiplier * 1.35) 2 0 ($modCore + "_Clavicle_Ctrl.cv[3]") ($modCore + "_Clavicle_Ctrl.cv[7]") ;
		//move -r ($multiplier * 0.5) 1.25 0 ($modCore + "_Clavicle_Ctrl.cv[2]") ($modCore + "_Clavicle_Ctrl.cv[4]") ($modCore + "_Clavicle_Ctrl.cv[0]") ($modCore + "_Clavicle_Ctrl.cv[6]") ;
		//group -n ($modCore + "_Clavicle_CtrlGrp") ($modCore + "_Clavicle_Ctrl"); xform -os -piv 0 0 0;
		//setAttr ($modCore + "_Clavicle_CtrlGrp.rotateOrder") 1;
		//delete `parentConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_Clavicle_CtrlGrp")`;

		circle -n ($modCore + "_Clavicle_Ctrl") -c 0 0 0 -nr 1 0 0 -r 1 -sw 150;
		circle -n ($modCore + "_Clavicle_Ctrl2") -c ($multiplier * 1) 0 0 -nr 1 0 0 -r 1 -sw 150;
		rotate -r -os -75 0 0 ($modCore + "_Clavicle_Ctrl") ($modCore + "_Clavicle_Ctrl2");		
		makeIdentity -apply true -r 1 ($modCore + "_Clavicle_Ctrl") ($modCore + "_Clavicle_Ctrl2");
		move -r - 0 0.5 0 ($modCore + "_Clavicle_Ctrl.cv[0:10]") ($modCore + "_Clavicle_Ctrl2.cv[0:10]");
		curve -n ($modCore + "_Clavicle_Ctrl3") -d 1 -p 0 0.758819 0.965926 -p ($multiplier * 1) 0.758819 0.965926 -k 0 -k 1 ;
		rename `listRelatives ($modCore + "_Clavicle_Ctrl3")` ($modCore + "_Clavicle_Ctrl3Shape");
		curve -n ($modCore + "_Clavicle_Ctrl4") -d 1 -p 0 0.758819 -0.965926 -p ($multiplier * 1) 0.758819 -0.965926 -k 0 -k 1 ;
		rename `listRelatives ($modCore + "_Clavicle_Ctrl4")` ($modCore + "_Clavicle_Ctrl4Shape");
		curve -n ($modCore + "_Clavicle_Ctrl5") -d 1 -p 0 1.5 0 -p ($multiplier * 1) 1.5 0 -k 0 -k 1 ;
		rename `listRelatives ($modCore + "_Clavicle_Ctrl5")` ($modCore + "_Clavicle_Ctrl5Shape");
		
		parent -r -s ($modCore + "_Clavicle_Ctrl2Shape") ($modCore + "_Clavicle_Ctrl3Shape") ($modCore + "_Clavicle_Ctrl4Shape") ($modCore + "_Clavicle_Ctrl5Shape") ($modCore + "_Clavicle_Ctrl");
		delete ($modCore + "_Clavicle_Ctrl2") ($modCore + "_Clavicle_Ctrl3") ($modCore + "_Clavicle_Ctrl4") ($modCore + "_Clavicle_Ctrl5"); 
		group -n ($modCore + "_Clavicle_CtrlGrp") ($modCore + "_Clavicle_Ctrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_Clavicle_CtrlGrp.rotateOrder") 1;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_Clavicle_CtrlGrp")`;
    
		if ($crntSide == "right" && $behavior == 0)
		{
			$rz = `getAttr ($modCore + "_Clavicle_CtrlGrp.rz")`;
			rotate -r -os 180 0 ($rz * -1) ($modCore + "_Clavicle_CtrlGrp");
			rotate -r -os 180 0 ($rz * -1) ($modCore + "_Clavicle_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_Clavicle_Ctrl");
		}
			
		setAttr (($modCore + "_Clavicle_CtrlGrp.scale"), (($ShoulderLength[0]) * 1), (($ArmLength/2) * .9), (($ArmLength/2) * .9));
		
		makeIdentity -apply true -t 0 -s 1 ($modCore + "_Clavicle_CtrlGrp");
		
		//SHOULDER FK CONTROL
		RRM_BasicControl(($modCore + "_ShoulderFk_Ctrl"), "x", ($ArmLength/3), 1, ($elbowLength[0] * $multiplier));
		rotate -r -90 0 0 ($modCore + "_ShoulderFk_Ctrl");
		makeIdentity -apply true -r 1 ($modCore + "_ShoulderFk_Ctrl");
		setAttr ($modCore + "_ShoulderFk_Ctrl.rotateOrder") 1;
		group -n ($modCore + "_ShoulderFk_CtrlGrp") ($modCore + "_ShoulderFk_Ctrl"); xform -os -piv 0 0 0; 
		group -n ($modCore + "_ShoulderFk_CtrlGrp2") ($modCore + "_ShoulderFk_CtrlGrp"); xform -os -piv 0 0 0; 
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_ShoulderFk_CtrlGrp2")`;

		float $upVector = 1;
		float $elbowLocCheck;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			$elbowLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Elbow.translateZ")`;
		}
		else
		{
			$elbowLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Elbow1.translateZ")`;
		}
		if ($elbowLocCheck > 0.0001)
		{
			$upVector = -1;
		}
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "objectrotation" -worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow")
			("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ShoulderFk_CtrlGrp2")`;
		}
		else
		{
			delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "objectrotation" -worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow1")
			("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_ShoulderFk_CtrlGrp2")`;
		}
		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 180 0 0 ($modCore + "_ShoulderFk_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_ShoulderFk_Ctrl");
		}		
	
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_ShoulderFk_Ctrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_ShoulderFk_Ctrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_ShoulderFk_Ctrl");
			
		//ELBOW FK CONTROL
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			RRM_BasicControl(($modCore + "_ElbowFk_Ctrl"), "x", ($ArmLength/3), 1, ($wristLength[0] * $multiplier));
			rotate -r ($multiplier * -90) 0 0 ($modCore + "_ElbowFk_Ctrl");
			if ($crntSide == "right" && $behavior == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_ElbowFk_Ctrl");
			}
			makeIdentity -apply true -r 1 ($modCore + "_ElbowFk_Ctrl");
			group -n ($modCore + "_ElbowFk_CtrlGrp") ($modCore + "_ElbowFk_Ctrl"); xform -os -piv 0 0 0;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ElbowFk_CtrlGrp")`;
			delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_ElbowFk_CtrlGrp")`;
		}
		else
		{
			RRM_BasicControl(($modCore + "_Elbow1Fk_Ctrl"), "x", ($ArmLength/3), 1, ($elbow2Length[0] * $multiplier));
			rotate -r ($multiplier * -90) 0 0 ($modCore + "_Elbow1Fk_Ctrl");
			if ($crntSide == "right" && $behavior == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_Elbow1Fk_Ctrl");
			}
			makeIdentity -apply true -r 1 ($modCore + "_Elbow1Fk_Ctrl");
			group -n ($modCore + "_Elbow1Fk_CtrlGrp") ($modCore + "_Elbow1Fk_Ctrl"); xform -os -piv 0 0 0;

			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_Elbow1Fk_CtrlGrp")`;
			delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow1")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_Elbow1Fk_CtrlGrp")`;

			scale -r-os 0.8 0.8 0.8 ($modCore + "_Elbow1Fk_CtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Elbow1Fk_CtrlGrp");
			
			RRM_BasicControl(($modCore + "_Elbow2Fk_Ctrl"), "x", ($ArmLength/3), 1, ($wristLength[0] * $multiplier));
			rotate -r ($multiplier * -90) 0 0 ($modCore + "_Elbow2Fk_Ctrl");
			if ($crntSide == "right" && $behavior == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_Elbow2Fk_Ctrl");
			}
			makeIdentity -apply true -r 1 ($modCore + "_Elbow2Fk_Ctrl");
			group -n ($modCore + "_Elbow2Fk_CtrlGrp") ($modCore + "_Elbow2Fk_Ctrl"); xform -os -piv 0 0 0;

			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_Elbow2Fk_CtrlGrp")`;
			delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_Elbow2Fk_CtrlGrp")`;
		}

		//WRIST FK CONTROL
		RRM_BasicControl(($modCore + "_WristFk_Ctrl"), "x", ($ArmLength/3), 0, $multiplier);
		rotate -r ($multiplier * -90) 0 0 ($modCore + "_WristFk_Ctrl");
		if ($crntSide == "right" && $behavior == 1)
		{
			rotate -r -os 180 0 0 ($modCore + "_WristFk_Ctrl");
		}
		makeIdentity -apply true -r 1 ($modCore + "_WristFk_Ctrl");
		group -n ($modCore + "_WristFk_CtrlGrp") ($modCore + "_WristFk_Ctrl"); xform -os -piv 0 0 0;

		delete `parentConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_WristFk_CtrlGrp")`;
		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 180 0 0 ($modCore + "_WristFk_CtrlGrp");
		}	
		//scale -r 0.8 0.8 0.8 ($modCore + "_WristFk_CtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_WristFk_CtrlGrp");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_WristFk_Ctrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_WristFk_Ctrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_WristFk_Ctrl");
	
	
		//////////////////////JOINTS//////////////////////
		select -cl;
		joint -n ($modCore + "_ClavicleJnt");
		setAttr ($modCore + "_ClavicleJnt.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_Clavicle_Ctrl") ($modCore + "_ClavicleJnt")`;
		
		select -cl;
		joint -n ($modCore + "_ShoulderJnt");
		setAttr ($modCore + "_ShoulderJnt.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ShoulderJnt")`;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -cl;
			joint -n ($modCore + "_ElbowJnt");
			setAttr ($modCore + "_ElbowJnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_ElbowFk_Ctrl") ($modCore + "_ElbowJnt")`;
		
			select -cl;
			joint -n ($modCore + "_WristJnt");
			setAttr ($modCore + "_WristJnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_WristFk_Ctrl") ($modCore + "_WristJnt")`;
			select -cl;
			joint -n ($modCore + "_WristJntDummy");
			setAttr ($modCore + "_WristJntDummy.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_WristFk_Ctrl") ($modCore + "_WristJntDummy")`;
			//if ($crntSide == "right")
			//{
			//	select "break";
			//}
			makeIdentity -apply true -r 1 ($modCore + "_ClavicleJnt") ($modCore + "_ShoulderJnt")
			($modCore + "_ElbowJnt") ($modCore + "_WristJnt") ($modCore + "_WristJntDummy");
			
			parent ($modCore + "_ShoulderJnt") ($modCore + "_ClavicleJnt");
			parent ($modCore + "_ElbowJnt") ($modCore + "_ShoulderJnt");
			parent ($modCore + "_WristJntDummy") ($modCore + "_ElbowJnt");
			//if ($crntSide == "right")
			//{
			//	select "break";
			//}
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_Elbow1Jnt");
			setAttr ($modCore + "_Elbow1Jnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_Elbow1Fk_Ctrl") ($modCore + "_Elbow1Jnt")`;
		
			select -cl;
			joint -n ($modCore + "_Elbow2Jnt");
			setAttr ($modCore + "_Elbow2Jnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_Elbow2Fk_Ctrl") ($modCore + "_Elbow2Jnt")`;
	
			select -cl;
			joint -n ($modCore + "_WristJnt");
			setAttr ($modCore + "_WristJnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_WristFk_Ctrl") ($modCore + "_WristJnt")`;
			select -cl;
			joint -n ($modCore + "_WristJntDummy");
			setAttr ($modCore + "_WristJntDummy.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_WristFk_Ctrl") ($modCore + "_WristJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_ClavicleJnt") ($modCore + "_ShoulderJnt")
			($modCore + "_Elbow1Jnt") ($modCore + "_Elbow2Jnt") ($modCore + "_WristJnt") ($modCore + "_WristJntDummy");
			//if ($crntSide == "right")
			//{
			//	select "break";
			//}	
			parent ($modCore + "_ShoulderJnt") ($modCore + "_ClavicleJnt");
			parent ($modCore + "_Elbow1Jnt") ($modCore + "_ShoulderJnt");
			parent ($modCore + "_Elbow2Jnt") ($modCore + "_Elbow1Jnt"); 
			//parent ($modCore + "_WristJnt") ($modCore + "_Elbow2Jnt");
			parent ($modCore + "_WristJntDummy") ($modCore + "_Elbow2Jnt");
		}
		//HIDE WRIST DUMMY 
		setAttr ($modCore + "_WristJntDummy.v") 0;
		//ELBOW ORIENTATION
		if (`objExists ($modCore + "_ElbowJnt")`)
		{
			if ($elbowLocCheck > 0.0001)
			{
				setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * $behaviorMultiplier * 60);
				//setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * 60);
			}
			else
			{
				setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * $behaviorMultiplier * -60);
				//setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * -60);
			}
			group -em -n ($modCore + "_WristJntGrp1");
			setAttr ($modCore + "_WristJntGrp1.rotateOrder") 1;
			pointConstraint ($modCore + "_WristJntDummy") ($modCore + "_WristJntGrp1");
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1")`;
			//if ($crntSide == "right" && $behavior == 0)
			//{
			//	$rz = `getAttr ($modCore + "_WristJntGrp1.rz")`;
			//	rotate -r -os 180 0 ($rz * -1) ($modCore + "_WristJntGrp1");
			//}

			group -em -n ($modCore + "_WristJntGrp2") ;
			setAttr ($modCore + "_WristJntGrp2.rotateOrder") 1;
			delete `pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_WristJntGrp2")`;
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp2")`;	
			parentConstraint -mo ($modCore + "_ElbowJnt") ($modCore + "_WristJntGrp2");
			//if ($crntSide == "right")
			//{
			//	select "break";
			//}
		}
		else
		{
			if ($elbowLocCheck > 0.0001)
			{
				//setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * $behaviorMultiplier * 30);
				setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * 30);
			}
			else
			{
				//setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * $behaviorMultiplier * -30);
				setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * -30);
			}
			group -em -n ($modCore + "_WristJntGrp1");
			setAttr ($modCore + "_WristJntGrp1.rotateOrder") 1;
			pointConstraint ($modCore + "_WristJntDummy") ($modCore + "_WristJntGrp1");
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1")`;
			group -em -n ($modCore + "_WristJntGrp2") ;
			setAttr ($modCore + "_WristJntGrp2.rotateOrder") 1;
			delete `pointConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_WristJntGrp2")`;
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp2")`;	
			parentConstraint -mo ($modCore + "_Elbow2Jnt") ($modCore + "_WristJntGrp2");
		}
		//if ($crntSide == "right" && $behavior == 0)
		//{	
		//	select "break";
		//}	
		parent ($modCore + "_WristJntGrp1") ($modCore + "_WristJntGrp2");
		parent ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1");	
	
		
		
		////////////////////Ik/Fk JOINTS////////////////////////////////////	
		//ARM Fk
		duplicate -n ($modCore + "_ShoulderJntFk") ($modCore + "_ShoulderJnt");
		select ($modCore + "_ShoulderJntFk");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			rename ($modCore + "_ElbowJntFk");
			pickWalk -d down;
			rename ($modCore + "_WristJntFk");
		}
		else
		{
			rename ($modCore + "_Elbow1JntFk");
			pickWalk -d down;
			rename ($modCore + "_Elbow2JntFk");
			pickWalk -d down;
			rename ($modCore + "_WristJntFk");
		}
		
		//ARM Ik
		duplicate -n ($modCore + "_ShoulderJntIk") ($modCore + "_ShoulderJnt");
		select ($modCore + "_ShoulderJntIk");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			rename ($modCore + "_ElbowJntIk");
			pickWalk -d down;
			rename ($modCore + "_WristJntIk");
		}
		else
		{
			rename ($modCore + "_Elbow1JntIk");
			pickWalk -d down;
			rename ($modCore + "_Elbow2JntIk");
			pickWalk -d down;
			rename ($modCore + "_WristJntIk");
		}	
	
		//DETACH Fk ARM JOINTS FOR SCALE COMPENSATION
	
		parent -w ($modCore + "_WristJntFk");
		group -n ($modCore + "_WristJntFkGrp1") ($modCore + "_WristJntFk"); xform -os -piv 0 0 0; 
		group -n ($modCore + "_WristJntFkGrp2") ($modCore + "_WristJntFkGrp1"); xform -os -piv 0 0 0; 
		//$WristLocation = `xform -q -ws -t ($modCore + "_WristJnt")`;
		//move $WristLocation[0] $WristLocation[1] $WristLocation[2] ($modCore + "_WristJntFkGrp2.scalePivot") ($modCore + "_WristJntFkGrp2.rotatePivot") ;
		//pointConstraint ($modCore + "_WristFk_Ctrl") ($modCore + "_WristJntFkGrp1");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ElbowJntFk") ($modCore + "_WristJntFkGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Elbow2JntFk") ($modCore + "_WristJntFkGrp2");
		}
			
		$elbowLocation = `xform -q -ws -t ($modCore + "_ShoulderJnt")`;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parent -w ($modCore + "_ElbowJntFk");// ($modCore + "_WristJntFk");
			group -n ($modCore + "_ElbowJntFkGrp1") ($modCore + "_ElbowJntFk");
			group -n ($modCore + "_ElbowJntFkGrp2") ($modCore + "_ElbowJntFkGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_ElbowJnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_ElbowJntFkGrp1.scalePivot") ($modCore + "_ElbowJntFkGrp1.rotatePivot") ;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_ElbowJntFkGrp2.scalePivot") ($modCore + "_ElbowJntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_ElbowFk_Ctrl") ($modCore + "_ElbowJntFkGrp1");
			parentConstraint -mo ($modCore + "_ShoulderJntFk") ($modCore + "_ElbowJntFkGrp2");
		}
		else
		{
			parent -w ($modCore + "_Elbow1JntFk") ($modCore + "_Elbow2JntFk");// ($modCore + "_WristJntFk");
			
			group -n ($modCore + "_Elbow1JntFkGrp1") ($modCore + "_Elbow1JntFk");
			group -n ($modCore + "_Elbow1JntFkGrp2") ($modCore + "_Elbow1JntFkGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_Elbow1Jnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_Elbow1JntFkGrp2.scalePivot") ($modCore + "_Elbow1JntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Elbow1Fk_Ctrl") ($modCore + "_Elbow1JntFkGrp1");
			parentConstraint -mo ($modCore + "_ShoulderJntFk") ($modCore + "_Elbow1JntFkGrp2");
	
			group -n ($modCore + "_Elbow2JntFkGrp1") ($modCore + "_Elbow2JntFk");
			group -n ($modCore + "_Elbow2JntFkGrp2") ($modCore + "_Elbow2JntFkGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_Elbow2Jnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_Elbow1JntFkGrp2.scalePivot") ($modCore + "_Elbow1JntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Elbow2Fk_Ctrl") ($modCore + "_Elbow2JntFkGrp1");
			parentConstraint -mo ($modCore + "_Elbow1JntFk") ($modCore + "_Elbow2JntFkGrp2");
		}
	
		//Ik CONTROLS///////////////////////////////////////////////////////////////

		//SCALE CONTROL
		spaceLocator -n ($modCore + "_armLengthAimLctr");
		spaceLocator -n ($modCore + "_armLengthTargetLctr");
		parent ($modCore + "_armLengthTargetLctr") ($modCore + "_armLengthAimLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_armLengthAimLctr");
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_armLengthAimLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_armLengthTargetLctr");
		$armLength = `getAttr ($modCore + "_armLengthTargetLctr.tx")`;
		delete ($modCore + "_armLengthAimLctr");

		curve -n ($modCore + "_WristIk_Ctrl") -d 1 -p 1 -1 -1 -p 1 1 -1 -p 1 1 1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 -1 1 -p 1 -1 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		rename `listRelatives -c ($modCore + "_WristIk_Ctrl")` ($modCore + "_WristIk_CtrlShape");
		curve -n ($modCore + "_WristIk_Ctrl1") -d 1 -p 1 1 -1 -p -1 1 -1 -p -1 -1 -1 -k 0 -k 1 -k 2 ;
		rename `listRelatives -c ($modCore + "_WristIk_Ctrl1")` ($modCore + "_WristIk_Ctrl1Shape");
		curve -n ($modCore + "_WristIk_Ctrl2") -d 1 -p 1 1 1 -p -1 1 1 -p -1 -1 1 -k 0 -k 1 -k 2 ;
		rename `listRelatives -c ($modCore + "_WristIk_Ctrl2")` ($modCore + "_WristIk_Ctrl2Shape");
		curve -n ($modCore + "_WristIk_Ctrl3") -d 1 -p -1 1 1 -p -1 1 -1 -k 0 -k 1 ;
		rename `listRelatives -c ($modCore + "_WristIk_Ctrl3")` ($modCore + "_WristIk_Ctrl3Shape");
		parent -r -s ($modCore + "_WristIk_Ctrl1Shape") ($modCore + "_WristIk_Ctrl2Shape") ($modCore + "_WristIk_Ctrl3Shape") ($modCore + "_WristIk_Ctrl");
		delete ($modCore + "_WristIk_Ctrl1") ($modCore + "_WristIk_Ctrl2") ($modCore + "_WristIk_Ctrl3");

		scale -r ($armLength/10) ($armLength/10) ($armLength/10) ($modCore + "_WristIk_Ctrl");
		makeIdentity -apply true -s 1 ($modCore + "_WristIk_Ctrl");

		
		group -n ($modCore + "_WristIk_CtrlGrp") ($modCore + "_WristIk_Ctrl"); xform -os -piv 0 0 0;
		delete `parentConstraint ($modCore + "_WristJnt") ($modCore + "_WristIk_CtrlGrp")`;
		if ($crntSide == "right" && $behavior == 0)
		{
			//$rz = `getAttr ($modCore + "_WristIk_CtrlGrp.rz")`;
			//rotate -r -os 180 0 ($rz * -1) ($modCore + "_WristIk_CtrlGrp");
			rotate -r -os 180 0 0 ($modCore + "_WristIk_CtrlGrp");
		}

		//WRIST PIVOT CONTROL
		RRM_MoveablePivot_Ctrl(($modCore + "_WristPivot_Ctrl"), ($armLength/8));
		delete `parentConstraint ($modCore + "_WristIk_Ctrl") ($modCore + "_WristPivot_CtrlGrp")`;
		parent ($modCore + "_WristPivot_CtrlGrp") ($modCore + "_WristIk_Ctrl");
		
		addAttr -ln "wristPivot_CtrlVis" -at bool ($modCore + "_WristIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_WristIk_Ctrl.wristPivot_CtrlVis");
		setAttr ($modCore + "_WristIk_Ctrl.wristPivot_CtrlVis") 0;
		for ($shape in `listRelatives -c -type "nurbsCurve" ($modCore + "_WristPivot_Ctrl")`)
		{
			connectAttr -f ($modCore + "_WristIk_Ctrl.wristPivot_CtrlVis") ($shape + ".v");
		}
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.sz");
		spaceLocator -n ($modCore + "_WristPivot_Lctr");
		delete `parentConstraint ($modCore + "_WristPivot_Ctrl") ($modCore + "_WristPivot_Lctr")`;
		parent ($modCore + "_WristPivot_Lctr") ($modCore + "_WristPivot_Ctrl");
		
		//CREATE OFFSETTING VALUES ON PARENT CTRL GRP
		shadingNode -asUtility multiplyDivide -n ($modCore + "_WristPivot_MD");
		connectAttr -f ($modCore + "_WristPivot_Ctrl.translate") ($modCore + "_WristPivot_MD.input1");
		setAttr (($modCore + "_WristPivot_MD.input2"), -1, -1, -1);
		connectAttr -f ($modCore + "_WristPivot_MD.output") ($modCore + "_WristPivot_Lctr.translate");
		setAttr ($modCore + "_WristPivot_Lctr.v") 0;
		
		
		//ELBOW Ik CONTROL
		if ($ea == 0)
		{
			curve -n ($modCore + "_ElbowIk_Ctrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
			-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
			-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
			-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
			-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
			-k 23 -k 24 ;
			rename `listRelatives -c ($modCore + "_ElbowIk_Ctrl")` ($modCore + "_ElbowIk_CtrlShape");
			
			move -r 0 0 0.95 ($modCore + "_ElbowIk_Ctrl.cv[12]") ($modCore + "_ElbowIk_Ctrl.cv[0]") ($modCore + "_ElbowIk_Ctrl.cv[24]") ($modCore + "_ElbowIk_Ctrl.cv[18]") ($modCore + "_ElbowIk_Ctrl.cv[6]") ;
			move -r 0 0 -0.65 ($modCore + "_ElbowIk_Ctrl.cv[3]") ($modCore + "_ElbowIk_Ctrl.cv[9]") ($modCore + "_ElbowIk_Ctrl.cv[15]") ($modCore + "_ElbowIk_Ctrl.cv[21]") ;

			scale -r -os 0.75 0.75 0.75 ($modCore + "_ElbowIk_Ctrl");
			makeIdentity -apply 1 -s 1 ($modCore + "_ElbowIk_Ctrl");
		}
		else
		{
			curve -n ($modCore + "_ElbowIk_Ctrl") -d 1 -p 1 -1 -1 -p 1 1 -1 -p 1 1 1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 -1 1 -p 1 -1 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			rename `listRelatives -c ($modCore + "_ElbowIk_Ctrl")` ($modCore + "_ElbowIk_CtrlShape");
			curve -n ($modCore + "_ElbowIk_Ctrl1") -d 1 -p 1 1 -1 -p -1 1 -1 -p -1 -1 -1 -k 0 -k 1 -k 2 ;
			rename `listRelatives -c ($modCore + "_ElbowIk_Ctrl1")` ($modCore + "_ElbowIk_Ctrl1Shape");
			curve -n ($modCore + "_ElbowIk_Ctrl2") -d 1 -p 1 1 1 -p -1 1 1 -p -1 -1 1 -k 0 -k 1 -k 2 ;
			rename `listRelatives -c ($modCore + "_ElbowIk_Ctrl2")` ($modCore + "_ElbowIk_Ctrl2Shape");
			curve -n ($modCore + "_ElbowIk_Ctrl3") -d 1 -p -1 1 1 -p -1 1 -1 -k 0 -k 1 ;
			rename `listRelatives -c ($modCore + "_ElbowIk_Ctrl3")` ($modCore + "_ElbowIk_Ctrl3Shape");
			parent -r -s ($modCore + "_ElbowIk_Ctrl1Shape") ($modCore + "_ElbowIk_Ctrl2Shape") ($modCore + "_ElbowIk_Ctrl3Shape") ($modCore + "_ElbowIk_Ctrl");
			delete ($modCore + "_ElbowIk_Ctrl1") ($modCore + "_ElbowIk_Ctrl2") ($modCore + "_ElbowIk_Ctrl3");
		}
		group -n ($modCore + "_ElbowIk_CtrlGrp") ($modCore + "_ElbowIk_Ctrl"); xform -os -piv 0 0 0;
		
		
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ElbowIk_CtrlGrp")`;
			setAttr (($modCore + "_ElbowIk_CtrlGrp.scale"), ($ArmLength / 12), ($ArmLength / 12), ($ArmLength / 12));
			//setAttr ($modCore + "_ElbowIk_CtrlGrp.tz") ($ArmLength * -2);
			move -r -os -wd 0 0 ($ArmLength * -1.2) ($modCore + "_ElbowIk_CtrlGrp");
			
			makeIdentity -apply true -t 0 -r 0 -s 1 ($modCore + "_ElbowIk_CtrlGrp");
		}
		else
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_ElbowIk_CtrlGrp")`;
			setAttr (($modCore + "_ElbowIk_CtrlGrp.scale"), ($ArmLength / 12), ($ArmLength / 12), ($ArmLength / 12));
			//setAttr ($modCore + "_ElbowIk_CtrlGrp.tz") ($ArmLength * -2);
			move -r -os -wd 0 0 ($ArmLength * -1.2) ($modCore + "_ElbowIk_CtrlGrp");
			
			makeIdentity -apply true -t 0 -r 0 -s 1 ($modCore + "_ElbowIk_CtrlGrp");
		}
		//select "break";
		//LOWER ARM CONTROL
		if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			curve -n ($modCore + "_LowerArmIk_Ctrl") -d 1 -p -1 0 4 -p -4 0 4 -p -3 0 5 -p -2 0 6 -p -1 0 7 -p 0 0 8 -p 1 0 7 -p 2 0 6 -p 3 0 5 -p 4 0 4 -p 1 0 4 -p 1 0 3 -p 1 0 2 -p 1 0 1 -p 1 0 0 -p 1 0 -1 -p 1 0 -2 -p 1 0 -3 -p 1 0 -4 -p 4 0 -4 -p 3 0 -5 -p 2 0 -6 -p 1 0 -7 -p 0 0 -8 -p -1 0 -7 -p -2 0 -6 -p -3 0 -5 -p -4 0 -4 -p -1 0 -4 -p -1 0 -3 -p -1 0 -2 -p -1 0 -1 -p -1 0 0 -p -1 0 1 -p -1 0 2 -p -1 0 3 -p -1 0 4 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 ;
			rename `listRelatives -c ($modCore + "_LowerArmIk_Ctrl")` ($modCore + "_LowerArmIk_CtrlShape");
			nonLinear -type bend -lowBound -1 -highBound 1 -curvature 0.6;
			$bend = `ls -sl`;
			rename $bend ($modCore + "_LowerArmIkCBend");
			rotate -a -os -90 0 -90 ($modCore + "_LowerArmIkCBend");
	
			rotate 0 0 90 ($modCore + "_LowerArmIk_Ctrl");
			setAttr (($modCore + "_LowerArmIk_Ctrl.scale"), ($ArmLength/14), ($ArmLength/14), ($ArmLength/14));
			makeIdentity -apply true -r 1 -s 1 ($modCore + "_LowerArmIk_Ctrl");
			delete -ch ($modCore + "_LowerArmIk_Ctrl");
	
			group -n ($modCore + "_LowerArmIk_CtrlGrp") ($modCore + "_LowerArmIk_Ctrl");
			group -n ($modCore + "_LowerArmIk_CtrlGrp2") ($modCore + "_LowerArmIk_CtrlGrp");
			parent ($modCore + "_LowerArmIk_CtrlGrp2") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerArmIk_CtrlGrp.rotateOrder") 1;
			setAttr ($modCore + "_LowerArmIk_CtrlGrp2.rotateOrder") 1;
	
			spaceLocator -n ($modCore + "_lowerArmIkLctr");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_lowerArmIkLctr")`;
			parent ($modCore + "_lowerArmIkLctr") ($modCore + "_ShoulderFk_Ctrl");
			setAttr ($modCore + "_lowerArmIkLctr.v") 0;
			
			delete `pointConstraint ($modCore + "_WristIk_Ctrl") ($modCore + "_LowerArmIk_CtrlGrp2")`;
			//ALIGN GROUP
			delete `aimConstraint -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIk_CtrlGrp2")`;
			//AIM CONSTRAIN GROUP WITH OFFSET
			aimConstraint -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_WristPivot_Ctrl")
			($modCore + "_lowerArmIkLctr") ($modCore + "_LowerArmIk_CtrlGrp2");
			delete `aimConstraint -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIk_CtrlGrp")`;
			pointConstraint -mo ($modCore + "_WristPivot_Ctrl") ($modCore + "_LowerArmIk_CtrlGrp2");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIk_Ctrl")`;
			$WristPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Wrist")`;
			move -a $WristPos[0] $WristPos[1] $WristPos[2] ($modCore + "_LowerArmIk_Ctrl.scalePivot") ($modCore + "_LowerArmIk_Ctrl.rotatePivot") ;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_LowerArmIk_Ctrl");
			
			//ADD ORIENTATION ATTRIBUTE FOR LOWER LEG Ik_Ctrl ORIENTATION
			spaceLocator -n ($modCore + "_LowerArmIk_CtrlGrp2_LctrOffset");
			delete `parentConstraint ($modCore + "_LowerArmIk_CtrlGrp2") ($modCore + "_LowerArmIk_CtrlGrp2_LctrOffset")`;
			parentConstraint -mo ($modCore + "_WristPivot_Ctrl") ($modCore + "_LowerArmIk_CtrlGrp2_LctrOffset");
			
			orientConstraint -mo ($modCore + "_LowerArmIk_CtrlGrp2") ($modCore + "_LowerArmIk_CtrlGrp2_LctrOffset") ($modCore + "_LowerArmIk_CtrlGrp");
			parent ($modCore + "_LowerArmIk_CtrlGrp2_LctrOffset") ($modCore + "_WristPivot_Ctrl");
			
			addAttr -ln "autoOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_LowerArmIk_Ctrl");
			setAttr -e -k 1 ($modCore + "_LowerArmIk_Ctrl.autoOrient");
			connectAttr -f ($modCore + "_LowerArmIk_Ctrl.autoOrient") ($modCore + "_LowerArmIk_CtrlGrp_orientConstraint1." + $modCore + "_LowerArmIk_CtrlGrp2W0");
			
			shadingNode -asUtility reverse -n ($modCore + "_LowerArmIk_Ctrl_Reverse");
			connectAttr -f ($modCore + "_LowerArmIk_Ctrl.autoOrient") ($modCore + "_LowerArmIk_Ctrl_Reverse.inputX");
			connectAttr -f ($modCore + "_LowerArmIk_Ctrl_Reverse.outputX") ($modCore + "_LowerArmIk_CtrlGrp_orientConstraint1." + $modCore + "_LowerArmIk_CtrlGrp2_LctrOffsetW1");
			setAttr ($modCore + "_LowerArmIk_CtrlGrp2_LctrOffset.v") 0;
			
			spaceLocator -n ($modCore + "_Lower_ElbowIkOffsetLctr");
			delete `pointConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_Lower_ElbowIkOffsetLctr")`;
			
		}
	
	
		//Ik SCALE
		
		//CREATE DUMMY WRIST JOINT
		select ($modCore + "_WristJntIk");
		duplicate -n ($modCore + "_WristJntIkDummy");
		parent -w;
		group -n ($modCore + "_WristJntIkDummyGrp1");
		group -n ($modCore + "_WristJntIkDummyGrp2");
		
		move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_WristJntIkDummyGrp2.scalePivot") ($modCore + "_WristJntIkDummyGrp2.rotatePivot") ;
		pointConstraint ($modCore + "_WristJntIk") ($modCore + "_WristJntIkDummyGrp1");
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + "_WristPivot_Ctrl") ($modCore + "_WristJntIkDummy");
		setAttr ($modCore + "_WristJntIkDummy_parentConstraint1.interpType") 2;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ElbowJntIk") ($modCore + "_WristJntIkDummyGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Elbow2JntIk") ($modCore + "_WristJntIkDummyGrp2");
		}
		
		RRM_LimbStretch($modRigName, $rigGrp, "arm", $prfx, $oppPrfx, $crntSide, $oppSide, $behavior, $behaviorMultiplier, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode, $lPrfx, $rPrfx, $ea);

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		
		////////////////////////////////////SIDE////////////////////////////////////
		//ARM
		parentConstraint -mo ($modCore + "_ScaleGrp") ($modCore + "_Clavicle_CtrlGrp");
		
		//Fk
		parentConstraint -mo ($modCore + "_Clavicle_Ctrl") ($modCore + "_ClavicleJnt");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_Clavicle_Ctrl") ($modCore + "_ShoulderFk_CtrlGrp");
		if ($modAttachNode != "ROOT")
		{
			parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
			($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_Clavicle_Ctrl") ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_ShoulderFk_CtrlGrp2");
		}
		else
		{
			parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
			($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_Clavicle_Ctrl") ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_ShoulderFk_CtrlGrp2");
		}
		setAttr ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1.interpType") 2;
		
		//SHOULDER ORIENT
		addAttr -ln "shoulderOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_ShoulderFk_Ctrl");
		setAttr -e -k 1 ($modCore + "_ShoulderFk_Ctrl.shoulderOrient");
	
		addAttr -ln "alwaysVisible" -at bool -min 0 -max 1 -dv 0 ($modCore + "_ShoulderFk_Ctrl");
		setAttr -e -k 1 ($modCore + "_ShoulderFk_Ctrl.alwaysVisible");

		setAttr ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW2") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFk_Ctrl.shoulderOrient") ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW2");
		setAttr ($modCore + "_ShoulderFk_Ctrl.shoulderOrient") 0;
		setAttr ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFk_Ctrl.shoulderOrient") ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW2");
		setAttr ($modCore + "_ShoulderFk_Ctrl.shoulderOrient") 1;
		
		
		
		//CHEST & CLAVICLE INFLUENCE
		addAttr -ln "clavicleInfluence" -at double -min 0 -max 1 -dv 0 ($modCore + "_ShoulderFk_Ctrl");
		setAttr -e -k 1 ($modCore + "_ShoulderFk_Ctrl.clavicleInfluence");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderFk_Inf_MD");
		connectAttr -force ($modCore + "_ShoulderFk_Ctrl.clavicleInfluence") ($modCore + "_ShoulderFk_Inf_MD.input1Y");
		setAttr ($modCore + "_ShoulderFk_Inf_MD.input1X") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFk_Ctrl.clavicleInfluence") ($modCore + "_ShoulderFk_Inf_MD.input1X");
		setAttr ($modCore + "_ShoulderFk_Ctrl.clavicleInfluence") 1;
		setAttr ($modCore + "_ShoulderFk_Inf_MD.input1X") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFk_Ctrl.clavicleInfluence") ($modCore + "_ShoulderFk_Inf_MD.input1X");
		setAttr ($modCore + "_ShoulderFk_Ctrl.clavicleInfluence") 0;
		
		connectAttr -force ($modCore + "_ShoulderFk_Ctrl.shoulderOrient") ($modCore + "_ShoulderFk_Inf_MD.input2X");
		connectAttr -force ($modCore + "_ShoulderFk_Ctrl.shoulderOrient") ($modCore + "_ShoulderFk_Inf_MD.input2Y");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -force ($modCore + "_ShoulderFk_Inf_MD.outputX") ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW0");
		}
		else
		{
			connectAttr -force ($modCore + "_ShoulderFk_Inf_MD.outputX") ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0");
		}
		connectAttr -force ($modCore + "_ShoulderFk_Inf_MD.outputY") ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1." + $modCore + "_Clavicle_CtrlW1");
		
		//selectKey -k -f 0 -f 1 ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1_" + $modRigName + "MAIN_Inner_CtrlW2") ;
		//selectKey -add -k -f 0 -f 1 ($modCore + "_ShoulderFk_Inf_MD_input1X") ;
		keyTangent -itt spline -ott spline ($modCore + "_ShoulderFk_CtrlGrp2_parentConstraint1_" + $modRigName + "MAIN_Inner_CtrlW2") ($modCore + "_ShoulderFk_Inf_MD_input1X");

		parentConstraint -mo ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ShoulderJntFk");
		pointConstraint -mo ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ShoulderJnt");
		pointConstraint -mo ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ShoulderJntIk");
	
		connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_ShoulderJntFk.scaleX");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ElbowFk_CtrlGrp");
		
			parentConstraint -mo ($modCore + "_ElbowFk_Ctrl") ($modCore + "_ElbowJntFk");
			parentConstraint -mo ($modCore + "_ElbowFk_Ctrl") ($modCore + "_WristFk_CtrlGrp");

			connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_ElbowFk_Ctrl.scaleX");
		}
		else
		{
			parentConstraint -mo ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_Elbow1Fk_CtrlGrp");
		
			parentConstraint -mo ($modCore + "_Elbow1Fk_Ctrl") ($modCore + "_Elbow1JntFk");
			parentConstraint -mo ($modCore + "_Elbow1Fk_Ctrl") ($modCore + "_Elbow2Fk_CtrlGrp");
	
			parentConstraint -mo ($modCore + "_Elbow2Fk_Ctrl") ($modCore + "_Elbow2JntFk");
			parentConstraint -mo ($modCore + "_Elbow2Fk_Ctrl") ($modCore + "_WristFk_CtrlGrp");

			connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_Elbow1Fk_Ctrl.scaleX");
			connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_Elbow2Fk_Ctrl.scaleX");
		}		
			
		parentConstraint -mo ($modCore + "_WristFk_Ctrl") ($modCore + "_WristJntFk");
		setAttr ($modCore + "_WristJntFk_parentConstraint1.interpType") 2;
		
		//CONNECT SCALE TO FK CONTROLS
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_ElbowJntFk.scaleX");
		}
		else
		{
			connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_Elbow1JntFk.scaleX");
			connectAttr -f ($modCore + "_ShoulderFk_Ctrl.scaleX") ($modCore + "_Elbow2JntFk.scaleX");
		}
	
		//Ik
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{	
			select ($modCore + "_ShoulderJntIk.rotatePivot") ($modCore + "_WristJntIk.rotatePivot") ;
			ikHandle -n ($modCore + "_ArmIkHandle") -sol ikRPsolver;
			parent ($modCore + "_ArmIkHandle") ($modCore + "_LimbLengthAttachLctr");
		}
		else
		{
			select ($modCore + "_Elbow2JntIk.rotatePivot") ($modCore + "_WristJntIk.rotatePivot");
			ikHandle -n ($modCore + "_LowerArmIkHandle") -sol ikSCsolver;
			parent ($modCore + "_LowerArmIkHandle") ($modCore + "_WristPivot_Ctrl");
			setAttr ($modCore + "_LowerArmIkHandle.v") 0;
	
			select ($modCore + "_ShoulderJntIk.rotatePivot") ($modCore + "_Elbow2JntIk.rotatePivot") ;
			ikHandle -n ($modCore + "_ArmIkHandle") -sol ikRPsolver;
			parent ($modCore + "_ArmIkHandle") ($modCore + "_LimbLengthAttachLctr");
		}
		poleVectorConstraint ($modCore + "_ElbowIk_Ctrl") ($modCore + "_ArmIkHandle") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z -weight 1 ($modCore + "_WristPivot_Ctrl") ($modCore + "_WristJntIk");
		setAttr ($modCore + "_WristJntIk_parentConstraint1.interpType") 2;
	
		//CHECK POLE VECTOR
		if (`objExists ($modCore + "_Elbow1Jnt")`)
		{
			$lSelectionOrient = `getAttr ($modCore + "_ShoulderJntIk.rotate")`;
			if ($lSelectionOrient[0] > 90 || $lSelectionOrient[0] < -90 || $lSelectionOrient[2] > 90 || $lSelectionOrient[2] < -90)
			{
				setAttr ($modCore + "_ArmIkHandle.twist") 180;
			}
				
		}
	
		//CONNECT Ik AND Fk JOINTS TO ORIGINALS
		//SHOULDER
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIkFk_BlndScale");
		connectAttr -f ($modCore + "_ShoulderJntFk.scale") ($modCore + "_ShoulderJntIkFk_BlndScale.color1");
		connectAttr -f ($modCore + "_ShoulderJntIk.scale") ($modCore + "_ShoulderJntIkFk_BlndScale.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ShoulderJntIkFk_BlndScale.blender");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderVolume_MD");
		setAttr ($modCore + "_ShoulderVolume_MD.input1X") 1;
		setAttr ($modCore + "_ShoulderVolume_MD.operation") 2;
		connectAttr -f ($modCore + "_ShoulderJntIkFk_BlndScale.outputR") ($modCore + "_ShoulderVolume_MD.input2X");
		
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIkFk_AutoBlnd");
		setAttr ($modCore + "_ShoulderJntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_ShoulderVolume_MD.outputX") ($modCore + "_ShoulderJntIkFk_AutoBlnd.color1R");
		connectAttr -f ($modCore + "_ShoulderJntIkFk_AutoBlnd.outputR") ($modCore + "_ShoulderJnt.scaleY");
		connectAttr -f ($modCore + "_ShoulderJntIkFk_AutoBlnd.outputR") ($modCore + "_ShoulderJnt.scaleZ");
		connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_ShoulderJntIkFk_AutoBlnd.blender");
		
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIkFk_BlndRotate");
		connectAttr -f ($modCore + "_ShoulderJntFk.rotate") ($modCore + "_ShoulderJntIkFk_BlndRotate.color1");
		connectAttr -f ($modCore + "_ShoulderJntIk.rotate") ($modCore + "_ShoulderJntIkFk_BlndRotate.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ShoulderJntIkFk_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_ShoulderJntIkFk_BlndScale.outputR") ($modCore + "_ShoulderJnt.scaleX");
		connectAttr -f ($modCore + "_ShoulderJntIkFk_BlndRotate.output") ($modCore + "_ShoulderJnt.rotate");
		
		
		//ELBOW
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIkFk_BlndScale");
			connectAttr -f ($modCore + "_ElbowJntFk.scale") ($modCore + "_ElbowJntIkFk_BlndScale.color1");
			connectAttr -f ($modCore + "_ElbowJntIk.scale") ($modCore + "_ElbowJntIkFk_BlndScale.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ElbowJntIkFk_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ElbowVolume_MD");
			setAttr ($modCore + "_ElbowVolume_MD.input1X") 1;
			setAttr ($modCore + "_ElbowVolume_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowJntIkFk_BlndScale.outputR") ($modCore + "_ElbowVolume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIkFk_AutoBlnd");
			setAttr ($modCore + "_ElbowJntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_ElbowVolume_MD.outputX") ($modCore + "_ElbowJntIkFk_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_ElbowJntIkFk_AutoBlnd.outputR") ($modCore + "_ElbowJnt.scaleY");
			connectAttr -f ($modCore + "_ElbowJntIkFk_AutoBlnd.outputR") ($modCore + "_ElbowJnt.scaleZ");
			connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_ElbowJntIkFk_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIkFk_BlndRotate");
			connectAttr -f ($modCore + "_ElbowJntFk.rotate") ($modCore + "_ElbowJntIkFk_BlndRotate.color1");
			connectAttr -f ($modCore + "_ElbowJntIk.rotate") ($modCore + "_ElbowJntIkFk_BlndRotate.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ElbowJntIkFk_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_ElbowJntIkFk_BlndScale.outputR") ($modCore + "_ElbowJnt.scaleX");
			connectAttr -f ($modCore + "_ElbowJntIkFk_BlndRotate.output") ($modCore + "_ElbowJnt.rotate");
		}
		else
		{
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIkFk_BlndScale");
			connectAttr -f ($modCore + "_Elbow1JntFk.scale") ($modCore + "_Elbow1JntIkFk_BlndScale.color1");
			connectAttr -f ($modCore + "_Elbow1JntIk.scale") ($modCore + "_Elbow1JntIkFk_BlndScale.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Elbow1JntIkFk_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Elbow1Volume_MD");
			setAttr ($modCore + "_Elbow1Volume_MD.input1X") 1;
			setAttr ($modCore + "_Elbow1Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Elbow1JntIkFk_BlndScale.outputR") ($modCore + "_Elbow1Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIkFk_AutoBlnd");
			setAttr ($modCore + "_Elbow1JntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Elbow1Volume_MD.outputX") ($modCore + "_Elbow1JntIkFk_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Elbow1JntIkFk_AutoBlnd.outputR") ($modCore + "_Elbow1Jnt.scaleY");
			connectAttr -f ($modCore + "_Elbow1JntIkFk_AutoBlnd.outputR") ($modCore + "_Elbow1Jnt.scaleZ");
			connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_Elbow1JntIkFk_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIkFk_BlndRotate");
			connectAttr -f ($modCore + "_Elbow1JntFk.rotate") ($modCore + "_Elbow1JntIkFk_BlndRotate.color1");
			connectAttr -f ($modCore + "_Elbow1JntIk.rotate") ($modCore + "_Elbow1JntIkFk_BlndRotate.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Elbow1JntIkFk_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Elbow1JntIkFk_BlndScale.outputR") ($modCore + "_Elbow1Jnt.scaleX");
			connectAttr -f ($modCore + "_Elbow1JntIkFk_BlndRotate.output") ($modCore + "_Elbow1Jnt.rotate");
	
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIkFk_BlndScale");
			connectAttr -f ($modCore + "_Elbow2JntFk.scale") ($modCore + "_Elbow2JntIkFk_BlndScale.color1");
			connectAttr -f ($modCore + "_Elbow2JntIk.scale") ($modCore + "_Elbow2JntIkFk_BlndScale.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Elbow2JntIkFk_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Elbow2Volume_MD");
			setAttr ($modCore + "_Elbow2Volume_MD.input1X") 1;
			setAttr ($modCore + "_Elbow2Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Elbow2JntIkFk_BlndScale.outputR") ($modCore + "_Elbow2Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIkFk_AutoBlnd");
			setAttr ($modCore + "_Elbow2JntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Elbow2Volume_MD.outputX") ($modCore + "_Elbow2JntIkFk_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Elbow2JntIkFk_AutoBlnd.outputR") ($modCore + "_Elbow2Jnt.scaleY");
			connectAttr -f ($modCore + "_Elbow2JntIkFk_AutoBlnd.outputR") ($modCore + "_Elbow2Jnt.scaleZ");
			connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_Elbow2JntIkFk_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIkFk_BlndRotate");
			connectAttr -f ($modCore + "_Elbow2JntFk.rotate") ($modCore + "_Elbow2JntIkFk_BlndRotate.color1");
			connectAttr -f ($modCore + "_Elbow2JntIk.rotate") ($modCore + "_Elbow2JntIkFk_BlndRotate.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Elbow2JntIkFk_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Elbow2JntIkFk_BlndScale.outputR") ($modCore + "_Elbow2Jnt.scaleX");
			connectAttr -f ($modCore + "_Elbow2JntIkFk_BlndRotate.output") ($modCore + "_Elbow2Jnt.rotate");
		}
	
		//WRIST
		orientConstraint -mo ($modCore + "_WristJntFk") ($modCore + "_WristJntIkDummy") ($modCore + "_WristJntGrp1");
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1.interpType") 2;
		setAttr ($modCore + "_Switch_Ctrl.switchIkFk") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIkDummyW1") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFkW0") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIkDummyW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFkW0");
		setDrivenKeyframe -currentDriver ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIkDummyW1");
		setAttr ($modCore + "_Switch_Ctrl.switchIkFk") 1;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFkW0") 1;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIkDummyW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFkW0");
		setDrivenKeyframe -currentDriver ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIkDummyW1");
		
		shadingNode -asUtility blendColors -n ($modCore + "_WristJntIkFk_BlndScale");
		connectAttr -f ($modCore + "_WristJntFk.scale") ($modCore + "_WristJntIkFk_BlndScale.color1");
		connectAttr -f ($modCore + "_WristJntIk.scale") ($modCore + "_WristJntIkFk_BlndScale.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_WristJntIkFk_BlndScale.blender");
		
		connectAttr -f ($modCore + "_WristJntIkFk_BlndScale.output") ($modCore + "_WristJnt.scale");
		

		//ELBOWIk_Ctrl FOLLOW
		parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_WristPivot_Ctrl") ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ElbowIk_CtrlGrp");
		addAttr -ln "follow" -at "enum" -en "Main:Wrist:Shoulder:Wrist and Shoulder:" ($modCore + "_ElbowIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_ElbowIk_Ctrl.follow");
		setAttr ($modCore + "_ElbowIk_Ctrl.follow") 0;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2") 0;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2"); 
		
		setAttr ($modCore + "_ElbowIk_Ctrl.follow") 1;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0") 0;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2");
		
		setAttr ($modCore + "_ElbowIk_Ctrl.follow") 2;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2") 1;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2");
		
		setAttr ($modCore + "_ElbowIk_Ctrl.follow") 3;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1") 1;
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_WristPivot_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIk_Ctrl.follow") ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1." + $modCore + "_ShoulderFk_CtrlW2");
		
		setAttr ($modCore + "_ElbowIk_Ctrl.follow") 0;
		
		keyTangent -itt spline -ott spline ($modCore + "_WristJntGrp1_orientConstraint1_" + $modCore + "_WristJntFkW0")
		($modCore + "_WristJntGrp1_orientConstraint1_" + $modCore + "_WristJntIkDummyW1")
		($modCore + "_ElbowIk_CtrlGrp_parentConstraint1_" + $modRigName + "MAIN_Inner_CtrlW0")
		($modCore + "_ElbowIk_CtrlGrp_parentConstraint1_" + $modCore + "_WristPivot_CtrlW1")
		($modCore + "_ElbowIk_CtrlGrp_parentConstraint1_" + $modCore + "_ShoulderFk_CtrlW2"); 
		
		//CONNECTOR LINE
		curve -n ($modCore + "_ElbowIkConnector_Curve") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		rename `listRelatives -c ($modCore + "_ElbowIkConnector_Curve")` ($modCore + "_ElbowIkConnector_CurveShape");
		delete `parentConstraint ($modCore + "_ElbowIk_Ctrl") ($modCore + "_ElbowIkConnector_Curve") `;
		parent ($modCore + "_ElbowIkConnector_Curve") ($modCore + "_ElbowIk_Ctrl");
		spaceLocator -n ($modCore + "_ElbowIkAimConnectorLctr");
		spaceLocator -n ($modCore + "_ElbowIkTargetConnectorLctr");
		parent ($modCore + "_ElbowIkTargetConnectorLctr") ($modCore + "_ElbowIkAimConnectorLctr");
		delete `parentConstraint ($modCore + "_ElbowIk_Ctrl") ($modCore + "_ElbowIkAimConnectorLctr")`;
		parent ($modCore + "_ElbowIkAimConnectorLctr") ($modCore + "_ElbowIk_Ctrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIkAimConnectorLctr");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_ElbowIkTargetConnectorLctr");
			aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_ElbowJnt") ($modCore + "_ElbowIkAimConnectorLctr");
			aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_ElbowJnt") ($modCore + "_ElbowIkConnector_Curve");
		}
		else
		{
			pointConstraint ($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIkTargetConnectorLctr");
			aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIkAimConnectorLctr");
			aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIkConnector_Curve");
		}
		connectAttr -f ($modCore + "_ElbowIkTargetConnectorLctr.tz") ($modCore + "_ElbowIkConnector_Curve.sz");
		setAttr ($modCore + "_ElbowIkAimConnectorLctr.v") 0;
		
		addAttr -ln "nonControl" -dt "string" ($modCore + "_ElbowIkConnector_Curve");
		setAttr -e -k 1 ($modCore + "_ElbowIkConnector_Curve.nonControl");
		setAttr -l 1 ($modCore + "_ElbowIkConnector_Curve.nonControl");
		
		//VISIBILITY TOGGLES////////////////////////////////////////////////////////////////////
	
		//ARM
		shadingNode -asUtility condition -n ($modCore + "_ArmIkViz");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ArmIkViz.firstTerm");
		setAttr ($modCore + "_ArmIkViz.secondTerm") 1;
		setAttr ($modCore + "_ArmIkViz.operation") 3;
			
		connectAttr -f ($modCore + "_ArmIkViz.outColorR") ($modCore + "_ElbowIk_Ctrl.v");
		connectAttr -f ($modCore + "_ArmIkViz.outColorR") ($modCore + "_WristIk_Ctrl.v");
		if (`objExists ($modCore + "_LowerArmIk_Ctrl")`)
		{
			connectAttr -f ($modCore + "_ArmIkViz.outColorR") ($modCore + "_LowerArmIk_Ctrl.v");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.v");
		}
		shadingNode -asUtility condition -n ($modCore + "_ArmFkViz");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ArmFkViz.firstTerm");
		setAttr ($modCore + "_ArmFkViz.secondTerm") 0;
		setAttr ($modCore + "_ArmFkViz.operation") 5;
		
		//SHOULDER
		shadingNode -asUtility condition -n ($modCore + "_ShoulderFkViz");
		connectAttr -f ($modCore + "_ShoulderFk_Ctrl.alwaysVisible") ($modCore + "_ShoulderFkViz.firstTerm");
		connectAttr -f ($modCore + "_ArmFkViz.outColorR") ($modCore + "_ShoulderFkViz.colorIfTrueR");
		connectAttr -f ($modCore + "_ShoulderFkViz.outColorR") ($modCore + "_ShoulderFk_Ctrl.v");



		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -f ($modCore + "_ArmFkViz.outColorR") ($modCore + "_ElbowFk_Ctrl.v");
		}
		else
		{
			connectAttr -f ($modCore + "_ArmFkViz.outColorR") ($modCore + "_Elbow1Fk_Ctrl.v");
			connectAttr -f ($modCore + "_ArmFkViz.outColorR") ($modCore + "_Elbow2Fk_Ctrl.v");
		}
		connectAttr -f ($modCore + "_ArmFkViz.outColorR") ($modCore + "_WristFk_Ctrl.v");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
	
		//JOINTS
		setAttr ($modCore + "_ShoulderJntIk.v") 0;
		setAttr ($modCore + "_ShoulderJntFk.v") 0;
		setAttr ($modCore + "_WristJntFk.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_ShoulderJntIk.v") 0;
		setAttr -l 1 -k 0 ($modCore + "_ShoulderJntFk.v") 0;
		setAttr -l 1 -k 0 ($modCore + "_WristJntFk.v") 0;
	
	
		setAttr ($modCore + "_LimbLengthOriginLctr.v") 0;
		setAttr ($modCore + "_WristJntIkDummyGrp2.v") 0;
		setAttr ($modCore + "_WristJntFkGrp2.v") 0;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr ($modCore + "_ElbowJntFkGrp2.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Elbow1JntFkGrp2.v") 0;
			setAttr ($modCore + "_Elbow2JntFkGrp2.v") 0;
		}
		
		
		setAttr ($modCore + "_ElbowIk_Ctrl_TargetLctr.v") 0;
		
		//CONTROLS
		setAttr -l 1 -k 0 ($modCore + "_Clavicle_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_Clavicle_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_Clavicle_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_Clavicle_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFk_Ctrl.v");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFk_Ctrl.v");
		}
		else
		{
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1Fk_Ctrl.v");
			
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.tz");
			//setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.rx");
			//setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2Fk_Ctrl.v");
			
			
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIk_Ctrl.v");
			transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_LowerArmIk_Ctrl");
		}
		
		setAttr -l 1 -k 0 ($modCore + "_WristFk_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_WristFk_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_WristFk_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_WristFk_Ctrl.v");
		
		//setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.rx");
		//setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.ry");
		//setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIk_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_WristIk_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_WristPivot_Ctrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.v");

		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.tx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.ty");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.tz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.rx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.ry");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.rz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.sx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.sy");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.sz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIkConnector_Curve.v");
		setAttr ($modCore + "_ElbowIkConnector_Curve.template") 1;
		
		setAttr ($modCore + "_ArmIkHandle.v") 0;
		
		
		//LOCK GROUPS
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		select -cl;
		//WRIST Fk LOCATOR
		spaceLocator -n ($modCore + "_WristFkLctr");
		delete `parentConstraint ($modCore + "_WristIk_CtrlGrp") ($modCore + "_WristFkLctr")`;
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristFkLctr");
		parent ($modCore + "_WristFkLctr") ($modCore + "_WristIk_CtrlGrp");
		parentConstraint ($modCore + "_WristFk_Ctrl") ($modCore + "_WristFkLctr");
		
		//WRIST Ik LOCATOR
		spaceLocator -n ($modCore + "_WristIkLctr");
		delete `parentConstraint ($modCore + "_WristFk_CtrlGrp") ($modCore + "_WristIkLctr")`;
		parent ($modCore + "_WristIkLctr") ($modCore + "_WristFk_CtrlGrp");
		orientConstraint -mo ($modCore + "_WristIk_Ctrl") ($modCore + "_WristIkLctr");
		setAttr ($modCore + "_WristIkLctr_orientConstraint1.interpType") 2;
		
		//ELBOW Fk LOCATOR
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			spaceLocator -n ($modCore + "_Elbow_FkAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIk_Ctrl") ($modCore + "_Elbow_FkAimLctr")`;
			parent ($modCore + "_Elbow_FkAimLctr") ($modCore + "_ElbowIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow_FkAimLctr");
		
			parentConstraint -mo ($modCore + "_ElbowFk_Ctrl") ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_Elbow_FkAimLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Elbow1_FkAimLctr");
			parent ($modCore + "_Elbow1_FkAimLctr") ($modCore + "_Elbow1Fk_Ctrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Elbow1_FkAimLctr");
			delete `pointConstraint -skip x -skip y -weight 1 ($modCore + "_ElbowIk_Ctrl") ($modCore + "_Elbow1_FkAimLctr")`;
	
			parent ($modCore + "_Elbow1_FkAimLctr") ($modCore + "_ElbowIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow1_FkAimLctr");
		
			parentConstraint -mo ($modCore + "_Elbow1Fk_Ctrl") ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_Elbow1_FkAimLctr");
			
			spaceLocator -n ($modCore + "_Elbow2_FkAimLctr");
			parent ($modCore + "_Elbow2_FkAimLctr") ($modCore + "_Elbow2Fk_Ctrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Elbow2_FkAimLctr");
			delete `pointConstraint -skip x -skip y -weight 1 ($modCore + "_ElbowIk_Ctrl") ($modCore + "_Elbow2_FkAimLctr")`;
	
			parent ($modCore + "_Elbow2_FkAimLctr") ($modCore + "_ElbowIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow2_FkAimLctr");
		
			parentConstraint -mo ($modCore + "_Elbow2Fk_Ctrl") ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_Elbow2_FkAimLctr");
		}		
		
		//SHOULDER Fk LOCATOR
		spaceLocator -n ($modCore + "_ShoulderFkOrientLctr");
		delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderFkOrientLctr")`;
		parent ($modCore + "_ShoulderFkOrientLctr") ($modCore + "_ShoulderFk_CtrlGrp");
		orientConstraint ($modCore + "_ShoulderJntIk") ($modCore + "_ShoulderFkOrientLctr");
		
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_ShoulderFkOrientLctr.v") 0;
		if (`objExists ($modCore + "_Elbow_FkAimLctr.v")`)
		{
			setAttr ($modCore + "_Elbow_FkAimLctr.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Elbow1_FkAimLctr.v") 0;
			setAttr ($modCore + "_Elbow2_FkAimLctr.v") 0;
		}		
		setAttr ($modCore + "_WristIkLctr.v") 0;
		setAttr ($modCore + "_WristFkLctr.v") 0;
		
		setAttr ($modCore + "_ShoulderIkLockLctr.v") 0;
		
		
		//PARENT TO MAIN CONTROL
		
		//SET ALL CONSTRAINTS TO SHORTEST INTERPOLATION
		select ;
		
		string $selectedParentConstraints[] = `ls ($modCore + "*_parentConstraint1")`;
		for ($crntParentConstraint in $selectedParentConstraints)
		{setAttr ($crntParentConstraint + ".interpType") 2;}
		
		setAttr ($modCore + "_ElbowIk_CtrlGrp_parentConstraint1.interpType") 2;
		
		if (`objExists ($modCore + "_Shoulder_CurveJnt")`)
		{
			setAttr ($modCore + "_LowerTwist75Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwist25Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwistHalfLctr_parentConstraint1.interpType") 2;
		}
		
		//HIERARCHY CLEAN-UP
		parent ($modCore + "_Clavicle_CtrlGrp") ($modCore + "_ClavicleJnt")
		($modCore + "_WristJntFkGrp2") ($modCore + "_WristIk_CtrlGrp") ($modCore + "_ElbowIk_CtrlGrp")
		($modCore + "_ElbowIk_Ctrl_TargetLctr") ($modCore + "_WristJntIkDummyGrp2")
		($modCore + "_LimbLengthOriginLctr") ($modCore + "_ShoulderIkLockLctr")
		($modCore + "_Switch_CtrlGrp") ($modCore + "_ShoulderFk_CtrlGrp2")
		($modCore + "_WristFk_CtrlGrp") ($modCore + "_WristJntGrp2")
		//($modCore + "_WristJntFk")
		($modCore + "_ScaleGrp");
			
		//if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		//{
		//	parent ($modCore + "_Elbow1JntFkGrp2") ($modCore + "_Elbow2JntFkGrp2") ($modCore + "_LowerArmIkHandle") ($modCore + "_ScaleGrp");
		//}

		//CREATE CONSTRAINT FOR WRIST Ik_CtrlGrp
		//CHECK IF ATTACHED TO ROOT
		if ($modAttachNode == "ROOT")
		{
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore + "_WristIk_CtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_WristIk_CtrlGrp");
		}

		//ADD DYNAMIC PARENTING CHANNELS
		addAttr -ln "follow" -at double -min 1 -max 1 -dv 1 ($modCore + "_WristIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_WristIk_Ctrl.follow");
		setAttr -l 1 ($modCore + "_WristIk_Ctrl.follow");
		if ($modAttachNode != "ROOT")
		{
			addAttr -ln "parent" -at double -min 0 -max 1 -dv 0 ($modCore + "_WristIk_Ctrl");
			setAttr -e -k 1 ($modCore + "_WristIk_Ctrl.parent");
		}
		addAttr -ln "ROOT" -at double -min 0 -max 1 -dv 0 ($modCore + "_WristIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_WristIk_Ctrl.ROOT");

		addAttr -ln "ROOTType" -at "enum" -en "ROOTC:ROOTsecondaryC:" ($modCore + "_WristIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_WristIk_Ctrl.ROOTType");


		//Ik WRIST DYNAMIC CONSTRAINTS
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_WristIk_Ctrl.parent") ($modCore + "_WristIk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW3");
		}
		
		//ROOT CONNECTIONS
		shadingNode -asUtility multiplyDivide -n ($modCore + "_WristIkROOTInf_MD");
		connectAttr -f ($modCore + "_WristIk_Ctrl.ROOT") ($modCore + "_WristIkROOTInf_MD.input1X");
		connectAttr -f ($modCore + "_WristIk_Ctrl.ROOT") ($modCore + "_WristIkROOTInf_MD.input1Y");
		connectAttr -f ($modCore + "_WristIk_Ctrl.ROOTType") ($modCore + "_WristIkROOTInf_MD.input2Y");
		
		shadingNode -asUtility reverse -n ($modCore + "_WristIkROOTInf_Reverse");
		connectAttr -f ($modCore + "_WristIk_Ctrl.ROOTType") ($modCore + "_WristIkROOTInf_Reverse.inputX");
		connectAttr -f ($modCore + "_WristIkROOTInf_Reverse.outputX") ($modCore + "_WristIkROOTInf_MD.input2X");

		connectAttr -f ($modCore + "_WristIkROOTInf_MD.outputX") ($modCore + "_WristIk_CtrlGrp_parentConstraint1." + $modRigName + "ROOT_CtrlW1");
		connectAttr -f ($modCore + "_WristIkROOTInf_MD.outputY") ($modCore + "_WristIk_CtrlGrp_parentConstraint1." + $modRigName + "ROOTSecondary_CtrlW2");
		
		shadingNode -asUtility plusMinusAverage -n ($modCore + "_WristIkParent_PMA");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_WristIk_Ctrl.parent") ($modCore + "_WristIkParent_PMA.input1D[0]");
		}
		connectAttr -f ($modCore + "_WristIk_Ctrl.ROOT") ($modCore + "_WristIkParent_PMA.input1D[1]");
		
		shadingNode -asUtility condition -n ($modCore + "_WristIkParent_Condition");
		setAttr ($modCore + "_WristIkParent_Condition.operation") 4;
		setAttr ($modCore + "_WristIkParent_Condition.secondTerm") 1;
		connectAttr -f ($modCore + "_WristIkParent_PMA.output1D") ($modCore + "_WristIkParent_Condition.firstTerm");
		connectAttr -force ($modCore + "_WristIkParent_PMA.output1D") ($modCore + "_WristIkParent_Condition.colorIfTrueR");
		
		shadingNode -asUtility reverse -n ($modCore + "_WristIkParent_Reverse");
		connectAttr -f ($modCore + "_WristIkParent_Condition.outColorR") ($modCore + "_WristIkParent_Reverse.inputX");
		connectAttr -f ($modCore + "_WristIkParent_Reverse.outputX") ($modCore + "_WristIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		//WRIST Ik TO Fk LOCATOR
		spaceLocator -n ($modCore + "_WristIkToFkLctr");
		delete `parentConstraint ($modCore + "_WristIk_CtrlGrp") ($modCore + "_WristIkToFkLctr")`;
		parent ($modCore + "_WristIkToFkLctr") ($modCore + "_WristIk_CtrlGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristIkToFkLctr");
		parentConstraint -mo ($modCore + "_WristFk_Ctrl") ($modCore + "_WristIkToFkLctr");
		
		//SINGLE ELBOW
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			//ELBOW Ik TO Fk LOCATOR
			spaceLocator -n ($modCore + "_ElbowIkToFkAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIk_Ctrl") ($modCore + "_ElbowIkToFkAimLctr")`;
			parent ($modCore + "_ElbowIkToFkAimLctr") ($modCore + "_ElbowIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIkToFkAimLctr");
			parentConstraint -mo ($modCore + "_ElbowFk_Ctrl") ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ElbowIkToFkAimLctr");

			////WRIST Fk TO Ik LOCATOR
			//spaceLocator -n ($modCore + "_WristFkToIkLctr");
			//setAttr ($modCore + "_WristFkToIkLctr.rotateOrder") 1;
			//delete `parentConstraint ($modCore + "_WristFk_CtrlGrp") ($modCore + "_WristFkToIkLctr")`;
			//parent ($modCore + "_WristFkToIkLctr") ($modCore + "_WristFk_CtrlGrp");
			//orientConstraint -mo ($modCore + "_WristIk_Ctrl") ($modCore + "_WristFkToIkLctr");
			//setAttr ($modCore + "_WristFkToIkLctr_orientConstraint1.interpType") 2;

			
			////SHOULDER Fk TO Ik LOCATOR
			//spaceLocator -n ($modCore + "_ShoulderFkToIkOrientLctr");
			//setAttr ($modCore + "_ShoulderFkToIkOrientLctr.rotateOrder") 1;
			//delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderFkToIkOrientLctr")`;
			//parent ($modCore + "_ShoulderFkToIkOrientLctr") ($modCore + "_ShoulderFk_CtrlGrp");
			//orientConstraint -mo ($modCore + "_ShoulderJntIk") ($modCore + "_ShoulderFkToIkOrientLctr");
		}
		else
		{
			//ELBOW Ik TO Fk LOCATOR
			spaceLocator -n ($modCore + "_ElbowIkToFkAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIk_Ctrl") ($modCore + "_ElbowIkToFkAimLctr")`;
			parent ($modCore + "_ElbowIkToFkAimLctr") ($modCore + "_ElbowIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIkToFkAimLctr");
			parentConstraint -mo ($modCore + "_Elbow1Fk_Ctrl") ($modCore + "_ShoulderFk_Ctrl") ($modCore + "_ElbowIkToFkAimLctr");
		}
		//TURN OFF VISIBILITY
		setAttr ($modCore + "_WristIkToFkLctr.v") 0;
		//setAttr ($modCore + "_WristFkToIkLctr.v") 0;
		setAttr ($modCore + "_ElbowIkToFkAimLctr.v") 0;
		//setAttr ($modCore + "_ShoulderFkToIkOrientLctr.v") 0;


		//ELBOW HIERARCHY CLEANUP////////////////////////////////////////////////////////
		if (`objExists ($modCore + "_ElbowJntFkGrp2")`)
		{
			parent ($modCore + "_ElbowJntFkGrp2") ($modCore + "_ElbowFk_CtrlGrp") ($modCore + "_ScaleGrp");
		}
		else
		{
			parent ($modCore + "_Elbow1Fk_CtrlGrp") ($modCore + "_Elbow2Fk_CtrlGrp")
			($modCore + "_Elbow1JntFkGrp2") ($modCore + "_Elbow2JntFkGrp2")
			($modCore + "_ScaleGrp");
		}
		
		select $topNode;
	
		if (`objExists ("RRM_" + $prfx + $core + "_Lower1")` || `objExists ("RRM_" + $prfx + $core + "_Middle1")` || `objExists ("RRM_" + $prfx + $core + "_Upper1")`)
		{
			if (`getAttr ("RRM_" + $core + ".toonArms")` == 1)
			{
				RRM_ToonLimbs($modRigName, $rigGrp, "arm", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode, $behavior, $behaviorMultiplier, $lPrfx, $rPrfx, $ea);
			}
			else
			{
				RRM_TwistLimbs($modRigName, $rigGrp, "arm", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode, $behavior, $behaviorMultiplier, $lPrfx, $rPrfx, $ea);
			}
		}
		
		//ADD JOINT ANGLE ATTRIBUTES
		addAttr -ln "shoulderAngleX" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "shoulderAngleX");
		addAttr -ln "shoulderAngleY" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "shoulderAngleY");
		addAttr -ln "shoulderAngleZ" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "shoulderAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			addAttr -ln "elbowAngleY" -at double ($modCore + "_Switch_Ctrl");
			setAttr -e -k 1 ($modCore + "_Switch_Ctrl.elbowAngleY");
		}
		else
		{
			addAttr -ln "elbow1AngleY" -at double ($modCore + "_Switch_Ctrl");
			setAttr -e -k 1 ($modCore + "_Switch_Ctrl.elbow1AngleY");
			addAttr -ln "elbow2AngleY" -at double ($modCore + "_Switch_Ctrl");
			setAttr -e -k 1 ($modCore + "_Switch_Ctrl.elbow2AngleY");
		}
		
		addAttr -ln "wristAngleX" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "wristAngleX");
		addAttr -ln "wristAngleY" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "wristAngleY");
		addAttr -ln "wristAngleZ" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "wristAngleZ");
		
		//CONNECT JOINT ANGLE ATTRIBUTES
		connectAttr -force ($modCore + "_ShoulderJnt.rotateX") ($modCore + "_Switch_Ctrl." + "shoulderAngleX");
		connectAttr -force ($modCore + "_ShoulderJnt.rotateY") ($modCore + "_Switch_Ctrl." + "shoulderAngleY");
		connectAttr -force ($modCore + "_ShoulderJnt.rotateZ") ($modCore + "_Switch_Ctrl." + "shoulderAngleZ"); 
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			connectAttr -force ($modCore + "_ElbowJnt.rotateY") ($modCore + "_Switch_Ctrl.elbowAngleY");
		}
		else
		{
			connectAttr -force ($modCore + "_Elbow1Jnt.rotateY") ($modCore + "_Switch_Ctrl.elbow1AngleY");
			connectAttr -force ($modCore + "_Elbow2Jnt.rotateY") ($modCore + "_Switch_Ctrl.elbow2AngleY");
		}
			
	
		connectAttr -force ($modCore + "_WristJntGrp1.rotateX") ($modCore + "_Switch_Ctrl.wristAngleX");
		connectAttr -force ($modCore + "_WristJntGrp1.rotateY") ($modCore + "_Switch_Ctrl.wristAngleY");
		connectAttr -force ($modCore + "_WristJntGrp1.rotateZ") ($modCore + "_Switch_Ctrl.wristAngleZ");
		
		setAttr -l 1 ($modCore + "_Switch_Ctrl.shoulderAngleX"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.shoulderAngleY"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.shoulderAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			setAttr -l 1 ($modCore + "_Switch_Ctrl.elbowAngleY");
		}
		else
		{
			setAttr -l 1 ($modCore + "_Switch_Ctrl.elbow1AngleY");
			setAttr -l 1 ($modCore + "_Switch_Ctrl.elbow2AngleY");
		}
		
		setAttr -l 1 ($modCore + "_Switch_Ctrl.wristAngleX"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.wristAngleY"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.wristAngleZ");
		
		
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*_Ctrl")`;
		string $crntModControl;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("" + $prfx + $core);
			setAttr -e-l 1 ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType" -dt "string" ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "arm";
			setAttr -l true ($crntModControl + ".moduleType");
		}

		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$inverseFront = 1;
	
		if (!`objExists ($topNode + ".pair")`)
		{
			$i = 2;
		}
	}
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Parent")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Parent")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Parent");}
	else if (`objExists ("RRM_" + $modRigName + "Parent")`)
		{select ("RRM_" + $modRigName + "Parent");}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE LEG MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRigLeg(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;  
	$core = `getAttr ($topNode + ".core")`;

	//INTEGER FOR LOOP
	$mirrorInt = 1;
		
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	string $prfx = $lPrfx;
	string $oppPrfx = $rPrfx;
	float $behavior = 1;
	float $behaviorMultiplier = 1;

	int $inverseFront = 0;
	$i = 2;
	if (!`objExists ($topNode + ".pair")`)
	{
		$prfx = "";
		$prfx = "";
		$oppPrfx = "";
		$mirrorInt = 2;
	}
	else if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
	{
		if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
		{	
			$behavior = 0;
		}
	}

	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;

	while ($mirrorInt <=2)
	{
		if ($crntSide == "right" && $behavior == 0)
		{
			$behaviorMultiplier = -1;
		}
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$modOppCore = ($modRigName + "" + $oppPrfx + $core);
		
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "leg";
		setAttr -l true ($modCore + "Grp.topNode");
			
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		//UPPER ROLL JOINTS
		string $UpperCJnt[];
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
		}
		addAttr -ln "upperTwist" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.upperTwist") ;
		setAttr -type "string" ($modCore + "Grp.upperTwist") `size $UpperCJnt`;
		setAttr -l true ($modCore + "Grp.upperTwist");
		
		string $LowerCJnt[];
		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
		}
		addAttr -ln "lowerTwist" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.lowerTwist") ;
		setAttr -type "string" ($modCore + "Grp.lowerTwist") `size $LowerCJnt`;
		setAttr -l true ($modCore + "Grp.lowerTwist");
	
		addAttr -ln "kneeNum" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.kneeNum") ;
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr -type "string" ($modCore + "Grp.kneeNum") "1";
		}
		else
		{
			setAttr -type "string" ($modCore + "Grp.kneeNum") "2";
		}		
		setAttr -l true ($modCore + "Grp.kneeNum");
		
		int $sizeMiddleCJnt = 0;
		string $MiddleCJnt[];
		if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
		{
			$MiddleCJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
		}
		addAttr -ln "midTwist" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.midTwist") ;
		setAttr -type "string" ($modCore + "Grp.midTwist") $MiddleCJnt;
		setAttr -l true ($modCore + "Grp.midTwist");
			
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");
	

		float $legLength;
		float $lKneeLength[];
		float $lKnee1Length[];
		float $lKnee2Length[];
		float $lAnkleLength[];
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Knee") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_EndLctr")`;
			$lKneeLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_EndLctr")`;
			$lAnkleLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			$legLength = (($lKneeLength[0] + $lAnkleLength[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_EndLctr")`;
			$lKnee1Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_EndLctr")`;
			$lKnee2Length = `xform -q -t ($modCore + "_EndLctr")`;
			$lKneeLength[0] = ($lKnee1Length[0] + $lKnee2Length[0]);
	
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_StartLctr")`;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modRigName + "MAIN_Ctrl")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_EndLctr")`;
			$lAnkleLength = `xform -q -t ($modCore + "_EndLctr")`;
	
			$legLength = (($lKnee1Length[0] + $lKnee2Length[0]) /2);
			delete ($modCore + "_StartLctr");
		}


		//HIP FK CONTROL
		RRM_BasicControl(($modCore + "_HipFk_Ctrl"), "x", ($legLength/3), 1, ($lKneeLength[0] * $multiplier));
		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 180 0 0 ($modCore + "_HipFk_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_HipFk_Ctrl");
		}
		
		group -n ($modCore + "_HipFk_CtrlGrp") ($modCore + "_HipFk_Ctrl"); xform -os -piv 0 0 0; 
		setAttr ($modCore + "_HipFk_CtrlGrp.rotateOrder") 1;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_HipFk_CtrlGrp")`;
		float $upVector = 1;
		float $kneeLocCheck;
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			$kneeLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Knee.translateZ")`;
		}
		else
		{
			$kneeLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Knee1.translateZ")`;
		}
		if ($kneeLocCheck < -0.0001)
		{
			$upVector = -1;
		}
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `aimConstraint -aimVector $behaviorMultiplier 0 0 -upVector 0 0 $behaviorMultiplier -worldUpType "objectrotation" -worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee")
			("RRM_" + $prfx + $core + "_Knee") ($modCore + "_HipFk_CtrlGrp")`;
		}
		else
		{
			delete `aimConstraint -aimVector $behaviorMultiplier 0 0 -upVector 0 0 $behaviorMultiplier -worldUpType "objectrotation" -worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee1")
			("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_HipFk_CtrlGrp")`;
		}

		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_HipFk_Ctrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_HipFk_Ctrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_HipFk_Ctrl");

			
		//KNEE FK CONTROL
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			RRM_BasicControl(($modCore + "_KneeFk_Ctrl"), "x", ($legLength/3), 1, ($lAnkleLength[0] * $multiplier));
			if ($crntSide == "right" && $behavior == 0)
			{
				rotate -r -os 180 0 0 ($modCore + "_KneeFk_Ctrl");
				makeIdentity -apply true -r 1 ($modCore + "_KneeFk_Ctrl");
			}
			group -n ($modCore + "_KneeFk_CtrlGrp") ($modCore + "_KneeFk_Ctrl"); xform -os -piv 0 0 0; 
			setAttr ($modCore + "_KneeFk_Ctrl.rotateOrder") 1;

			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_KneeFk_CtrlGrp")`;
			delete `aimConstraint -aimVector $behaviorMultiplier 0 0 -upVector 0 0 $behaviorMultiplier -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_KneeFk_CtrlGrp")`;
		}
		else
		{
			RRM_BasicControl(($modCore + "_Knee1Fk_Ctrl"), "x", ($legLength/3), 1, ($lKnee2Length[0] * $multiplier));
			if ($crntSide == "right" && $behavior == 0)
			{
				rotate -r -os 180 0 0 ($modCore + "_Knee1Fk_Ctrl");
				makeIdentity -apply true -r 1 ($modCore + "_Knee1Fk_Ctrl");
			}
			group -n ($modCore + "_Knee1Fk_CtrlGrp") ($modCore + "_Knee1Fk_Ctrl"); xform -os -piv 0 0 0; 
			setAttr ($modCore + "_Knee1Fk_CtrlGrp.rotateOrder") 1;

			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_Knee1Fk_CtrlGrp")`;
			delete `aimConstraint -aimVector $behaviorMultiplier 0 0 -upVector 0 0 $behaviorMultiplier -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee1")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_Knee1Fk_CtrlGrp")`;
			
			RRM_BasicControl(($modCore + "_Knee2Fk_Ctrl"), "x", ($legLength/3), 1, ($lAnkleLength[0] * $multiplier));
			if ($crntSide == "right" && $behavior == 0)
			{
				rotate -r -os 180 0 0 ($modCore + "_Knee2Fk_Ctrl");
				makeIdentity -apply true -r 1 ($modCore + "_Knee2Fk_Ctrl");
			}
			group -n ($modCore + "_Knee2Fk_CtrlGrp") ($modCore + "_Knee2Fk_Ctrl"); xform -os -piv 0 0 0; 
			setAttr ($modCore + "_Knee2Fk_CtrlGrp.rotateOrder") 1;

			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_Knee2Fk_CtrlGrp")`;
			delete `aimConstraint -aimVector $behaviorMultiplier 0 0 -upVector 0 0 $behaviorMultiplier -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee2")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_Knee2Fk_CtrlGrp")`;
		}
		//BALL CONTROL LOCATORS
		spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
		spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
		
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $core + "_HeelPivot")
		("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_StartLctr")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_EndLctr")`;
		$ankleLength = `xform -q -t ($modCore + "_EndLctr")`;

		delete `pointConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_StartLctr")`;
		delete `pointConstraint -skip x -skip z ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $core + "_HeelPivot")
		("RRM_" + $prfx + $core + "_Toe") ($modCore + "_StartLctr")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_EndLctr")`;
		$footLength = `xform -q -t ($modCore + "_EndLctr")`;

		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_StartLctr")`;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $core + "_HeelPivot")
		("RRM_" + $prfx + $core + "_Toe") ($modCore + "_StartLctr")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_EndLctr")`;		
		$ballLength = `xform -q -t ($modCore + "_EndLctr")`;
		delete ($modCore + "_StartLctr");
		
		//ANKLE FK CONTROL
		RRM_BasicControl(($modCore + "_AnkleFk_Ctrl"), "x", ($legLength/3), 1, ($ballLength[0] * $multiplier));
		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 180 0 0 ($modCore + "_AnkleFk_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_AnkleFk_Ctrl");
		}
		group -n ($modCore + "_AnkleFk_CtrlGrp") ($modCore + "_AnkleFk_Ctrl"); xform -os -piv 0 0 0; 
		setAttr ($modCore + "_AnkleFk_CtrlGrp.rotateOrder") 1;

		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_AnkleFk_CtrlGrp")`;
		delete `orientConstraint -offset 0 0 -90 ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_AnkleFk_CtrlGrp")`;

		scale -r -os 0.8 0.8 0.8 ($modCore + "_AnkleFk_CtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_AnkleFk_CtrlGrp");
		select ($modCore + "_AnkleFk_CtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_AnkleFk_Ctrl");
		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 0 180 0 ($modCore + "_AnkleFk_CtrlGrp");
		}
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_AnkleFk_Ctrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_AnkleFk_Ctrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_AnkleFk_Ctrl");
	
		//BALL FK CONTROL
		RRM_BasicControl(($modCore + "_BallFk_Ctrl"), "x", 1, 1, ($ballLength[0] * $multiplier));
		if ($crntSide == "right")
		{
			rotate -r -os 0 0 180 ($modCore + "_BallFk_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_BallFk_Ctrl");
		}
		move -r -os -wd 0 0 0.5 ($modCore + "_BallFk_CtrlShape.cv[0:17]") ($modCore + "_BallFk_Ctrl2Shape.cv[0:17]") ($modCore + "_BallFk_Ctrl3Shape.cv[0:1]") ($modCore + "_BallFk_Ctrl4Shape.cv[0:1]") ($modCore + "_BallFk_Ctrl5Shape.cv[0:1]") ($modCore + "_BallFk_Ctrl6Shape.cv[0:1]") ;
		group -n ($modCore + "_BallFk_CtrlGrp") ($modCore + "_BallFk_Ctrl"); xform -os -piv 0 0 0;
	
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_BallFk_CtrlGrp")`;
		delete `orientConstraint -offset 0 -90 -90 ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_BallFk_CtrlGrp")`;
		scale -r -os ($footLength[0]/5) ($footLength[0]/3) ($footLength[0]/4) ($modCore + "_BallFk_CtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_BallFk_CtrlGrp");

		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 0 180 0 ($modCore + "_BallFk_CtrlGrp");
			rotate -r -os 0 -180 0 ($modCore + "_BallFk_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_BallFk_Ctrl");
		}
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_BallFk_Ctrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_BallFk_Ctrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_BallFk_Ctrl");
		
		//TOE FK CONTROL
		RRM_BasicControl(($modCore + "_ToeFk_Ctrl"), "x", 1, 0, 1);
		//if ($crntSide == "right")
		//{
		//	rotate -r -os 180 0 0 ($modCore + "_ToeFk_Ctrl");
		//	makeIdentity -apply true -r 1 ($modCore + "_ToeFk_Ctrl");
		//}
		move -r -os 0 0 0.5 ($modCore + "_ToeFk_Ctrl.cv[0:17]");
	
		group -n ($modCore + "_ToeFk_CtrlGrp") ($modCore + "_ToeFk_Ctrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_ToeFk_CtrlGrp.rotateOrder") 1;
	
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_ToeFk_CtrlGrp")`;
		delete `orientConstraint -offset 0 -90 -90 ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_ToeFk_CtrlGrp")`;
		scale -r -os ($footLength[0]/5) ($footLength[0]/3) ($footLength[0]/4) ($modCore + "_ToeFk_CtrlGrp");

		if ($crntSide == "right" && $behavior == 0)
		{
			rotate -r -os 0 180 0 ($modCore + "_ToeFk_CtrlGrp");
			rotate -r -os 0 -180 0 ($modCore + "_ToeFk_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_ToeFk_Ctrl");
		}
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_ToeFk_Ctrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_ToeFk_Ctrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_ToeFk_Ctrl");
		
		//////////////////////JOINTS//////////////////////
		select -cl;
		joint -n ($modCore + "_HipJnt");
		delete `parentConstraint ($modCore + "_HipFk_Ctrl") ($modCore + "_HipJnt")`;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -cl;
			joint -n ($modCore + "_KneeJnt");
			delete `parentConstraint ($modCore + "_KneeFk_Ctrl") ($modCore + "_KneeJnt")`;
		
			select -cl;
			joint -n ($modCore + "_AnkleJnt");
			delete `parentConstraint ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJnt")`;
			select -cl;
			joint -n ($modCore + "_AnkleJntDummy");
			delete `parentConstraint ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_HipJnt")
			($modCore + "_KneeJnt") ($modCore + "_AnkleJnt") ($modCore + "_AnkleJntDummy");
			
			parent ($modCore + "_KneeJnt") ($modCore + "_HipJnt");
			parent ($modCore + "_AnkleJnt") ($modCore + "_KneeJnt");
			parent ($modCore + "_AnkleJntDummy") ($modCore + "_KneeJnt");
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_Knee1Jnt");
			delete `parentConstraint ($modCore + "_Knee1Fk_Ctrl") ($modCore + "_Knee1Jnt")`;
		
			select -cl;
			joint -n ($modCore + "_Knee2Jnt");
			delete `parentConstraint ($modCore + "_Knee2Fk_Ctrl") ($modCore + "_Knee2Jnt")`;
	
			select -cl;
			joint -n ($modCore + "_AnkleJnt");
			delete `parentConstraint ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJnt")`;
			select -cl;
			joint -n ($modCore + "_AnkleJntDummy");
			delete `parentConstraint ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_HipJnt")
			($modCore + "_Knee1Jnt") ($modCore + "_Knee2Jnt") ($modCore + "_AnkleJnt") ($modCore + "_AnkleJntDummy");
	
			parent ($modCore + "_Knee1Jnt") ($modCore + "_HipJnt");
			parent ($modCore + "_Knee2Jnt") ($modCore + "_Knee1Jnt"); 
			parent ($modCore + "_AnkleJnt") ($modCore + "_Knee2Jnt");
			parent ($modCore + "_AnkleJntDummy") ($modCore + "_Knee2Jnt");
		}
		//HIDE WRIST DUMMY 
		setAttr ($modCore + "_AnkleJntDummy.v") 0;
		
		select -cl;
		joint -n ($modCore + "_BallJnt");
		delete `parentConstraint ($modCore + "_BallFk_Ctrl") ($modCore + "_BallJnt")`;	
		
		select -cl;
		joint -n ($modCore + "_ToeJnt");
		delete `parentConstraint ($modCore + "_ToeFk_Ctrl") ($modCore + "_ToeJnt")`;
		
		makeIdentity -apply true -r 1 ($modCore + "_BallJnt") ($modCore + "_ToeJnt");
		
		parent ($modCore + "_BallJnt") ($modCore + "_AnkleJnt");
		parent ($modCore + "_ToeJnt") ($modCore + "_BallJnt");
	
		//KNEE ORIENTATION
		if (`objExists ($modCore + "_KneeJnt")`)
		{
			if ($kneeLocCheck < -0.0001)
			{
				setAttr ($modCore + "_KneeJnt.preferredAngleY") (-60);
			}
			else
			{
				setAttr ($modCore + "_KneeJnt.preferredAngleY") (60);
			}
		}
		else
		{
			if ($kneeLocCheck < -0.0001)
			{
				setAttr ($modCore + "_Knee1Jnt.preferredAngleY") (-30);
			}
			else
			{
				setAttr ($modCore + "_Knee1Jnt.preferredAngleY") (30);
			}			
		}
		
		////////////////////Ik/Fk JOINTS////////////////////////////////////	
		//LEG Fk
		duplicate -n ($modCore + "_HipJntFk") ($modCore + "_HipJnt");
		select ($modCore + "_HipJntFk");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			rename ($modCore + "_KneeJntFk");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntFk");
			pickWalk -d right;
			delete;  
		}
		else
		{
			rename ($modCore + "_Knee1JntFk");
			pickWalk -d down;
			rename ($modCore + "_Knee2JntFk");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntFk");
			pickWalk -d right;
			delete;
		}
		select ($modCore + "_AnkleJntFk");
		pickWalk -d down;
		rename ($modCore + "_BallJntFk");
		pickWalk -d down;
		rename ($modCore + "_ToeJntFk");
		
		//LEG Ik
		duplicate -n ($modCore + "_HipJntIk") ($modCore + "_HipJnt");
		select ($modCore + "_HipJntIk");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			rename ($modCore + "_KneeJntIk");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntIk");
			pickWalk -d right;
			delete;
		}
		else
		{
			rename ($modCore + "_Knee1JntIk");
			pickWalk -d down;
			rename ($modCore + "_Knee2JntIk");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntIk");
			pickWalk -d right;
			delete;
		}
		
		select ($modCore + "_AnkleJntIk");
		pickWalk -d down;
		rename ($modCore + "_BallJntIk");
		pickWalk -d down;
		rename ($modCore + "_ToeJntIk");
		
		//DETACH Fk LEG JOINTS FOR SCALE COMPENSATION
	
		parent -w ($modCore + "_AnkleJntFk");
		group -n ($modCore + "_AnkleJntFkGrp1") ($modCore + "_AnkleJntFk");
		group -n ($modCore + "_AnkleJntFkGrp2") ($modCore + "_AnkleJntFkGrp1");
		$lAnkleLocation = `xform -q -ws -t ($modCore + "_AnkleJnt")`;
		move $lAnkleLocation[0] $lAnkleLocation[1] $lAnkleLocation[2] ($modCore + "_AnkleJntFkGrp1.scalePivot") ($modCore + "_AnkleJntFkGrp1.rotatePivot") ;
	
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			parentConstraint -mo ($modCore + "_KneeJntFk") ($modCore + "_AnkleJntFkGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Knee2JntFk") ($modCore + "_AnkleJntFkGrp2");
		}
			
		$lKneeLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			$lKneeLocation = `xform -q -ws -t ($modCore + "_KneeJnt")`;
			move $lKneeLocation[0] $lKneeLocation[1] $lKneeLocation[2] ($modCore + "_AnkleJntFkGrp2.scalePivot") ($modCore + "_AnkleJntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJntFkGrp1");
			parentConstraint -mo ($modCore + "_KneeJntFk") ($modCore + "_AnkleJntFkGrp2");
		
			parent -w ($modCore + "_KneeJntFk");
			group -n ($modCore + "_KneeJntFkGrp1") ($modCore + "_KneeJntFk");
			group -n ($modCore + "_KneeJntFkGrp2") ($modCore + "_KneeJntFkGrp1");
			$lHipLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
			move $lKneeLocation[0] $lKneeLocation[1] $lKneeLocation[2] ($modCore + "_KneeJntFkGrp1.scalePivot") ($modCore + "_KneeJntFkGrp1.rotatePivot") ;
			move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_KneeJntFkGrp2.scalePivot") ($modCore + "_KneeJntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_KneeFk_Ctrl") ($modCore + "_KneeJntFkGrp1");
			parentConstraint -mo ($modCore + "_HipJntFk") ($modCore + "_KneeJntFkGrp2");
		}
		else
		{
			$lKnee2Location = `xform -q -ws -t ($modCore + "_Knee2Jnt")`;
			move $lKnee2Location[0] $lKnee2Location[1] $lKnee2Location[2] ($modCore + "_AnkleJntFkGrp2.scalePivot") ($modCore + "_AnkleJntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJntFkGrp1");
			parentConstraint -mo ($modCore + "_Knee2JntFk") ($modCore + "_AnkleJntFkGrp2");
	
			parent -w ($modCore + "_Knee1JntFk") ($modCore + "_Knee2JntFk");
			
			group -n ($modCore + "_Knee1JntFkGrp1") ($modCore + "_Knee1JntFk");
			group -n ($modCore + "_Knee1JntFkGrp2") ($modCore + "_Knee1JntFkGrp1");
			$lHipLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
			$lKnee1Location = `xform -q -ws -t ($modCore + "_Knee1Jnt")`;
			$lKnee2Location = `xform -q -ws -t ($modCore + "_Knee2Jnt")`;
			move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_Knee1JntFkGrp1.scalePivot") ($modCore + "_Knee1JntFkGrp1.rotatePivot") ;
			move $lKnee1Location[0] $lKnee1Location[1] $lKnee1Location[2] ($modCore + "_Knee1JntFkGrp2.scalePivot") ($modCore + "_Knee1JntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Knee1Fk_Ctrl") ($modCore + "_Knee1JntFkGrp1");
			parentConstraint -mo ($modCore + "_HipJntFk") ($modCore + "_Knee1JntFkGrp2");
	
			group -n ($modCore + "_Knee2JntFkGrp1") ($modCore + "_Knee2JntFk");
			group -n ($modCore + "_Knee2JntFkGrp2") ($modCore + "_Knee2JntFkGrp1");
			move $lKnee1Location[0] $lKnee1Location[1] $lKnee1Location[2] ($modCore + "_Knee2JntFkGrp1.scalePivot") ($modCore + "_Knee2JntFkGrp1.rotatePivot") ;
			move $lKnee2Location[0] $lKnee2Location[1] $lKnee2Location[2] ($modCore + "_Knee2JntFkGrp2.scalePivot") ($modCore + "_Knee2JntFkGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Knee2Fk_Ctrl") ($modCore + "_Knee2JntFkGrp1");
			parentConstraint -mo ($modCore + "_Knee1JntFk") ($modCore + "_Knee2JntFkGrp2");
		}
		
		//CONSTRAIN HIP JOINTS TO ATTACH NODE
		pointConstraint ($modCore + "_HipFk_Ctrl") ($modCore + "_HipJnt");
		delete `pointConstraint ($modCore + "_HipFk_Ctrl") ($modCore + "_HipJntFk")`;
		pointConstraint ($modCore + "_HipFk_Ctrl") ($modCore + "_HipJntIk");
	
		$anklePosition = `xform -ws -q -rp ($modCore + "_AnkleJnt")`;
		$ballLocation = `xform -q -t ($modCore + "_BallJnt")`;
		$toeLocation = `xform -q -t ($modCore + "_ToeJnt")`;

		//FOOT Ik CONTROL
		if ($ea == 0)
		{
			circle -n ($modCore + "_FootIk_Ctrl") -nr 0 1 0 -r 2.5 -s 16 -ch 0;
		
			scale -r 0.4 1 1 ($modCore + "_FootIk_Ctrl.cv[13]") ($modCore + "_FootIk_Ctrl.cv[5]");
			scale -r 0.6 1 1 ($modCore + "_FootIk_Ctrl.cv[14]") ($modCore + "_FootIk_Ctrl.cv[4]");
			scale -r 0.78 1 1 ($modCore + "_FootIk_Ctrl.cv[3]") ($modCore + "_FootIk_Ctrl.cv[15]"); 
			scale -r 0.78 1 1 ($modCore + "_FootIk_Ctrl.cv[12]") ($modCore + "_FootIk_Ctrl.cv[6]");
			scale -r 0.89 1 1 ($modCore + "_FootIk_Ctrl.cv[7]") ($modCore + "_FootIk_Ctrl.cv[11]");
			move -r -os -wd 0 0.565 0 ($modCore + "_FootIk_Ctrl.cv[5]") ($modCore + "_FootIk_Ctrl.cv[13]");
			move -r -os -wd 0 0.1 0 ($modCore + "_FootIk_Ctrl.cv[4]") ($modCore + "_FootIk_Ctrl.cv[14]") ($modCore + "_FootIk_Ctrl.cv[6]") ($modCore + "_FootIk_Ctrl.cv[12]");
			move -r 0 0 1.5 ($modCore + "_FootIk_Ctrl.cv[0:15]");
		}
		else
		{
			curve -n ($modCore + "_FootIk_Ctrl") -d 1 -p 1.277418 0.2 -1 -p -1.277418 0.2 -1 -p -1.277418 1.400898 -1 -p 1.277418 1.400898 -1 -p 1.277418 0.2 -1 -p 1.277418 0.2 2.790869 -p -1.277418 0.2 2.790869 -p -1.277418 0.2 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			rename `listRelatives ($modCore + "_FootIk_Ctrl")` ($modCore + "_FootIk_CtrlShape");
			curve -n ($modCore + "_FootIk2_Ctrl") -d 1 -p 1.277418 1.400898 -1 -p 1.277418 1.400898 2.102458 -p 1.277418 0.2 2.790869 -k 0 -k 1 -k 2 ;
			rename `listRelatives ($modCore + "_FootIk2_Ctrl")` ($modCore + "_FootIk2_CtrlShape");
			curve -n ($modCore + "_FootIk3_Ctrl") -d 1 -p -1.277418 1.400898 -1 -p -1.277418 1.400898 2.102458 -p -1.277418 0.2 2.790869 -k 0 -k 1 -k 2 ;
			rename `listRelatives ($modCore + "_FootIk3_Ctrl")` ($modCore + "_FootIk3_CtrlShape");
			curve -n ($modCore + "_FootIk4_Ctrl") -d 1 -p -1.277418 1.400898 2.102458 -p 1.277418 1.400898 2.102458 -k 0 -k 1 ;
			rename `listRelatives ($modCore + "_FootIk4_Ctrl")` ($modCore + "_FootIk4_CtrlShape");
			parent -r -s ($modCore + "_FootIk2_CtrlShape") ($modCore + "_FootIk3_CtrlShape") ($modCore + "_FootIk4_CtrlShape") ($modCore + "_FootIk_Ctrl");
			delete ($modCore + "_FootIk2_Ctrl") ($modCore + "_FootIk3_Ctrl") ($modCore + "_FootIk4_Ctrl");
			move -r -os 0 0 0.035 ($modCore + "_FootIk_Ctrl");
		}
		scale -r ($footLength[0]/5) ($footLength[0]/4.2) ($footLength[0]/3.4) ($modCore + "_FootIk_Ctrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_FootIk_Ctrl");
		group -n ($modCore + "_FootIk_CtrlGrp") ($modCore + "_FootIk_Ctrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_FootIk_Ctrl.rotateOrder") 1;

		delete `parentConstraint ("RRM_" + $prfx + $core + "_Ground") ($modCore + "_FootIk_CtrlGrp")`;
		move $anklePosition[0] $anklePosition[1] $anklePosition[2] ($modCore + "_FootIk_Ctrl.scalePivot") ($modCore + "_FootIk_Ctrl.rotatePivot") ;

		//FOOT PIVOT CONTROL
		RRM_MoveablePivot_Ctrl(($modCore + "_FootPivot_Ctrl"), ($footLength[0]/10));
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_FootPivot_CtrlGrp")`;
		setAttr ($modCore + "_FootPivot_CtrlGrp.ty") 0;
		parent ($modCore + "_FootPivot_CtrlGrp") ($modCore + "_FootIk_Ctrl");
		
		

		//FOOT
		//PIVOTS
		addAttr -ln "pivots" -at bool ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 -l true ($modCore + "_FootIk_Ctrl.pivots");

		addAttr -ln "toe_pivot" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.toe_pivot");
		addAttr -ln "ball_pivot" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.ball_pivot");
		addAttr -ln "heel_pivot" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.heel_pivot");

		//ROLLS
		addAttr -ln "rolls" -at bool ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 -l true ($modCore + "_FootIk_Ctrl.rolls");

		addAttr -ln "ball_roll" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.ball_roll");
		addAttr -ln "toe_heel_roll" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.toe_heel_roll");
		addAttr -ln "bank_in_out" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.bank_in_out");
		addAttr -ln "toe_roll" -at double -min -10 -max 10 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.toe_roll");

		//LEGS
		addAttr -ln "legs" -at bool ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 -l true ($modCore + "_FootIk_Ctrl.legs");	

		addAttr -ln "stretch" -at double -min 0 -max 1 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.stretch");
		addAttr -ln "dampen_softness" -at double -min 0 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.dampen_softness");

		addAttr -ln "limbScale" -at double -min 0.01 -dv 1 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.limbScale");

		addAttr -ln "kneeLock" -at double -min 0 -max 1 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.kneeLock");

		//SUB CONTROLS VIS
		addAttr -ln "subControlsVis" -at bool -dv 1 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.subControlsVis");
		setAttr ($modCore + "_FootIk_Ctrl.subControlsVis") 1;
		
		addAttr -ln "footPivot_CtrlVis" -at bool ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.footPivot_CtrlVis");
		setAttr ($modCore + "_FootIk_Ctrl.footPivot_CtrlVis") 0;
		for ($shape in `listRelatives -c -type "nurbsCurve" ($modCore + "_FootPivot_Ctrl")`)
		{
			connectAttr -f ($modCore + "_FootIk_Ctrl.footPivot_CtrlVis") ($shape + ".v");
		}
		
		//HEEL Ik CONTROL
		circle -n ($modCore + "_HeelIk_Ctrl") -nr 0 1 0 -r 1 -ch 0;
		move -r -0.25107 1.330277 2.206782 ($modCore + "_HeelIk_Ctrl.cv[1]") ;
		move -r 0.254402 1.084741 1.162191 ($modCore + "_HeelIk_Ctrl.cv[0]") ;
		move -r 0.0513063 0.450871 -0.204969 ($modCore + "_HeelIk_Ctrl.cv[7]") ;
		move -r 0.187803 0.259426 -0.108661 ($modCore + "_HeelIk_Ctrl.cv[6]") ;
		move -r -0.276837 0.154413 0.307813 ($modCore + "_HeelIk_Ctrl.cv[5]") ;
		move -r -0.395115 0.259426 -0.0326967 ($modCore + "_HeelIk_Ctrl.cv[4]") ;
		move -r 0.00260226 0.47359 -0.204969 ($modCore + "_HeelIk_Ctrl.cv[3]") ;
		move -r -0.369241 1.189888 1.331089 ($modCore + "_HeelIk_Ctrl.cv[2]") ;
		move -r -os -wd 0 0 0.8 ($modCore + "_HeelIk_Ctrl.cv[0:7]") ;
		scale -r -p 0cm 0cm 0cm $multiplier 1 -1 ($modCore + "_HeelIk_Ctrl.cv[0:7]");
		scale -r ($footLength[0]/5) ($footLength[0]/3.7) ($footLength[0]/7) ($modCore + "_HeelIk_Ctrl");
		//makeIdentity -apply 1 -s 1 ($modCore + "_HeelIk_Ctrl");
		//move -r -os -wd -.001 0 0.45 ($modCore + "_HeelIk_Ctrl.cv[0:7]");
		rotate -r -os ($multiplier * 90) 0 ($multiplier * 90) ($modCore + "_HeelIk_Ctrl");
		if ($crntSide == "right")
		{
			rotate -r 0 0 180 ($modCore + "_HeelIk_Ctrl");
		}
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_HeelIk_Ctrl");
		group -n ($modCore + "_HeelIk_CtrlSdkGrp") ($modCore + "_HeelIk_Ctrl"); xform -os -piv 0 0 0;
		group -n ($modCore + "_HeelIk_CtrlGrp") ($modCore + "_HeelIk_CtrlSdkGrp"); xform -os -piv 0 0 0;
		parent ($modCore + "_HeelIk_CtrlGrp") ($modCore + "_FootPivot_Ctrl");

		delete `parentConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_HeelIk_CtrlGrp")`;
		rotate -r -os ($multiplier * -90) ($multiplier * -90) 0 ($modCore + "_HeelIk_CtrlGrp");
		makeIdentity -apply true -t 1 ($modCore + "_HeelIk_CtrlGrp");

		connectAttr -f ($modCore + "_FootIk_Ctrl.subControlsVis") ($modCore + "_HeelIk_Ctrl.v");

		//TOE Ik CONTROL
		circle -n ($modCore + "_ToeIk_Ctrl") -nr 0 1 0 -r 1 -ch 0;
		move -r ($multiplier * -0.251) 1.330 2.207($modCore + "_ToeIk_Ctrl.cv[1]") ;
		move -r 0.254 1.085 1.162($modCore + "_ToeIk_Ctrl.cv[0]") ;
		move -r 0.051 0.451 -0.205 ($modCore + "_ToeIk_Ctrl.cv[7]") ;
		move -r 0.188 0.259 -0.109 ($modCore + "_ToeIk_Ctrl.cv[6]") ;
		move -r -0.277 0.154 0.308 ($modCore + "_ToeIk_Ctrl.cv[5]") ;
		move -r -0.395 0.259 -0.033 ($modCore + "_ToeIk_Ctrl.cv[4]") ;
		move -r 0.003 0.474 -0.205 ($modCore + "_ToeIk_Ctrl.cv[3]") ;
		move -r -0.369 1.190 1.331 ($modCore + "_ToeIk_Ctrl.cv[2]") ;
		move -r -os -wd 0 0 0.9 ($modCore + "_ToeIk_Ctrl.cv[0:7]") ;
		scale -r -p 0cm 0cm 0cm $multiplier 1 1 ($modCore + "_ToeIk_Ctrl.cv[0:7]");
		//move -r -.001 0 1.85 ($modCore + "_ToeIk_Ctrl.cv[0:7]");
		scale -r ($footLength[0]/5) ($footLength[0]/4) ($footLength[0]/4.4) ($modCore + "_ToeIk_Ctrl");
		rotate -r -os ($multiplier * 90) 0 90 ($modCore + "_ToeIk_Ctrl");

		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ToeIk_Ctrl");
		group -n ($modCore + "_ToeIk_CtrlSdkGrp") ($modCore + "_ToeIk_Ctrl"); xform -os -piv 0 0 0;
		group -n ($modCore + "ToeIk_CtrlGrp") ($modCore + "_ToeIk_CtrlSdkGrp"); xform -os -piv 0 0 0;
		parent ($modCore + "ToeIk_CtrlGrp") ($modCore + "_HeelIk_Ctrl");

		delete `parentConstraint ($modCore + "_ToeJnt") ($modCore + "ToeIk_CtrlGrp")`;
		setAttr ($modCore + "ToeIk_CtrlGrp.tz") 0;
		
		//BALL Ik CONTROL
		circle -n ($modCore + "_BallIk_Ctrl") -nr 0 0 1 -r 1.9 -ch 0;
		move -r -os -wd 0 1.4458 0 ($modCore + "_BallIk_Ctrl.cv[4]") ($modCore + "_BallIk_Ctrl.cv[6]");
		move -r -os -wd 0 1.949201 0 ($modCore + "_BallIk_Ctrl.cv[5]");
		move -r -os -wd 0 0.02789 0 ($modCore + "_BallIk_Ctrl.cv[0]") ($modCore + "_BallIk_Ctrl.cv[2]") ($modCore + "_BallIk_Ctrl.cv[3]") ($modCore + "_BallIk_Ctrl.cv[7]");
		//move -r -os -wd 0 0.3 0 ($modCore + "_BallIk_Ctrl.cv[0]") ($modCore + "_BallIk_Ctrl.cv[2]");
		move -r -os -wd 0 0.45 0 ($modCore + "_BallIk_Ctrl.cv[1]");
		scale -r ($footLength[0]/8) ($footLength[0]/8) 1 ($modCore + "_BallIk_Ctrl");
		rotate -r -os ($multiplier * 90) 0 90 ($modCore + "_BallIk_Ctrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_BallIk_Ctrl");
		group -n ($modCore + "_BallIk_CtrlSdkGrp") ($modCore + "_BallIk_Ctrl"); xform -os -piv 0 0 0;
		group -n ($modCore + "_BallIk_CtrlGrp") ($modCore + "_BallIk_CtrlSdkGrp"); xform -os -piv 0 0 0;
		parent ($modCore + "_BallIk_CtrlGrp") ($modCore + "_ToeIk_Ctrl");
		
		delete `parentConstraint ($modCore + "_BallJnt") ($modCore + "_BallIk_CtrlGrp")`; 
		

		//TOE IK CONTROL		
		circle -n ($modCore + "_ToePivotIk_Ctrl") -nr 0 0 1 -r 1.9 -ch 0;
		move -r -os -wd 0 1.4458 0 ($modCore + "_ToePivotIk_Ctrl.cv[4]") ($modCore + "_ToePivotIk_Ctrl.cv[6]");
		move -r -os -wd 0 1.949201 0 ($modCore + "_ToePivotIk_Ctrl.cv[5]");
		move -r -os -wd 0 0.02789 0 ($modCore + "_ToePivotIk_Ctrl.cv[0]") ($modCore + "_ToePivotIk_Ctrl.cv[2]") ($modCore + "_ToePivotIk_Ctrl.cv[3]") ($modCore + "_ToePivotIk_Ctrl.cv[7]");
		scale -r ($footLength[0]/10) ($footLength[0]/8) 1 ($modCore + "_ToePivotIk_Ctrl");
		rotate -r -os ($multiplier * 90) 0 90 ($modCore + "_ToePivotIk_Ctrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ToePivotIk_Ctrl");
		group -n ($modCore + "_ToePivotIk_CtrlSdkGrp") ($modCore + "_ToePivotIk_Ctrl"); xform -os -piv 0 0 0;
		group -n ($modCore + "_ToePivotIk_CtrlGrp") ($modCore + "_ToePivotIk_CtrlSdkGrp"); xform -os -piv 0 0 0;
		//parent ($modCore + "_ToePivotIk_CtrlGrp") ($modCore + "_ToePivotIk_Ctrl");
		
		delete `parentConstraint ($modCore + "_BallJnt") ($modCore + "_ToePivotIk_CtrlGrp")`;
		$toeLength = `getAttr ($modCore + "_ToeJnt.translateX")`;
		move -r -os -wd $toeLength 0 0 ($modCore + "_ToePivotIk_Ctrl.cv[0:7]");
		//move $ballLocation[0] $ballLocation[1] $ballLocation[2] ($modCore + "_ToePivotIk_Ctrl.scalePivot") ($modCore + "_ToePivotIk_Ctrl.rotatePivot") ;




		//FOOT Ik LOCATORS
		spaceLocator -n ($modCore + "_FootToePivotLctr");
		delete `pointConstraint ($modCore + "_BallJnt") ($modCore + "_FootToePivotLctr")`;
		setAttr ($modCore + "_FootToePivotLctr.ty") 0;
		delete `aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_FootIk_Ctrl")
		($modCore + "_ToeJnt") ($modCore + "_FootToePivotLctr")`;
		parent ($modCore + "_ToePivotIk_CtrlGrp") ($modCore + "_FootToePivotLctr");
	
		select ($modCore + "_AnkleJntIk.rotatePivot") ($modCore + "_BallJntIk.rotatePivot") ; 
		ikHandle -n ($modCore + "_BallIkHandle") -sol ikSCsolver;
		parent ($modCore + "_BallIkHandle") ($modCore + "_BallIk_Ctrl");
		setAttr ($modCore + "_BallIkHandle.v") 0;
		select ($modCore + "_BallJntIk.rotatePivot") ($modCore + "_ToeJntIk.rotatePivot") ; 
		ikHandle -n ($modCore + "_ToeIkHandle") -sol ikSCsolver;
		parent ($modCore + "_ToeIkHandle") ($modCore + "_ToePivotIk_Ctrl");
	
		spaceLocator -n ($modCore + "_BallSwivelLctr");
		delete `pointConstraint ($modCore + "_BallJnt") ($modCore + "_BallSwivelLctr")`;
		setAttr ($modCore + "_BallSwivelLctr.ty") 0;
		parent ($modCore + "_BallSwivelLctr") ($modCore + "_ToeIk_Ctrl");
		makeIdentity -apply false -r 1 ($modCore + "_BallSwivelLctr");
		
		spaceLocator -n ($modCore + "_FootBankInLctr");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_FootBankIn") ($modCore + "_FootBankInLctr")`;
		spaceLocator -n ($modCore + "_FootBankOutLctr");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_FootBankOut") ($modCore + "_FootBankOutLctr")`;

	
		parent ($modCore + "_FootBankInLctr") ($modCore + "_BallSwivelLctr");
		parent ($modCore + "_FootBankOutLctr") ($modCore + "_FootBankInLctr");
		parent ($modCore + "_FootToePivotLctr") ($modCore + "_FootBankOutLctr");
		
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_HeelIk_Ctrl");
		
		//MOVE BALL CONTROL WITH BALL PIVOT
		parentConstraint -mo ($modCore + "_FootBankOutLctr") ($modCore + "_BallIk_CtrlGrp");
		
		//CREATE OFFSETTING VALUES ON PARENT CTRL GRP
		shadingNode -asUtility multiplyDivide -n ($modCore + "_FootPivot_MD");
		connectAttr -f ($modCore + "_FootPivot_Ctrl.translate") ($modCore + "_FootPivot_MD.input1");
		setAttr (($modCore + "_FootPivot_MD.input2"), -1, -1, -1);
		connectAttr -f ($modCore + "_FootPivot_MD.output") ($modCore + "_HeelIk_CtrlGrp.translate");		
		
		setAttr -l 0 -k 1 ($modCore + "_HipJntIk.rx");
		setAttr -l 0 -k 1 ($modCore + "_HipJntIk.ry");
		setAttr -l 0 -k 1 ($modCore + "_HipJntIk.rz");
		if (`objExists ($modCore + "_KneeJntIk")`)
		{
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIk.rx");
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIk.ry");
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIk.rz");
		}
		else
		{
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIk.rx");
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIk.ry");
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIk.rz");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIk.rx");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIk.ry");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIk.rz");
		}
	
		//KNEE Ik CONTROL
		if ($ea == 0)
		{
			curve -n ($modCore + "_KneeIk_Ctrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
			-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
			-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
			-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
			-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
			-k 23 -k 24 ;
			rename `listRelatives -c ($modCore + "_KneeIk_Ctrl")` ($modCore + "_KneeIk_CtrlShape");
			
			move -r 0 0 -0.95 ($modCore + "_KneeIk_Ctrl.cv[12]") ($modCore + "_KneeIk_Ctrl.cv[0]") ($modCore + "_KneeIk_Ctrl.cv[24]") ($modCore + "_KneeIk_Ctrl.cv[18]") ($modCore + "_KneeIk_Ctrl.cv[6]") ;
			move -r 0 0 0.65 ($modCore + "_KneeIk_Ctrl.cv[3]") ($modCore + "_KneeIk_Ctrl.cv[9]") ($modCore + "_KneeIk_Ctrl.cv[15]") ($modCore + "_KneeIk_Ctrl.cv[21]") ;
			scale -r -os 0.75 0.75 0.75 ($modCore + "_KneeIk_Ctrl");
			makeIdentity -apply 1 -s 1 ($modCore + "_KneeIk_Ctrl");
		}
		else
		{
			curve -n ($modCore + "_KneeIk_Ctrl") -d 1 -p 1 -1 -1 -p 1 1 -1 -p 1 1 1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 -1 1 -p 1 -1 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			rename `listRelatives -c ($modCore + "_KneeIk_Ctrl")` ($modCore + "_KneeIk_CtrlShape");
			curve -n ($modCore + "_KneeIk_Ctrl1") -d 1 -p 1 1 -1 -p -1 1 -1 -p -1 -1 -1 -k 0 -k 1 -k 2 ;
			rename `listRelatives -c ($modCore + "_KneeIk_Ctrl1")` ($modCore + "_KneeIk_Ctrl1Shape");
			curve -n ($modCore + "_KneeIk_Ctrl2") -d 1 -p 1 1 1 -p -1 1 1 -p -1 -1 1 -k 0 -k 1 -k 2 ;
			rename `listRelatives -c ($modCore + "_KneeIk_Ctrl2")` ($modCore + "_KneeIk_Ctrl2Shape");
			curve -n ($modCore + "_KneeIk_Ctrl3") -d 1 -p -1 1 1 -p -1 1 -1 -k 0 -k 1 ;
			rename `listRelatives -c ($modCore + "_KneeIk_Ctrl3")` ($modCore + "_KneeIk_Ctrl3Shape");
			parent -r -s ($modCore + "_KneeIk_Ctrl1Shape") ($modCore + "_KneeIk_Ctrl2Shape") ($modCore + "_KneeIk_Ctrl3Shape") ($modCore + "_KneeIk_Ctrl");
			delete ($modCore + "_KneeIk_Ctrl1") ($modCore + "_KneeIk_Ctrl2") ($modCore + "_KneeIk_Ctrl3");
		}

		group -n ($modCore + "_KneeIk_CtrlGrp") ($modCore + "_KneeIk_Ctrl"); xform -os -piv 0 0 0;

		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_KneeIk_CtrlGrp")`;
			setAttr (($modCore + "_KneeIk_CtrlGrp.scale"), ($legLength / 15), ($legLength / 15), ($legLength / 15));
			move -r -os -wd 0 0 ($legLength * 1.2) ($modCore + "_KneeIk_CtrlGrp");
		}
		else
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_KneeIk_CtrlGrp")`;
			setAttr (($modCore + "_KneeIk_CtrlGrp.scale"), ($legLength / 15), ($legLength / 15), ($legLength / 15));
			move -r -os -wd 0 0 ($legLength * 1.2) ($modCore + "_KneeIk_CtrlGrp");
		}
		makeIdentity -apply true -t 0 -r 0 -s 1 ($modCore + "_KneeIk_CtrlGrp");

		//LOWER LEG CONTROL
		if (`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			curve -n ($modCore + "_LowerLegIk_Ctrl") -d 1 -p -1 0 4 -p -4 0 4 -p -3 0 5 -p -2 0 6 -p -1 0 7 -p 0 0 8 -p 1 0 7 -p 2 0 6 -p 3 0 5 -p 4 0 4 -p 1 0 4 -p 1 0 3 -p 1 0 2 -p 1 0 1 -p 1 0 0 -p 1 0 -1 -p 1 0 -2 -p 1 0 -3 -p 1 0 -4 -p 4 0 -4 -p 3 0 -5 -p 2 0 -6 -p 1 0 -7 -p 0 0 -8 -p -1 0 -7 -p -2 0 -6 -p -3 0 -5 -p -4 0 -4 -p -1 0 -4 -p -1 0 -3 -p -1 0 -2 -p -1 0 -1 -p -1 0 0 -p -1 0 1 -p -1 0 2 -p -1 0 3 -p -1 0 4 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 ;
			rename `listRelatives -c ($modCore + "_LowerLegIk_Ctrl")` ($modCore + "_LowerLegIk_CtrlShape");
			nonLinear -type bend -lowBound -1 -highBound 1 -curvature 15;
			$bend = `ls -sl`;
			rename $bend ($modCore + "_LowerLegIkCBend");
			rotate -a -os -90 0 -90 ($modCore + "_LowerLegIkCBend");
	
			setAttr (($modCore + "_LowerLegIk_Ctrl.scale"), ($legLength/14), ($legLength/14), ($legLength/14));
			makeIdentity -apply true -r 1 -s 1 ($modCore + "_LowerLegIk_Ctrl");
			delete -ch ($modCore + "_LowerLegIk_Ctrl");
			
			group -n ($modCore + "_LowerLegIk_CtrlGrp") ($modCore + "_LowerLegIk_Ctrl");
			group -n ($modCore + "_LowerLegIk_CtrlGrp2") ($modCore + "_LowerLegIk_CtrlGrp");
			group -n ($modCore + "_LowerLegIk_CtrlGrp3") ($modCore + "_LowerLegIk_CtrlGrp2");			
			parent ($modCore + "_LowerLegIk_CtrlGrp3") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerLegIk_CtrlGrp.rotateOrder") 1;
			setAttr ($modCore + "_LowerLegIk_CtrlGrp2.rotateOrder") 1;
			setAttr ($modCore + "_LowerLegIk_CtrlGrp3.rotateOrder") 1;
	
			spaceLocator -n ($modCore + "_lowerLegIkLctr");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_lowerLegIkLctr")`;
			parent ($modCore + "_lowerLegIkLctr") ($modCore + "_HipFk_Ctrl");
			setAttr ($modCore + "_lowerLegIkLctr.v") 0;
			
			//MOVE GROUP 3 TO BALL LOCATION AND ORIENT IT SO IT IS AIMING AT LOWER Ik CONTROL
			delete `pointConstraint ($modCore + "_FootIk_Ctrl") ($modCore + "_LowerLegIk_CtrlGrp3")`;
			delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Knee2")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIk_CtrlGrp3")`;
	
			parentConstraint -mo ($modCore + "_BallIk_Ctrl") ($modCore + "_LowerLegIk_CtrlGrp3");
			
			//LOCATOR FOR UP AXIS ON LOWER FOOT CONTROL USING ROTATE Y ONLY FROM FOOTIkC
			spaceLocator -n ($modCore + "_LowerLegIk_Ctrl_UpLctr");
			setAttr ($modCore + "_LowerLegIk_Ctrl_UpLctr.rotateOrder") 1;
			group -n ($modCore + "_LowerLegIk_Ctrl_UpLctrGrp") ($modCore + "_LowerLegIk_Ctrl_UpLctr");
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIk_Ctrl_UpLctrGrp")`;
			pointConstraint ($modCore + "_FootIk_Ctrl") ($modCore + "_LowerLegIk_Ctrl_UpLctrGrp");
			parent ($modCore + "_LowerLegIk_Ctrl_UpLctrGrp") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerLegIk_Ctrl_UpLctrGrp.v") 0;
			orientConstraint -mo -skip x -skip z ($modCore + "_FootIk_Ctrl") ($modCore + "_LowerLegIk_Ctrl_UpLctr");
			setAttr ($modCore + "_LowerLegIk_Ctrl_UpLctr_orientConstraint1.interpType") 2;
			
			aimConstraint -mo -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_LowerLegIk_Ctrl_UpLctr")
			($modCore + "_lowerLegIkLctr") ($modCore + "_LowerLegIk_CtrlGrp2");
			spaceLocator -n ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset");
			delete `pointConstraint ($modCore + "_FootIk_Ctrl") ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset")`;
			parent ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset") ($modCore + "_BallIk_Ctrl");
			delete `orientConstraint ($modCore + "_LowerLegIk_CtrlGrp2") ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset")`;
			parentConstraint -mo ($modCore + "_BallIk_Ctrl") ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset");

			orientConstraint -mo ($modCore + "_LowerLegIk_CtrlGrp2") ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset") ($modCore + "_LowerLegIk_CtrlGrp");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIk_Ctrl")`;
			$AnklePos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Ankle")`;
			move -a $AnklePos[0] $AnklePos[1] $AnklePos[2] ($modCore + "_LowerLegIk_Ctrl.scalePivot") ($modCore + "_LowerLegIk_Ctrl.rotatePivot") ;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_LowerLegIk_Ctrl");
			
			//ADD ORIENTATION ATTRIBUTE FOR LOWER LEG Ik_Ctrl ORIENTATION
			addAttr -ln "autoOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_LowerLegIk_Ctrl");
			setAttr -e -k 1 ($modCore + "_LowerLegIk_Ctrl.autoOrient");
			connectAttr -f ($modCore + "_LowerLegIk_Ctrl.autoOrient") ($modCore + "_LowerLegIk_CtrlGrp_orientConstraint1." + $modCore + "_LowerLegIk_CtrlGrp2W0");
			
			shadingNode -asUtility reverse -n ($modCore + "_LowerLegIk_Ctrl_Reverse");
			connectAttr -f ($modCore + "_LowerLegIk_Ctrl.autoOrient") ($modCore + "_LowerLegIk_Ctrl_Reverse.inputX");
			connectAttr -f ($modCore + "_LowerLegIk_Ctrl_Reverse.outputX") ($modCore + "_LowerLegIk_CtrlGrp_orientConstraint1." + $modCore + "_LowerLegIk_CtrlGrp2_LctrOffsetW1");
			setAttr ($modCore + "_LowerLegIk_CtrlGrp2_LctrOffset.v") 0;

			spaceLocator -n ($modCore + "_Lower_KneeIkOffsetLctr");
			delete `pointConstraint ($modCore + "_Knee2Jnt") ($modCore + "_Lower_KneeIkOffsetLctr")`;
		}
		
		RRM_LimbStretch($modRigName, $rigGrp, "leg", $prfx, $oppPrfx, $crntSide, $oppSide, $behavior, $behaviorMultiplier, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode, $lPrfx, $rPrfx, $ea);
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//LEG
		
		//Fk

		//HIP ORIENT
		addAttr -ln "hipOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_HipFk_Ctrl");
		setAttr -e -k 1 ($modCore + "_HipFk_Ctrl.hipOrient");

		addAttr -ln "alwaysVisible" -at bool -min 0 -max 1 -dv 0 ($modCore + "_HipFk_Ctrl");
		setAttr -e -k 1 ($modCore + "_HipFk_Ctrl.alwaysVisible");


		$lHipLocation = `xform -q -ws -t ($modCore + "_HipFk_CtrlGrp")`;
		move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_HipFk_CtrlGrp.scalePivot") ($modCore + "_HipFk_CtrlGrp.rotatePivot") ;
		if ($modAttachNode != "ROOT")
		{
			parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
			($modRigName + "" + $modAttachNode + "Jnt") ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_HipFk_CtrlGrp");

			setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW0");
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1");
			setAttr ($modCore + "_HipFk_Ctrl.hipOrient") 0;
			setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW0") 0;
			setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1") 1;
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW0");
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1");
			setAttr ($modCore + "_HipFk_Ctrl.hipOrient") 1;
			
			keyTangent -itt spline -ott spline($modCore + "_HipFk_CtrlGrp_parentConstraint1_" + $modRigName + "" + $modAttachNode + "JntW0")
			($modCore + "_HipFk_CtrlGrp_parentConstraint1_" + $modRigName + "MAIN_Inner_CtrlW1");
		}
		else
		{
			parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
			($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_HipFk_CtrlGrp");

			setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0");
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1");
			setAttr ($modCore + "_HipFk_Ctrl.hipOrient") 0;
			setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0") 0;
			setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1") 1;
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0");
			setDrivenKeyframe -currentDriver ($modCore + "_HipFk_Ctrl.hipOrient") ($modCore + "_HipFk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1");
			setAttr ($modCore + "_HipFk_Ctrl.hipOrient") 1;
			
			keyTangent -itt spline -ott spline($modCore + "_HipFk_CtrlGrp_parentConstraint1_" + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0")
			($modCore + "_HipFk_CtrlGrp_parentConstraint1_" + $modRigName + "MAIN_Inner_CtrlW1");
		}
		setAttr ($modCore + "_HipFk_CtrlGrp_parentConstraint1.interpType") 2;
		

		parentConstraint -mo ($modCore + "_HipFk_Ctrl") ($modCore + "_HipJntFk");
	
		connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_HipJntFk.scaleX");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			parentConstraint -mo ($modCore + "_HipFk_Ctrl") ($modCore + "_KneeFk_CtrlGrp");
		
			parentConstraint -mo ($modCore + "_KneeFk_Ctrl") ($modCore + "_KneeJntFk");
			parentConstraint -mo ($modCore + "_KneeFk_Ctrl") ($modCore + "_AnkleFk_CtrlGrp");
	
			connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_KneeFk_Ctrl.scaleX");
		}
		else
		{
			parentConstraint -mo ($modCore + "_HipFk_Ctrl") ($modCore + "_Knee1Fk_CtrlGrp");
		
			parentConstraint -mo ($modCore + "_Knee1Fk_Ctrl") ($modCore + "_Knee1JntFk");
			parentConstraint -mo ($modCore + "_Knee1Fk_Ctrl") ($modCore + "_Knee2Fk_CtrlGrp");
	
			parentConstraint -mo ($modCore + "_Knee2Fk_Ctrl") ($modCore + "_Knee2JntFk");
			parentConstraint -mo ($modCore + "_Knee2Fk_Ctrl") ($modCore + "_AnkleFk_CtrlGrp");
	
			connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_Knee1Fk_Ctrl.scaleX");
			connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_Knee2Fk_Ctrl.scaleX");
		}
			
		parentConstraint -mo ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleJntFk");
		setAttr ($modCore + "_AnkleJntFk_parentConstraint1.interpType") 2;
		
		parentConstraint -mo ($modCore + "_AnkleFk_Ctrl") ($modCore + "_BallFk_CtrlGrp");
		parentConstraint -mo ($modCore + "_BallFk_Ctrl") ($modCore + "_BallJntFk");
		setAttr ($modCore + "_BallFk_CtrlGrp_parentConstraint1.interpType") 2;
		
		parentConstraint -mo ($modCore + "_BallFk_Ctrl") ($modCore + "_ToeFk_CtrlGrp");
		parentConstraint -mo ($modCore + "_ToeFk_Ctrl") ($modCore + "_ToeJntFk");
		setAttr ($modCore + "_ToeFk_CtrlGrp_parentConstraint1.interpType") 2;
		setAttr ($modCore + "_ToeJntFk_parentConstraint1.interpType") 2;
		
		//CONNECT SCALE TO FK CONTROLS
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_KneeJntFk.scaleX");
		}
		else
		{
			connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_Knee1JntFk.scaleX");
			connectAttr -f ($modCore + "_HipFk_Ctrl.scaleX") ($modCore + "_Knee2JntFk.scaleX");
		}
	
		//Ik
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select ($modCore + "_HipJntIk.rotatePivot") ($modCore + "_AnkleJntIk.rotatePivot") ;
			ikHandle -n ($modCore + "_LegIkHandle") -sol ikRPsolver;
			parent ($modCore + "_LegIkHandle") ($modCore + "_LimbLengthAttachLctr");
		}
		else
		{
			select ($modCore + "_Knee2JntIk.rotatePivot") ($modCore + "_AnkleJntIk.rotatePivot");
			ikHandle -n ($modCore + "_LowerLegIkHandle") -sol ikSCsolver;
			parent ($modCore + "_LowerLegIkHandle") ($modCore + "_BallIk_Ctrl");
			setAttr ($modCore + "_LowerLegIkHandle.v") 0;
	
			select ($modCore + "_HipJntIk.rotatePivot") ($modCore + "_Knee2JntIk.rotatePivot") ;
			ikHandle -n ($modCore + "_LegIkHandle") -sol ikRPsolver;
			parent ($modCore + "_LegIkHandle") ($modCore + "_LimbLengthAttachLctr");
		}
		poleVectorConstraint ($modCore + "_KneeIk_Ctrl") ($modCore + "_LegIkHandle") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z -weight 1 ($modCore + "_FootIk_Ctrl") ($modCore + "_AnkleJntIk");
		setAttr ($modCore + "_AnkleJntIk_parentConstraint1.interpType") 2;	
		
		//CONNECT Ik AND Fk JOINTS TO ORIGINALS
		//HIP
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIkFk_BlndScale");
		connectAttr -f ($modCore + "_HipJntFk.scale") ($modCore + "_HipJntIkFk_BlndScale.color1");
		connectAttr -f ($modCore + "_HipJntIk.scale") ($modCore + "_HipJntIkFk_BlndScale.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_HipJntIkFk_BlndScale.blender");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HipVolume_MD");
		setAttr ($modCore + "_HipVolume_MD.input1X") 1;
		setAttr ($modCore + "_HipVolume_MD.operation") 2;
		connectAttr -f ($modCore + "_HipJntIkFk_BlndScale.outputR") ($modCore + "_HipVolume_MD.input2X");
		
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIkFk_AutoBlnd");
		setAttr ($modCore + "_HipJntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_HipVolume_MD.outputX") ($modCore + "_HipJntIkFk_AutoBlnd.color1R");
		connectAttr -f ($modCore + "_HipJntIkFk_AutoBlnd.outputR") ($modCore + "_HipJnt.scaleY");
		connectAttr -f ($modCore + "_HipJntIkFk_AutoBlnd.outputR") ($modCore + "_HipJnt.scaleZ");
		connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_HipJntIkFk_AutoBlnd.blender");
		
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIkFk_BlndRotate");
		connectAttr -f ($modCore + "_HipJntFk.rotate") ($modCore + "_HipJntIkFk_BlndRotate.color1");
		connectAttr -f ($modCore + "_HipJntIk.rotate") ($modCore + "_HipJntIkFk_BlndRotate.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_HipJntIkFk_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_HipJntIkFk_BlndScale.outputR") ($modCore + "_HipJnt.scaleX");
		connectAttr -f ($modCore + "_HipJntIkFk_BlndRotate.output") ($modCore + "_HipJnt.rotate");
		
		//KNEE
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIkFk_BlndScale");
			connectAttr -f ($modCore + "_KneeJntFk.scale") ($modCore + "_KneeJntIkFk_BlndScale.color1");
			connectAttr -f ($modCore + "_KneeJntIk.scale") ($modCore + "_KneeJntIkFk_BlndScale.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_KneeJntIkFk_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_KneeVolume_MD");
			setAttr ($modCore + "_KneeVolume_MD.input1X") 1;
			setAttr ($modCore + "_KneeVolume_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeJntIkFk_BlndScale.outputR") ($modCore + "_KneeVolume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIkFk_AutoBlnd");
			setAttr ($modCore + "_KneeJntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_KneeVolume_MD.outputX") ($modCore + "_KneeJntIkFk_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_KneeJntIkFk_AutoBlnd.outputR") ($modCore + "_KneeJnt.scaleY");
			connectAttr -f ($modCore + "_KneeJntIkFk_AutoBlnd.outputR") ($modCore + "_KneeJnt.scaleZ");
			connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_KneeJntIkFk_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIkFk_BlndRotate");
			connectAttr -f ($modCore + "_KneeJntFk.rotate") ($modCore + "_KneeJntIkFk_BlndRotate.color1");
			connectAttr -f ($modCore + "_KneeJntIk.rotate") ($modCore + "_KneeJntIkFk_BlndRotate.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_KneeJntIkFk_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_KneeJntIkFk_BlndScale.outputR") ($modCore + "_KneeJnt.scaleX");
			connectAttr -f ($modCore + "_KneeJntIkFk_BlndRotate.output") ($modCore + "_KneeJnt.rotate");
		}
		else
		{
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIkFk_BlndScale");
			connectAttr -f ($modCore + "_Knee1JntFk.scale") ($modCore + "_Knee1JntIkFk_BlndScale.color1");
			connectAttr -f ($modCore + "_Knee1JntIk.scale") ($modCore + "_Knee1JntIkFk_BlndScale.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Knee1JntIkFk_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Knee1Volume_MD");
			setAttr ($modCore + "_Knee1Volume_MD.input1X") 1;
			setAttr ($modCore + "_Knee1Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Knee1JntIkFk_BlndScale.outputR") ($modCore + "_Knee1Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIkFk_AutoBlnd");
			setAttr ($modCore + "_Knee1JntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Knee1Volume_MD.outputX") ($modCore + "_Knee1JntIkFk_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Knee1JntIkFk_AutoBlnd.outputR") ($modCore + "_Knee1Jnt.scaleY");
			connectAttr -f ($modCore + "_Knee1JntIkFk_AutoBlnd.outputR") ($modCore + "_Knee1Jnt.scaleZ");
			connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_Knee1JntIkFk_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIkFk_BlndRotate");
			connectAttr -f ($modCore + "_Knee1JntFk.rotate") ($modCore + "_Knee1JntIkFk_BlndRotate.color1");
			connectAttr -f ($modCore + "_Knee1JntIk.rotate") ($modCore + "_Knee1JntIkFk_BlndRotate.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Knee1JntIkFk_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Knee1JntIkFk_BlndScale.outputR") ($modCore + "_Knee1Jnt.scaleX");
			connectAttr -f ($modCore + "_Knee1JntIkFk_BlndRotate.output") ($modCore + "_Knee1Jnt.rotate");
	
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIkFk_BlndScale");
			connectAttr -f ($modCore + "_Knee2JntFk.scale") ($modCore + "_Knee2JntIkFk_BlndScale.color1");
			connectAttr -f ($modCore + "_Knee2JntIk.scale") ($modCore + "_Knee2JntIkFk_BlndScale.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Knee2JntIkFk_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Knee2Volume_MD");
			setAttr ($modCore + "_Knee2Volume_MD.input1X") 1;
			setAttr ($modCore + "_Knee2Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Knee2JntIkFk_BlndScale.outputR") ($modCore + "_Knee2Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIkFk_AutoBlnd");
			setAttr ($modCore + "_Knee2JntIkFk_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Knee2Volume_MD.outputX") ($modCore + "_Knee2JntIkFk_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Knee2JntIkFk_AutoBlnd.outputR") ($modCore + "_Knee2Jnt.scaleY");
			connectAttr -f ($modCore + "_Knee2JntIkFk_AutoBlnd.outputR") ($modCore + "_Knee2Jnt.scaleZ");
			connectAttr -f ($modCore + "_Switch_Ctrl.autoVolume") ($modCore + "_Knee2JntIkFk_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIkFk_BlndRotate");
			connectAttr -f ($modCore + "_Knee2JntFk.rotate") ($modCore + "_Knee2JntIkFk_BlndRotate.color1");
			connectAttr -f ($modCore + "_Knee2JntIk.rotate") ($modCore + "_Knee2JntIkFk_BlndRotate.color2");
			connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_Knee2JntIkFk_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Knee2JntIkFk_BlndScale.outputR") ($modCore + "_Knee2Jnt.scaleX");
			connectAttr -f ($modCore + "_Knee2JntIkFk_BlndRotate.output") ($modCore + "_Knee2Jnt.rotate");
		}		
	
		//ANKLE
		shadingNode -asUtility blendColors -n ($modCore + "_AnkleJntIkFk_BlndRotate");
		connectAttr -f ($modCore + "_AnkleJntFk.rotate") ($modCore + "_AnkleJntIkFk_BlndRotate.color1");
		connectAttr -f ($modCore + "_AnkleJntIk.rotate") ($modCore + "_AnkleJntIkFk_BlndRotate.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_AnkleJntIkFk_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_AnkleJntIkFk_BlndRotate.output") ($modCore + "_AnkleJnt.rotate");
		
		//BALL
		shadingNode -asUtility blendColors -n ($modCore + "_BallJntIkFk_BlndRotate");
		connectAttr -f ($modCore + "_BallJntFk.rotate") ($modCore + "_BallJntIkFk_BlndRotate.color1");
		connectAttr -f ($modCore + "_BallJntIk.rotate") ($modCore + "_BallJntIkFk_BlndRotate.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_BallJntIkFk_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_BallJntIkFk_BlndRotate.output") ($modCore + "_BallJnt.rotate");
		
		//TOE
		shadingNode -asUtility blendColors -n ($modCore + "_ToeJntIkFk_BlndRotate");
		connectAttr -f ($modCore + "_ToeJntFk.rotate") ($modCore + "_ToeJntIkFk_BlndRotate.color1");
		connectAttr -f ($modCore + "_ToeJntIk.rotate") ($modCore + "_ToeJntIkFk_BlndRotate.color2");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_ToeJntIkFk_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_ToeJntIkFk_BlndRotate.output") ($modCore + "_ToeJnt.rotate");
		
		//KNEE Ik_Ctrl FOLLOW
		parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_BallIk_Ctrl") ($modCore + "_HipFk_Ctrl") ($modCore + "_KneeIk_CtrlGrp");
		addAttr -ln "follow" -at "enum" -en "Main:Ankle:Hip:Ankle and Hip:" ($modCore + "_KneeIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_KneeIk_Ctrl.follow");
		setAttr ($modCore + "_KneeIk_Ctrl.follow") 0;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2") 0;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2");
		
		setAttr ($modCore + "_KneeIk_Ctrl.follow") 1;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0") 0;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2");
		
		setAttr ($modCore + "_KneeIk_Ctrl.follow") 2;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2") 1;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2");
		
		setAttr ($modCore + "_KneeIk_Ctrl.follow") 3;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1") 1;
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_BallIk_CtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIk_Ctrl.follow") ($modCore + "_KneeIk_CtrlGrp_parentConstraint1." + $modCore + "_HipFk_CtrlW2");
		
		setAttr ($modCore + "_KneeIk_Ctrl.follow") 0;

		//SDK TOE PIVOT		
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_pivot") ($modCore + "_ToeIk_CtrlSdkGrp.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.toe_pivot") -10;
		rotate -r 0 0 90 ($modCore + "_ToeIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_pivot") ($modCore + "_ToeIk_CtrlSdkGrp.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.toe_pivot") 10;
		rotate -r 0 0 -90 ($modCore + "_ToeIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_pivot") ($modCore + "_ToeIk_CtrlSdkGrp.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.toe_pivot") 0;
		//SDK BALL PIVOT		
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.ball_pivot") ($modCore + "_BallSwivelLctr.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.ball_pivot") -10;
		rotate -r 0 0 90 ($modCore + "_BallSwivelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.ball_pivot") ($modCore + "_BallSwivelLctr.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.ball_pivot") 10;
		rotate -r 0 0 -90 ($modCore + "_BallSwivelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.ball_pivot") ($modCore + "_BallSwivelLctr.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.ball_pivot") 0;
		//SDK HEEL PIVOT		
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.heel_pivot") ($modCore + "_HeelIk_CtrlSdkGrp.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.heel_pivot") -10;
		rotate -r 0 0 90 ($modCore + "_HeelIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.heel_pivot") ($modCore + "_HeelIk_CtrlSdkGrp.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.heel_pivot") 10;
		rotate -r 0 0 -90 ($modCore + "_HeelIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.heel_pivot") ($modCore + "_HeelIk_CtrlSdkGrp.rotateZ");
		setAttr ($modCore + "_FootIk_Ctrl.heel_pivot") 0;


		//SDK BALL ROLL
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.ball_roll") ($modCore + "_BallIk_CtrlSdkGrp.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.ball_roll") -10;
		rotate -r 0 -90 0 ($modCore + "_BallIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.ball_roll") ($modCore + "_BallIk_CtrlSdkGrp.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.ball_roll") 10;
		rotate -r 0 90 0 ($modCore + "_BallIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.ball_roll") ($modCore + "_BallIk_CtrlSdkGrp.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.ball_roll") 0;
		//SDK TOE HEEL ROLL
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_heel_roll") ($modCore + "_ToeIk_CtrlSdkGrp.rotateY");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_heel_roll") ($modCore + "_HeelIk_CtrlSdkGrp.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.toe_heel_roll") -10;
		rotate -r 0 90 0 ($modCore + "_ToeIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_heel_roll") ($modCore + "_ToeIk_CtrlSdkGrp.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.toe_heel_roll") 10;
		rotate -r 0 -90 0 ($modCore + "_HeelIk_CtrlSdkGrp");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_heel_roll") ($modCore + "_HeelIk_CtrlSdkGrp.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.toe_heel_roll") 0;
		//SDK BANK
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.bank_in_out") ($modCore + "_FootBankInLctr.rotateX");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.bank_in_out") ($modCore + "_FootBankOutLctr.rotateX");
		setAttr ($modCore + "_FootIk_Ctrl.bank_in_out") -10;
		rotate -r 90 0 0 ($modCore + "_FootBankInLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.bank_in_out") ($modCore + "_FootBankInLctr.rotateX");
		setAttr ($modCore + "_FootIk_Ctrl.bank_in_out") 10;
		rotate -r -90 0 0 ($modCore + "_FootBankOutLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.bank_in_out") ($modCore + "_FootBankOutLctr.rotateX");
		setAttr ($modCore + "_FootIk_Ctrl.bank_in_out") 0;
		//SDK TOE ROLL
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_roll") ($modCore + "_FootToePivotLctr.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.toe_roll") -10;
		rotate -r 0 90 0 ($modCore + "_FootToePivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_roll") ($modCore + "_FootToePivotLctr.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.toe_roll") 10;
		rotate -r 0 -90 0 ($modCore + "_FootToePivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIk_Ctrl.toe_roll") ($modCore + "_FootToePivotLctr.rotateY");
		setAttr ($modCore + "_FootIk_Ctrl.toe_roll") 0;
		
		keyTangent -itt spline -ott spline
		($modCore + "_KneeIk_CtrlGrp_parentConstraint1_" + $modRigName + "MAIN_Inner_CtrlW0")
		($modCore + "_KneeIk_CtrlGrp_parentConstraint1_" + $modCore + "_BallIk_CtrlW1")
		($modCore + "_KneeIk_CtrlGrp_parentConstraint1_" + $modCore + "_HipFk_CtrlW2")
		($modCore + "_FootBankInLctr_rotateX")
		($modCore + "_FootBankOutLctr_rotateX")
		($modCore + "_FootToePivotLctr_rotateY")
		($modCore + "_BallIk_CtrlSdkGrp_rotateY")
		($modCore + "_BallSwivelLctr_rotateZ");
		keyTangent -itt spline -ott spline ;
	
		setInfinity -pri linear ($modCore + "_BallSwivelLctr.ry");
		setInfinity -poi linear ($modCore + "_BallSwivelLctr.ry");
		
	
		//CONNECTOR LINE
		curve -n ($modCore + "_KneeIkConnector_Curve") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		rename `listRelatives -c ($modCore + "_KneeIkConnector_Curve")` ($modCore + "_KneeIkConnector_CurveShape");
		delete `parentConstraint ($modCore + "_KneeIk_Ctrl") ($modCore + "_KneeIkConnector_Curve") `;
		parent ($modCore + "_KneeIkConnector_Curve") ($modCore + "_KneeIk_Ctrl");
		spaceLocator -n ($modCore + "_KneeIkAimConnectorLctr");
		spaceLocator -n ($modCore + "_KneeIkTargetConnectorLctr");
		parent ($modCore + "_KneeIkTargetConnectorLctr") ($modCore + "_KneeIkAimConnectorLctr");
		delete `parentConstraint ($modCore + "_KneeIk_Ctrl") ($modCore + "_KneeIkAimConnectorLctr")`;
		parent ($modCore + "_KneeIkAimConnectorLctr") ($modCore + "_KneeIk_Ctrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIkAimConnectorLctr");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			pointConstraint ($modCore + "_KneeJnt") ($modCore + "_KneeIkTargetConnectorLctr");
			aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_KneeJnt") ($modCore + "_KneeIkAimConnectorLctr");
			aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_KneeJnt") ($modCore + "_KneeIkConnector_Curve");
		}
		else
		{
			pointConstraint ($modCore + "_Knee1Jnt") ($modCore + "_KneeIkTargetConnectorLctr");
			aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Knee1Jnt") ($modCore + "_KneeIkAimConnectorLctr");
			aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Knee1Jnt") ($modCore + "_KneeIkConnector_Curve");
		}
		connectAttr -f ($modCore + "_KneeIkTargetConnectorLctr.tz") ($modCore + "_KneeIkConnector_Curve.sz");
		setAttr ($modCore + "_KneeIkAimConnectorLctr.v") 0;

		addAttr -ln "nonControl" -dt "string" ($modCore + "_KneeIkConnector_Curve");
		setAttr -e -k 1 ($modCore + "_KneeIkConnector_Curve.nonControl");
		setAttr -l 1 ($modCore + "_KneeIkConnector_Curve.nonControl");


		//VISIBILITY TOGGLES////////////////////////////////////////////////////////////////////
		
	
		//LEG
		shadingNode -asUtility condition -n ($modCore + "_LegIkViz");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_LegIkViz.firstTerm");
		setAttr ($modCore + "_LegIkViz.secondTerm") 1;
		setAttr ($modCore + "_LegIkViz.operation") 3;
			
		connectAttr -f ($modCore + "_LegIkViz.outColorR") ($modCore + "_KneeIk_Ctrl.v");
		connectAttr -f ($modCore + "_LegIkViz.outColorR") ($modCore + "_FootIk_Ctrl.v");
		connectAttr -f ($modCore + "_LegIkViz.outColorR") ($modCore + "_ToeIk_Ctrl.v");
		if (`objExists ($modCore + "_LowerLegIk_Ctrl")`)
		{
			connectAttr -f ($modCore + "_LegIkViz.outColorR") ($modCore + "_LowerLegIk_Ctrl.v");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.v");
		}
		shadingNode -asUtility condition -n ($modCore + "_LegFkViz");
		connectAttr -f ($modCore + "_Switch_Ctrl.switchIkFk") ($modCore + "_LegFkViz.firstTerm");
		setAttr ($modCore + "_LegFkViz.secondTerm") 0;
		setAttr ($modCore + "_LegFkViz.operation") 5;
		setAttr ($modCore + "_Switch_Ctrl.switchIkFk") 0;

		//SHOULDER
		shadingNode -asUtility condition -n ($modCore + "_HipFkViz");
		connectAttr -f ($modCore + "_HipFk_Ctrl.alwaysVisible") ($modCore + "_HipFkViz.firstTerm");
		connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_HipFkViz.colorIfTrueR");
		connectAttr -f ($modCore + "_HipFkViz.outColorR") ($modCore + "_HipFk_Ctrl.v");

		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_KneeFk_Ctrl.v");
		}
		else
		{
			connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_Knee1Fk_Ctrl.v");
			connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_Knee2Fk_Ctrl.v");
		}
		connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_AnkleFk_Ctrl.v");
		connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_BallFk_Ctrl.v");
		connectAttr -f ($modCore + "_LegFkViz.outColorR") ($modCore + "_ToeFk_Ctrl.v");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
		//MAKE FEET JOINTS VISIBLE
		setAttr ($modCore + "_AnkleJnt.overrideEnabled") 1;
	
		
		//JOINTS
		setAttr ($modCore + "_HipJntIk.v") 0;
		setAttr ($modCore + "_HipJntFk.v") 0;
		setAttr ($modCore + "_AnkleJntFk.v") 0;
	
	
		setAttr ($modCore + "_LimbLengthOriginLctr.v") 0;
		setAttr ($modCore + "_AnkleJntFkGrp2.v") 0;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr ($modCore + "_KneeJntFkGrp2.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Knee1JntFkGrp2.v") 0;
			setAttr ($modCore + "_Knee2JntFkGrp2.v") 0;
		}
		
		
		setAttr ($modCore + "_KneeIk_Ctrl_TargetLctr.v") 0;
		
		//CONTROLS
		setAttr -l 1 -k 0 ($modCore + "_HipFk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_HipFk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_HipFk_Ctrl.v");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFk_Ctrl.v");
		}
		else
		{
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1Fk_Ctrl.v");
			
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.tz");
			//setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.rx");
			//setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2Fk_Ctrl.v");

			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIk_Ctrl.v");
			transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_LowerLegIk_Ctrl");
		}
		
		setAttr -l 1 -k 0 ($modCore + "_AnkleFk_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFk_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFk_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFk_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_BallFk_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ToeFk_Ctrl.v");
		
		//setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.rx");
		//setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.ry");
		//setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIk_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_FootIk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_FootIk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_FootIk_Ctrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_ToeIk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ToeIk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ToeIk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ToeIk_Ctrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_HeelIk_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_HeelIk_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_HeelIk_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_HeelIk_Ctrl.v");

		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_Switch_Ctrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.tx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.ty");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.tz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.rx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.ry");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.rz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.sx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.sy");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.sz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIkConnector_Curve.v");
		setAttr ($modCore + "_KneeIkConnector_Curve.template") 1;

		setAttr ($modCore + "_LegIkHandle.v") 0;
		setAttr ($modCore + "_ToeIkHandle.v") 0;		
		setAttr ($modCore + "_BallSwivelLctrShape.v") 0;	
		setAttr ($modCore + "_FootBankInLctrShape.v") 0;	
		setAttr ($modCore + "_FootBankOutLctrShape.v") 0;	
		setAttr ($modCore + "_FootToePivotLctrShape.v") 0;	
		
		
		//LOCK GROUPS
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		select -cl;
		
		//ANKLE Ik LOCATOR
		spaceLocator -n ($modCore + "_AnkleIkLctr");
		delete `parentConstraint ($modCore + "_AnkleFk_CtrlGrp") ($modCore + "_AnkleIkLctr")`;
		parent ($modCore + "_AnkleIkLctr") ($modCore + "_AnkleFk_CtrlGrp");
		orientConstraint -mo ($modCore + "_FootIk_Ctrl") ($modCore + "_AnkleIkLctr");
		setAttr ($modCore + "_AnkleIkLctr_orientConstraint1.interpType") 2;
		
		//KNEE Fk LOCATOR
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			spaceLocator -n ($modCore + "_Knee_FkAimLctr");
			delete `parentConstraint ($modCore + "_KneeIk_Ctrl") ($modCore + "_Knee_FkAimLctr")`;
			parent ($modCore + "_Knee_FkAimLctr") ($modCore + "_KneeIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee_FkAimLctr");
		
			parentConstraint -mo ($modCore + "_KneeFk_Ctrl") ($modCore + "_HipFk_Ctrl") ($modCore + "_Knee_FkAimLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Knee1_FkAimLctr");
			parent ($modCore + "_Knee1_FkAimLctr") ($modCore + "_Knee1Fk_Ctrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Knee1_FkAimLctr");
			delete `pointConstraint -skip x -skip y -weight 1 ($modCore + "_KneeIk_Ctrl") ($modCore + "_Knee1_FkAimLctr")`;
	
			parent ($modCore + "_Knee1_FkAimLctr") ($modCore + "_KneeIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee1_FkAimLctr");
		
			parentConstraint -mo ($modCore + "_Knee1Fk_Ctrl") ($modCore + "_HipFk_Ctrl") ($modCore + "_Knee1_FkAimLctr");
			
			spaceLocator -n ($modCore + "_Knee2_FkAimLctr");
			parent ($modCore + "_Knee2_FkAimLctr") ($modCore + "_Knee2Fk_Ctrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Knee2_FkAimLctr");
			delete `pointConstraint -skip x -skip y -weight 1 ($modCore + "_KneeIk_Ctrl") ($modCore + "_Knee2_FkAimLctr")`;
	
			parent ($modCore + "_Knee2_FkAimLctr") ($modCore + "_KneeIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee2_FkAimLctr");
		
			parentConstraint -mo ($modCore + "_Knee2Fk_Ctrl") ($modCore + "_HipFk_Ctrl") ($modCore + "_Knee2_FkAimLctr");
		}		
		
		//HIP Fk LOCATOR
		spaceLocator -n ($modCore + "_HipFkOrientLctr");
		delete `parentConstraint ($modCore + "_HipJnt") ($modCore + "_HipFkOrientLctr")`;
		parent ($modCore + "_HipFkOrientLctr") ($modCore + "_HipFk_CtrlGrp");
		orientConstraint ($modCore + "_HipJntIk") ($modCore + "_HipFkOrientLctr");
		
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_HipFkOrientLctr.v") 0;
		if (`objExists ($modCore + "_Knee_FkAimLctr.v")`)
		{
			setAttr ($modCore + "_Knee_FkAimLctr.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Knee1_FkAimLctr.v") 0;
			setAttr ($modCore + "_Knee2_FkAimLctr.v") 0;
		}		
		setAttr ($modCore + "_AnkleIkLctr.v") 0;
		//setAttr ($modCore + "_AnkleFkLctr.v") 0;
		
		setAttr ($modCore + "_HipIkLockLctr.v") 0;
		
		
		//PARENT TO MAIN CONTROL
		
		//SET ALL CONSTRAINTS TO SHORTEST INTERPOLATION
		string $selectedParentConstraints[] = `ls ($modCore + "*_parentConstraint1")`;
		for ($crntParentConstraint in $selectedParentConstraints)
		{setAttr ($crntParentConstraint + ".interpType") 2;}
		
		setAttr ($modCore + "_KneeIk_CtrlGrp_parentConstraint1.interpType") 2;
		
		if (`objExists ($modCore + "_HipCurveJnt")`)
		{
			setAttr ($modCore + "_LowerTwist75Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwist25Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwistHalfLctr_parentConstraint1.interpType") 2;
		}
		
		//HIERARCHY CLEAN-UP
		parent 
		($modCore + "_AnkleJntFkGrp2") 
		($modCore + "_FootIk_CtrlGrp") ($modCore + "_KneeIk_CtrlGrp") ($modCore + "_KneeIk_Ctrl_TargetLctr")
		($modCore + "_LimbLengthOriginLctr") ($modCore + "_HipIkLockLctr")
		($modCore + "_Switch_CtrlGrp") ($modCore + "_HipFk_CtrlGrp")
		
		($modCore + "_AnkleFk_CtrlGrp") ($modCore + "_BallFk_CtrlGrp") ($modCore + "_ToeFk_CtrlGrp")
		($modCore + "_HipJnt") ($modCore + "_HipJntFk") ($modCore + "_HipJntIk")
		($modCore + "_ScaleGrp");

		//CREATE CONSTRAINT FOR ANKLE Ik_CtrlGrp
		//CHECK IF ATTACHED TO ROOT
		if ($modAttachNode == "ROOT")
		{
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore + "_FootIk_CtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modRigName + $modAttachNode + "Jnt") ($modCore + "_FootIk_CtrlGrp");
		}

		//ADD DYNAMIC PARENTING CHANNELS
		addAttr -ln "follow" -at bool ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 -l 1 ($modCore + "_FootIk_Ctrl.follow");
		if ($modAttachNode != "ROOT")
		{
			addAttr -ln "parent" -at double -min 0 -max 1 -dv 0 ($modCore + "_FootIk_Ctrl");
			setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.parent");
		}
		addAttr -ln "ROOT" -at double -min 0 -max 1 -dv 0 ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.ROOT");

		addAttr -ln "ROOTType" -at "enum" -en "ROOTC:ROOTsecondaryC:" ($modCore + "_FootIk_Ctrl");
		setAttr -e -k 1 ($modCore + "_FootIk_Ctrl.ROOTType");


		//Ik ANKLE DYNAMIC CONSTRAINTS
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_FootIk_Ctrl.parent") ($modCore + "_FootIk_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW3");
		}
		
		//ROOT CONNECTIONS
		shadingNode -asUtility multiplyDivide -n ($modCore + "_FootIkROOTInf_MD");
		connectAttr -f ($modCore + "_FootIk_Ctrl.ROOT") ($modCore + "_FootIkROOTInf_MD.input1X");
		connectAttr -f ($modCore + "_FootIk_Ctrl.ROOT") ($modCore + "_FootIkROOTInf_MD.input1Y");
		connectAttr -f ($modCore + "_FootIk_Ctrl.ROOTType") ($modCore + "_FootIkROOTInf_MD.input2Y");
		
		shadingNode -asUtility reverse -n ($modCore + "_FootIkROOTInf_Reverse");
		connectAttr -f ($modCore + "_FootIk_Ctrl.ROOTType") ($modCore + "_FootIkROOTInf_Reverse.inputX");
		connectAttr -f ($modCore + "_FootIkROOTInf_Reverse.outputX") ($modCore + "_FootIkROOTInf_MD.input2X");

		connectAttr -f ($modCore + "_FootIkROOTInf_MD.outputX") ($modCore + "_FootIk_CtrlGrp_parentConstraint1." + $modRigName + "ROOT_CtrlW1");
		connectAttr -f ($modCore + "_FootIkROOTInf_MD.outputY") ($modCore + "_FootIk_CtrlGrp_parentConstraint1." + $modRigName + "ROOTSecondary_CtrlW2");
		
		shadingNode -asUtility plusMinusAverage -n ($modCore + "_FootIkParent_PMA");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_FootIk_Ctrl.parent") ($modCore + "_FootIkParent_PMA.input1D[0]");
		}
		connectAttr -f ($modCore + "_FootIk_Ctrl.ROOT") ($modCore + "_FootIkParent_PMA.input1D[1]");
		
		shadingNode -asUtility condition -n ($modCore + "_FootIkParent_Condition");
		setAttr ($modCore + "_FootIkParent_Condition.operation") 4;
		setAttr ($modCore + "_FootIkParent_Condition.secondTerm") 1;
		connectAttr -f ($modCore + "_FootIkParent_PMA.output1D") ($modCore + "_FootIkParent_Condition.firstTerm");
		connectAttr -force ($modCore + "_FootIkParent_PMA.output1D") ($modCore + "_FootIkParent_Condition.colorIfTrueR");
		
		shadingNode -asUtility reverse -n ($modCore + "_FootIkParent_Reverse");
		connectAttr -f ($modCore + "_FootIkParent_Condition.outColorR") ($modCore + "_FootIkParent_Reverse.inputX");
		connectAttr -f ($modCore + "_FootIkParent_Reverse.outputX") ($modCore + "_FootIk_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");


		/////////////////////////////////SNAP ASSETS/////////////////////////////////

		//ANKLE Ik TO Fk LOCATOR
		spaceLocator -n ($modCore + "_AnkleIkToFkLctr");
		setAttr ($modCore + "_AnkleIkToFkLctr.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_FootIk_Ctrl") ($modCore + "_AnkleIkToFkLctr")`;
		parent ($modCore + "_AnkleIkToFkLctr") ($modCore + "_FootIk_CtrlGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_AnkleIkToFkLctr");
		parentConstraint -mo ($modCore + "_AnkleFk_Ctrl") ($modCore + "_AnkleIkToFkLctr");

		//SINGLE KNEE
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			//KNEE Ik TO Fk LOCATOR
			spaceLocator -n ($modCore + "_KneeIkToFkAimLctr");
			delete `parentConstraint ($modCore + "_KneeIk_Ctrl") ($modCore + "_KneeIkToFkAimLctr")`;
			parent ($modCore + "_KneeIkToFkAimLctr") ($modCore + "_KneeIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIkToFkAimLctr");
			parentConstraint -mo ($modCore + "_KneeFk_Ctrl") ($modCore + "_HipFk_Ctrl") ($modCore + "_KneeIkToFkAimLctr");
		}
		else
		{
			//KNEE Ik TO Fk LOCATOR
			spaceLocator -n ($modCore + "_KneeIkToFkAimLctr");
			delete `parentConstraint ($modCore + "_KneeIk_Ctrl") ($modCore + "_KneeIkToFkAimLctr")`;
			parent ($modCore + "_KneeIkToFkAimLctr") ($modCore + "_KneeIk_CtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIkToFkAimLctr");
			parentConstraint -mo ($modCore + "_Knee1Fk_Ctrl") ($modCore + "_HipFk_Ctrl") ($modCore + "_KneeIkToFkAimLctr");
		}
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_KneeIkToFkAimLctr.v") 0;
		setAttr ($modCore + "_AnkleIkToFkLctr.v") 0;

		//KNEE HIERARCHY CLEANUP		
		if (`objExists ($modCore + "_KneeJntFkGrp2")`)
		{
			parent ($modCore + "_KneeJntFkGrp2") ($modCore + "_KneeFk_CtrlGrp")
			($modCore + "_ScaleGrp");
		}
		else
		{
			parent ($modCore + "_Knee1Fk_CtrlGrp") ($modCore + "_Knee2Fk_CtrlGrp")
			($modCore + "_Knee1JntFkGrp2") ($modCore + "_Knee2JntFkGrp2")
			($modCore + "_ScaleGrp");
		}
	
		//CHECK POLE VECTOR
		if (`objExists ($modCore + "_Knee1Jnt")`)
		{
			$lhipOrient = `getAttr ($modCore + "_HipJnt.rotate")`;
			if ($lhipOrient[0] > 90 || $lhipOrient[0] < -90 || $lhipOrient[2] > 90 || $lhipOrient[2] < -90)
			{
				setAttr ($modCore + "_LegIkHandle.twist") 180;
			}
				
		}

		select $topNode;
		
		if (`objExists ("RRM_" + $prfx + $core + "_Lower1")` || `objExists ("RRM_" + $prfx + $core + "_Middle1")` || `objExists ("RRM_" + $prfx + $core + "_Upper1")`)
		{
			if ($modAttachNode != "ROOT")
			{
				RRM_ToonLimbs($modRigName, $rigGrp, "leg", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, ($modRigName + "" + $modAttachNode + "Jnt"), $topNode, $behavior, $behaviorMultiplier, $lPrfx, $rPrfx, $ea);
			}
			else 
			{
				RRM_ToonLimbs($modRigName, $rigGrp, "leg", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, ($modRigName + "" + $modAttachNode + "Secondary_Ctrl"), $topNode, $behavior, $behaviorMultiplier, $lPrfx, $rPrfx, $ea);
			}
		}

		//ADD JOINT ANGLE ATTRIBUTES
		addAttr -ln "hipAngleX" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "hipAngleX");
		addAttr -ln "hipAngleY" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "hipAngleY");
		addAttr -ln "hipAngleZ" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "hipAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			addAttr -ln "kneeAngleY" -at double ($modCore + "_Switch_Ctrl");
			setAttr -e -k 1 ($modCore + "_Switch_Ctrl.kneeAngleY");
		}
		else
		{
			addAttr -ln "knee1AngleY" -at double ($modCore + "_Switch_Ctrl");
			setAttr -e -k 1 ($modCore + "_Switch_Ctrl.knee1AngleY");
			addAttr -ln "knee2AngleY" -at double ($modCore + "_Switch_Ctrl");
			setAttr -e -k 1 ($modCore + "_Switch_Ctrl.knee2AngleY");
		}
		
		addAttr -ln "ankleAngleX" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "ankleAngleX");
		addAttr -ln "ankleAngleY" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "ankleAngleY");
		addAttr -ln "ankleAngleZ" -at double ($modCore + "_Switch_Ctrl");
		setAttr -e -k 1 ($modCore + "_Switch_Ctrl." + "ankleAngleZ");
		
		//CONNECT JOINT ANGLE ATTRIBUTES
		connectAttr -force ($modCore + "_HipJnt.rotateX") ($modCore + "_Switch_Ctrl.hipAngleX");
		connectAttr -force ($modCore + "_HipJnt.rotateY") ($modCore + "_Switch_Ctrl.hipAngleY");
		connectAttr -force ($modCore + "_HipJnt.rotateZ") ($modCore + "_Switch_Ctrl.hipAngleZ"); 
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			connectAttr -force ($modCore + "_KneeJnt.rotateY") ($modCore + "_Switch_Ctrl.kneeAngleY");
		}
		else
		{
			connectAttr -force ($modCore + "_Knee1Jnt.rotateY") ($modCore + "_Switch_Ctrl.knee1AngleY");
			connectAttr -force ($modCore + "_Knee2Jnt.rotateY") ($modCore + "_Switch_Ctrl.knee2AngleY");
		}
			
	
		connectAttr -force ($modCore + "_AnkleJnt.rotateX") ($modCore + "_Switch_Ctrl.ankleAngleX");
		connectAttr -force ($modCore + "_AnkleJnt.rotateY") ($modCore + "_Switch_Ctrl.ankleAngleY");
		connectAttr -force ($modCore + "_AnkleJnt.rotateZ") ($modCore + "_Switch_Ctrl.ankleAngleZ");
		
		setAttr -l 1 ($modCore + "_Switch_Ctrl.hipAngleX"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.hipAngleY"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.hipAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			setAttr -l 1 ($modCore + "_Switch_Ctrl.kneeAngleY");
		}
		else
		{
			setAttr -l 1 ($modCore + "_Switch_Ctrl.knee1AngleY");
			setAttr -l 1 ($modCore + "_Switch_Ctrl.knee2AngleY");
		}
		
		setAttr -l 1 ($modCore + "_Switch_Ctrl.ankleAngleX"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.ankleAngleY"); 
		setAttr -l 1 ($modCore + "_Switch_Ctrl.ankleAngleZ");


		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*_Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("" + $prfx + $core);
			setAttr -e-l 1 ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType" -dt "string" ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "leg";
			setAttr -l true ($crntModControl + ".moduleType");
		}
	
		//SET UP FOR RIGHT SIDE
		$mirrorInt++;
		$i++;
		$prfx = $rPrfx;
		$posOffset = -2;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$inverseFront = 1;
	
		if (!`objExists ($topNode + ".pair")`)
		{
			$i = 2;
		}
	}
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Parent")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Parent")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Parent");}
	else if (`objExists ("RRM_" + $modRigName + "Parent")`)
		{select ("RRM_" + $modRigName + "Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE Fk CHAIN MODULE/////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigFkChain(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;  

	//INTEGER FOR LOOP
	$mirrorInt = 1;
	$multiplier = 1;
	float $rotOffset = 0;

	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";
	
	$crntSide = "";
	$oppSide = "";

	float $behavior = 1;
	float $behaviorMultiplier = 1;

	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = $lPrfx;
		$oppPrfx = $rPrfx;

		$mirrorInt = 0;
		$crntSide = "left";
		$oppSide = "right";
		if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behavior = 0;
			}
		}
	}

	
	//CHECK IF Ik IS ENABLED
	$enableIk = 1;
	if (`objExists ($topNode + ".ikEnabled")`)
	{
		$enableIk = `getAttr ($topNode + ".ikEnabled")`;
	}
	
	while ($mirrorInt <= 1)
	{
		if ($crntSide == "right" && `objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				//print "behavior\n";
				$behaviorMultiplier = -1;
			}
		}

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		$modOppCore = ($modRigName + "" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
						
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "fkChain";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$fkChains = `ls ("RRM_" + $prfx + $core + "_??_01")`;
	
		addAttr -ln "fkChains" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.fkChains") ;
		setAttr -type "string" ($modCore + "Grp.fkChains") `size $fkChains`;
		setAttr -l true ($modCore + "Grp.fkChains");
		
		$fkjointsPerChain = `ls ("RRM_" + $prfx + $core + "_01_??")`;
	
		addAttr -ln "jointsPerChain" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.jointsPerChain") ;
		setAttr -type "string" ($modCore + "Grp.jointsPerChain") `size $fkjointsPerChain`;
		setAttr -l true ($modCore + "Grp.jointsPerChain");
		
		addAttr -ln "ikEnabled" -at bool ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.ikEnabled");
		setAttr ($modCore + "Grp.ikEnabled") $enableIk;
		setAttr -l true ($modCore + "Grp.ikEnabled");

		//SCALE GROUP
		spaceLocator -n ($modCore + "_AveragePosition_Lctr");
		parentConstraint $fkChains ($modCore + "_AveragePosition_Lctr");
		group -em -n ($modCore + "_ScaleGrp");

		//GROUP FOR NODES
		group -em -n ($modCore + "_curveNodesGrp");
		parent ($modCore + "_curveNodesGrp") ($modCore + "_ScaleGrp");
		group -em -n ($modCore + "_extraCurveNodesGrp");
		setAttr ($modCore + "_extraCurveNodesGrp.inheritsTransform") 0; 
		parent ($modCore + "_extraCurveNodesGrp") ($modCore + "Grp");

		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modCore + "_AveragePosition_Lctr") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modCore + "_AveragePosition_Lctr") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modCore + "_ScaleGrp");
		}
		delete ($modCore + "_AveragePosition_Lctr");
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");
							
		$allJoints = `ls ("RRM_" + $prfx + $core + "_??_??")`;
		$sizeAllJoints = `size $allJoints`;
		$fKChain = `ls ("RRM_" + $prfx + $core + "_??_01")`;
		$fKChainSize = `size $fKChain`;
		$crntCh = 1;
		$crntJnt = 1;
		
		//MASTER CONTROLLER
		circle -n ($modCore + "_Master_Ctrl") -nr 5 0 0 -r 1 -d 1 -s 4 -ch 0;
		rotate -r 45 0 0 ($modCore + "_Master_Ctrl");
		makeIdentity -apply true -r 1 ($modCore + "_Master_Ctrl");
		group -n ($modCore + "_Master_CtrlGrp") ($modCore + "_Master_Ctrl");
		spaceLocator -n ($modCore + "_Master_Ctrl_StartAttachLctr");
		spaceLocator -n ($modCore + "_Master_Ctrl_EndAttachLctr");
		pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_Master_Ctrl_StartAttachLctr");
		aimConstraint -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "objectRotation" -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		$fKChain ($modCore + "_Master_Ctrl_StartAttachLctr");
		pointConstraint $fKChain ($modCore + "_Master_Ctrl_EndAttachLctr");
		delete `pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_Master_Ctrl_EndAttachLctr") ($modCore + "_Master_CtrlGrp")`;
		delete `orientConstraint ($modCore + "_Master_Ctrl_StartAttachLctr") ($modCore + "_Master_CtrlGrp")`;
		parent ($modCore + "_Master_CtrlGrp") ($modCore + "_ScaleGrp");
		delete ($modCore + "_Master_Ctrl_StartAttachLctr") ($modCore + "_Master_Ctrl_EndAttachLctr");
		
		if (`size $fKChain` > 1)
		{
			spaceLocator -n ($modCore + "_Master_Ctrl_SizeStartLctr");
			spaceLocator -n ($modCore + "_Master_Ctrl_SizeEndLctr");
			parent ($modCore + "_Master_Ctrl_SizeEndLctr") ($modCore + "_Master_Ctrl_SizeStartLctr");
			pointConstraint $fKChain[0] ($modCore + "_Master_Ctrl_SizeStartLctr");
			aimConstraint -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "none" $fKChain[($fKChainSize - 1)] ($modCore + "_Master_Ctrl_SizeStartLctr");
			pointConstraint $fKChain[($fKChainSize - 1)] ($modCore + "_Master_Ctrl_SizeEndLctr");
			float $chains = `getAttr ($modCore + "_Master_Ctrl_SizeEndLctr.tx")`;
			scale -r 1 ($chains * .8) ($chains * .3) ($modCore + "_Master_Ctrl");
			makeIdentity -apply true -s 1 ($modCore + "_Master_Ctrl");
			delete ($modCore + "_Master_Ctrl_SizeStartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Master_Ctrl_SizeStartLctr");
			spaceLocator -n ($modCore + "_Master_Ctrl_SizeEndLctr");
			parent ($modCore + "_Master_Ctrl_SizeEndLctr") ($modCore + "_Master_Ctrl_SizeStartLctr");
			pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_Master_Ctrl_SizeStartLctr");
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $fKChain[0] ($modCore + "_Master_Ctrl_SizeStartLctr");
			pointConstraint $fKChain[0] ($modCore + "_Master_Ctrl_SizeEndLctr");
			float $chains = `getAttr ($modCore + "_Master_Ctrl_SizeEndLctr.tx")`;
			scale -r 1 ($chains * .8) ($chains * .3) ($modCore + "_Master_Ctrl");
			makeIdentity -apply true -s 1 ($modCore + "_Master_Ctrl");
			delete ($modCore + "_Master_Ctrl_SizeStartLctr");
		}
			
		//PARENT ORIENT
		$parentOrient = ($modCore + "_Master_Ctrl");
		RRM_ParentOrient($modRigName, $modCore, $modAttachNode, $parentOrient); 
		
		//CONTROLLER SIZE
		float $controllerSize = 1.0;
		float $fKChainDistance = 1.0;
		spaceLocator -n ($modCore + "_StartLctr");
		spaceLocator -n ($modCore + "_EndLctr");
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");					
	
		if ($sizeAllJoints >1)
		{
			pointConstraint $allJoints[0] ($modCore + "_StartLctr");
			aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $allJoints[($sizeAllJoints - 1)] ($modCore + "_StartLctr");
			pointConstraint $allJoints[($sizeAllJoints - 1)] ($modCore + "_EndLctr");
			$fKChainDistance = `getAttr ($modCore + "_EndLctr.tx")`;
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 2);
		}
		else 
		{				
			pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_StartLctr");
			aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $allJoints[0] ($modCore + "_StartLctr");
			pointConstraint $allJoints[0] ($modCore + "_EndLctr");
			$fKChainDistance = `getAttr ($modCore + "_EndLctr.tx")`;
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 0.5);
		}
		if (`size $fKChain` == 1)
		{
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 0.625);
		}
		delete ($modCore + "_StartLctr");

		//CONTROL FOR EACH Fk CHAIN
		
		//MAIN GROUP TO ATTACH CHAINS TO PARENT CONTROL
		group -em -n ($modCore + "_MainChain_CtrlGrp");
		parent ($modCore + "_MainChain_CtrlGrp") ($modCore + "_ScaleGrp");
		
		//CUSTOM ATTRIBUTES FOR MASTER CTRL
		addAttr -ln "curl" -at double -min -100 -max 100 -dv 0 ($modCore + "_Master_Ctrl");
		setAttr -e -k 1 ($modCore + "_Master_Ctrl.curl");
		
		if ($ea == 1)
		{
			addAttr -ln "thumb_curl" -at double -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.thumb_curl");
			
			addAttr -ln "scrunch" -at double -min -20 -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.scrunch");
			
			addAttr -ln "thumb_scrunch" -at double -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.thumb_scrunch");
			
			addAttr -ln "cup" -at double -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.cup");
		}

		if (`size $fkChains` > 1)
		{
			addAttr -ln "spread1" -at double -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.spread1");
			addAttr -ln "spread2" -at double -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.spread2");
		}

		
		if ($ea == 1)
		{
			addAttr -ln "thumb_spread" -at double -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.thumb_spread");
		}
		
		addAttr -ln "lean" -at double -dv 0 ($modCore + "_Master_Ctrl");
		setAttr -e -k 1 ($modCore + "_Master_Ctrl.lean");
		
		addAttr -ln "length" -at double -dv 0 ($modCore + "_Master_Ctrl");
		setAttr -e -k 1 ($modCore + "_Master_Ctrl.length");

		//HIDE END CONTROLS
		addAttr -ln "hideEndFkControls" -at bool ($modCore + "_Master_Ctrl");
		setAttr -e -k 1 -l 0 ($modCore + "_Master_Ctrl.hideEndFkControls");

		if ($fKChainSize > 2)
		{
				//AUTO SPREADS
				addAttr -ln "spreads" -at bool ($modCore + "_Master_Ctrl");
				setAttr -e -k 1 -l true ($modCore + "_Master_Ctrl.spreads");

				addAttr -ln "fkAutoSpreadPos" -at double -min 0 -max 1 -dv 0 ($modCore + "_Master_Ctrl");
				setAttr -e -k 1 ($modCore + "_Master_Ctrl.fkAutoSpreadPos");
				addAttr -ln "fkAutoSpreadRot" -at double -min 0 -max 1 -dv 0 ($modCore + "_Master_Ctrl");
				setAttr -e -k 1 ($modCore + "_Master_Ctrl.fkAutoSpreadRot");
		}
		
		//JOINT INFLUENCE
		addAttr -ln "influences" -at bool ($modCore + "_Master_Ctrl");
		setAttr -e -k 1 -l true ($modCore + "_Master_Ctrl.influences");

		if ($enableIk == 1)
		{
			//ADD SPLINE ATTRIBUTES
			addAttr -ln "splineEffect" -at "enum" -en "Settings:" ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 -l true ($modCore + "_Master_Ctrl.splineEffect");
		
			addAttr -ln "blendedAdditive" -at double -min 0 -max 1 -dv 0 ($modCore + "_Master_Ctrl");
			setAttr -e -k 1 ($modCore + "_Master_Ctrl.blendedAdditive");
		
			if ($fKChainSize > 2)
			{
				addAttr -ln "splineAutoSpreadPos" -at double -min 0 -max 1 -dv 0 ($modCore + "_Master_Ctrl");
				setAttr -e -k 1 ($modCore + "_Master_Ctrl.splineAutoSpreadPos");
		
				addAttr -ln "splineAutoSpreadRot" -at double -min 0 -max 1 -dv 0 ($modCore + "_Master_Ctrl");
				setAttr -e -k 1 ($modCore + "_Master_Ctrl.splineAutoSpreadRot");
			}
		}

		//VARIABLES FOR SPREADING ATTR
		float $outSpreadRatio = -20.0;
		float $inSpreadRatio = 20.0;
	
		for ($crntFkChain in $fKChain)         
		{
			string $nPdCh = "_";
			if ($crntCh < 10)
			{
				$nPdCh = "_0";
			}
	
			$fKJoints = `ls ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + "??")`;
			$fKJointSize = `size $fKJoints`;
			string $crntFkJoint;
			int $crntJnt = 1;

			//INDIVIDUAL MASTER CONTROLS
			curve -n ($modCore + $nPdCh + $crntCh + "_Ctrl") -d 1 -p 0 0 0.25 -p 0 1.75 0.25 -p 0 1.75 -0.25 -p 0 0 -0.25 -k 0 -k 1 -k 2 -k 3 ;
			rename `listRelatives -c -type "shape" ($modCore + $nPdCh + $crntCh + "_Ctrl")` ($modCore + $nPdCh + $crntCh + "_CtrlShape");
			delete `pointConstraint $crntFkChain ($modCore + $nPdCh + $crntCh + "_Ctrl")`;
			parent ($modCore + $nPdCh + $crntCh + "_Ctrl") ($modCore + "_Master_Ctrl");
			//delete `parentConstraint -mo -skipTranslate y -skipTranslate z ($modCore + "_Master_Ctrl") ($modCore + $nPdCh + $crntCh + "_Ctrl")`;
			setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.tx") 0;
			setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.ty") 0;
			setAttr (($modCore + $nPdCh + $crntCh + "_Ctrl.rotate"), 0, 0, 0);
			move -r -os 0 ($controllerSize * $multiplier * 4) 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
			scale -r -os ($controllerSize * 2) ($controllerSize * 2) ($controllerSize * 2) ($modCore + $nPdCh + $crntCh + "_Ctrl");
			if ($crntSide == "right")
			{
				rotate -r -os 180 0 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
			}
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $nPdCh + $crntCh + "_Ctrl");

			//CUSTOM ATTTRIBUTES
			addAttr -ln "curl" -at double -min -100 -max 100 -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
			setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.curl");
			
			if ($ea == 1)
			{
				addAttr -ln "scrunch" -at double -min -20 -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
				setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.scrunch");
			}


			if (`size $fkChains` > 1 && $fKJointSize > 1)
			{
				addAttr -ln "spread1" -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
				setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.spread1");
				addAttr -ln "spread2" -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
				setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.spread2");
			}

			if ($ea == 1)
			{
				addAttr -ln "orbit" -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
				setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.orbit");		
			}
			addAttr -ln "twist" -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
			setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.twist");
			
			addAttr -ln "lean" -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
			setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.lean");

			addAttr -ln "length" -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
			setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.length");


			//ADD ALL BENDS AT ONCE
			if (!`objExists ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_01")`)
			{
				addAttr -ln "bends" -at bool ($modCore + $nPdCh + $crntCh + "_Ctrl");
				setAttr -e -k 1 -l true ($modCore + $nPdCh + $crntCh + "_Ctrl.bends");

				$val = 1;
				$valPad = "0";
				while ($val <= $fKJointSize)
				{
					if ($val > 9)
					{
						$valPad = "";
					}
					addAttr -ln ("bend_" + $valPad + $val) -at double -dv 0 ($modCore + $nPdCh + $crntCh + "_Ctrl");
					setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $valPad + $val);
					$val++;
				}
				//ADD INFLUENCES
				addAttr -ln "drivenControls" -at bool ($modCore + $nPdCh + $crntCh + "_Ctrl");
				setAttr -e -k 1 -l true ($modCore + $nPdCh + $crntCh + "_Ctrl.drivenControls");

				$val = 1;
				$valPad = "0";
				while ($val <= $fKJointSize)
				{
					if ($val > 9)
					{
						$valPad = "";
					}
					addAttr -ln ("joint_inf_" + $valPad + $val) -at double -dv 1 -min 0 -max 1 ($modCore + $nPdCh + $crntCh + "_Ctrl");
					setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_Ctrl.joint_inf_" + $valPad + $val);
					$val++;
				}
			}			
	
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.tx");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.ty");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.tz");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.rx");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.ry");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.rz");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.sx");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.sy");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.sz");
			setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_Ctrl.v");



			for ($crntFkJoint in $fKJoints)
			{
				print ($crntFkJoint+"\n");
				string $nPd = "";
				if ($crntJnt < 10)
				{
					$nPd = "0";
				}
				$nextJnt = ($crntJnt + 1);
				$nPdNext = "";
				if ($nextJnt <10)
				{
					$nPdNext = "0";
				}
				$previousJnt = ($crntJnt - 1);
				$nPdPrev = "";
				if ($previousJnt <10)
				{
					$nPdPrev = "0";
				}


				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk");
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.v") 0;
				if ($enableIk == 1)
				{
					duplicate -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk");
				}
				
				if ($crntJnt == 1)
				{
					//GET JOINT DIRECTION
					$upPos = `xform -q -ws -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_5Shape.cv[1]")`;
					$aimPos = `xform -q -ws -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[7]")`;
					spaceLocator -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr");
					spaceLocator -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr");
					setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr.translate"), $upPos[0], $upPos[1], $upPos[2]);
					setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr.translate"), $aimPos[0], $aimPos[1], $aimPos[2]);


					group -n ($modCore + $nPdCh + $crntCh + "JntGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
					group -n ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntGrp");
					group -n ($modCore + $nPdCh + $crntCh + "JntFkGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk");
					group -n ($modCore + $nPdCh + $crntCh + "JntFkGrp2") ($modCore + $nPdCh + $crntCh + "JntFkGrp");
					parent ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntFkGrp2") ($modCore + "_ScaleGrp");

					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntFkGrp2")`;
					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntGrp2")`;
					delete `aimConstraint -aimVector $multiplier 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntFkGrp2")`;
					delete `aimConstraint -aimVector $multiplier 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntGrp2")`;
					//if ($crntSide == "right")
					//{
					//	select "break";
					//}

					makeIdentity -apply true -t 1 ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntFkGrp2");
					//if ($crntSide == "right"){select "break";}
					if ($enableIk == 1)
					{
						group -n ($modCore + $nPdCh + $crntCh + "JntIkGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk");
						group -n ($modCore + $nPdCh + $crntCh + "JntIkGrp2") ($modCore + $nPdCh + $crntCh + "JntIkGrp");
						delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntIkGrp2")`;

						delete `aimConstraint -aimVector $multiplier 0 0 -upVector 0 $behaviorMultiplier 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
						($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntIkGrp2")`;
						parent ($modCore + $nPdCh + $crntCh + "JntIkGrp2") ($modCore + "_ScaleGrp");
						
						makeIdentity -apply true -t 1 ($modCore + $nPdCh + $crntCh + "JntIkGrp2");
						setAttr ($modCore + $nPdCh + $crntCh + "JntIkGrp2.v") 0;

						//CREATE BLEND
						if (!`objExists ($modCore + "_Master_Ctrl.splineIk_01Inf")`)
						{
							//addAttr -ln "splineInfluence" -at bool ($modCore + $nPdCh + $crntCh + "_Ctrl");
							//setAttr -e -k 1 -l true ($modCore + $nPdCh + $crntCh + "_Ctrl.splineInfluence");						

							$val = 1;
							$valPad = "_0";
							while ($val <= $fKChainSize)
							{
								if ($val > 9)
								{
									$valPad = "_";
								}
								addAttr -ln ("splineIk" + $valPad + $val + "Inf") -at double -min 0 -max 1 -dv 0 ($modCore + "_Master_Ctrl");
								setAttr -e -k 1 ($modCore + "_Master_Ctrl.splineIk" + $valPad + $val + "Inf");
								$val++;
							}
						}
					}
					
					delete ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr");
				
				}
				else
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk")
					($modCore + "_ScaleGrp");
					if ($enableIk == 1)
					{
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk") ($modCore + "_ScaleGrp");
					}
				}					
				
				
				if ($crntSide == "right" && $fKJointSize > 1 && $enableIk == 1)
				{
					select -cl;
					joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide");
					setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide.v") 0;
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide") ($modCore + "_ScaleGrp");           
				}

				//MAIN CONTROL
				if ($crntCh != $fKChainSize || $fKChainSize == 1)
				{
					circle -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") -nr 1 0 0 -r 1 -ch 0;
				}
				//CREATE LAST CONTROL FOR CONNECTING SPREADS
				if ($crntCh == 1 && $fKChainSize > 2)
				{
					if ($fKChainSize < 10)
					{					
						circle -n ($modCore + $nPdCh + $fKChainSize + "_" + $nPd + $crntJnt + "_Ctrl") -nr 1 0 0 -r 1 -ch 0;
					}
					else
					{
						circle -n ($modCore + $fKChainSize + "_" + $nPd + $crntJnt + "_Ctrl") -nr 1 0 0 -r 1 -ch 0;
					}
				}

				scale -r 1 1 0.667 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.cv[3]") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.cv[7]") ;
	
				scale -r 1 ($controllerSize * 3) ($controllerSize * 1) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");
				makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");
					
				group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");
				group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp")`;
				
				if ($enableIk == 1)
				{
					if ($fKJointSize > 1)
					{
						if ($crntFkJoint == 1)
						{
							if ($crntSide == "left" || $crntSide == "")
							{
								parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk") ($modCore + "_extraCurveNodesGrp");
							}
							else
							{
								parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide") ($modCore + "_extraCurveNodesGrp");
							}
						}
		
						//SPLINE CONTROL
						if ($crntCh != $fKChainSize || $fKChainSize == 1)
						{

							curve -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl") -d 1 -p -0.7 3.4 0 -p 0.7 3.4 0 -p 0.7 2.6 0 -p -0.7 2.6 0 -p -0.7 3.4 0 -k 0 -k 1 -k 2 -k 3 -k 4 ;
                            rename `listRelatives ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl")` ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlShape");
							
							curve -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1") -d 1 -p 0 0 0 -p 0 2.6 0 -k 0 -k 1 ;
							rename `listRelatives -c ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1")` ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1Shape");
							parent -r -s ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1Shape") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							//setAttr ("_Spline_Ctrl1Shape.template") 1;
							delete ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1");


							//circle -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl") -nr 0 0 1 -r 1 -ch 0;
							//scale -r 0.25 0.9 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.cv[3]") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.cv[7]") ;
							//
							//move -r -os -wd 0 3 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.cv[0:7]");
							//curve -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1") -d 1 -p 0 0 0 -p 0 2 0 -k 0 -k 1 ;
							//rename `listRelatives -c ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1")` ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1Shape");
							//parent -r -s ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1Shape") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							//setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1Shape.template") 1;
							//delete ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl1");

							scale -r ($controllerSize * $multiplier) ($controllerSize * $multiplier) 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							if ($crntSide == "right" && $behavior == 0)
							{
								rotate -r -os 180 0 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							}
							makeIdentity -apply true -r 1 -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
						}
						if ($crntCh == 1 && $fKChainSize > 2)
						{
							if ($fKChainSize < 10)
							{					
								duplicate -n ($modCore + $nPdCh + $fKChainSize + "_" + $nPd + $crntJnt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							}
							else
							{
								duplicate -n ($modCore + $fKChainSize + "_" + $nPd + $crntJnt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							}
						}

						group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp2") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl"); xform -os -piv 0 0 0;
						group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp2"); xform -os -piv 0 0 0;
						delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp")`;
					}
				}
				
				//GROUPS AND NODES FOR SPREADING
				if ($fKChainSize > 1 && $crntCh != 1 && $crntCh != $fKChainSize) 
				{
					//ONCE FOR Fk AND ONCE FOR SPLINE
					$type = "";
					$spreadPos = ".fkAutoSpreadPos";
					$spreadRot = ".fkAutoSpreadRot";
					int $doubleLoop = 0;
					if ($enableIk == 0)
					{
						$doubleLoop = 1;
					}
					while ($doubleLoop < 2)
					{
						//CREATE GROUP AND CONSTRAINT

						group -em -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp");

						if ($crntJnt == 1)
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp") ($modCore + "_MainChain_CtrlGrp");
						}
						else
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + $type + "_Ctrl");
						}
						delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp")`;
						if ($crntSide == "right")
						{
							if ($behavior == 0)
							{
								rotate -r -os 180 180 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp");
							}
							else if ($behavior == 1)
							{
								rotate -r -os 0 180 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp");								
							}
						}
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlOffsetGrp");
						
						//ADD ATTRIBUTES AND SET WEIGHTS
						float $crntChFloat = ($crntCh - 1);
						float $fKChainSizeFloat = ($fKChainSize - 1);
						float $spreadVal = ($crntChFloat/$fKChainSizeFloat);
		
						addAttr -ln "translateSpreadVal" -at double -min 0 -max 1 -dv $spreadVal ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Ctrl");
						setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Ctrl.translateSpreadVal");
						addAttr -ln "rotateSpreadVal" -at double -min 0 -max 1 -dv $spreadVal ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Ctrl");
						setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Ctrl.rotateSpreadVal");
						

						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.blender");
						connectAttr -f ($modCore + "_01_" + $nPd + $crntJnt + $type + "_Ctrl.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.color2");

						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Ctrl.rotateSpreadVal") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_Blnd.blender");
						connectAttr -f ($modCore + "_01_" + $nPd + $crntJnt + $type + "_Ctrl.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_Blnd.color2");
						if ($fKChainSize < 10)
						{
							connectAttr -f ($modCore + $nPdCh + $fKChainSize + "_" + $nPd + $crntJnt + $type + "_Ctrl.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $fKChainSize + "_" + $nPd + $crntJnt + $type + "_Ctrl.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_Blnd.color1");
							//connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.input2")
						}
						else
						{
							connectAttr -f ($modCore + $fKChainSize + "_" + $nPd + $crntJnt + $type + "_Ctrl.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.color1");
							connectAttr -f ($modCore + $fKChainSize + "_" + $nPd + $crntJnt + $type + "_Ctrl.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_Blnd.color1");
							//connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.input2")
						}

						//AMOUNT OF SPREAD MULTIPLIER
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD");
						connectAttr -force ($modCore + "_Master_Ctrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.input1X");
						connectAttr -force ($modCore + "_Master_Ctrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.input1Y");
						connectAttr -force ($modCore + "_Master_Ctrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.input1Z");

						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_MD");
						connectAttr -force ($modCore + "_Master_Ctrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_MD.input1X");
						connectAttr -force ($modCore + "_Master_Ctrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_MD.input1Y");
						connectAttr -force ($modCore + "_Master_Ctrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_MD.input1Z");

						//CONNECT SPREAD
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.input2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Translate" + $type + "_Spread_MD.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlGrp.translate");

						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_MD.input2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Rotate" + $type + "_Spread_MD.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_CtrlGrp.rotate");


						if ($fKJointSize == 1)
						{//DON'T LOOP IF THERE IS ONLY ONE JOINT PER CHAIN
							$doubleLoop = 2;
						}
						$type = "_Spline";
						$spreadPos = ".splineAutoSpreadPos";
						$spreadRot = ".splineAutoSpreadRot";
						$doubleLoop++;
					}
				}
				else if ($crntJnt > 1)
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "_Ctrl");
					if ($enableIk == 1)
					{
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "_Spline_Ctrl");
					}
				}
				else
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp") ($modCore + "_MainChain_CtrlGrp");
					if ($enableIk == 1 && `objExists ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp")`)
					{
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp") ($modCore + "_MainChain_CtrlGrp");
					}
				}
				//ORIENT JOINT
				if (`objExists ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPdNext + $nextJnt)`)
				{
					//GET LOCATION OF TOP CV
					$proxyUp = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_5Shape.cv[1]")`;
					$proxyAim = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[7]")`;
					//CREATE LOCATOR
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					move -r $proxyAim[0] $proxyAim[1] $proxyAim[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					move -r $proxyUp[0] $proxyUp[1] $proxyUp[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					
					if ($crntSide == "left")
					{
						delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
						("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp")`;
					}
					else if ($crntSide == "right" && $behavior == 0)
					{
						delete `aimConstraint -aimVector -1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
						("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp")`;						
					}
					else if ($crntSide == "right" && $behavior == 1)
					{
						delete `aimConstraint -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
						("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp")`;						
					}


					scale -r 1 0.667 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");

					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
				}
				else
				{
					//GET ORIENTATION USING THE END POINT OF THE END CONTROL
					$proxyAim = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_3Shape.cv[1]")`;
					$ProxyUp = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[3]")`;
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					move -r $proxyAim[0] $proxyAim[1] $proxyAim[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					move -r $ProxyUp[0] $ProxyUp[1] $ProxyUp[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					
					delete `aimConstraint -aimVector ($behaviorMultiplier * 1) 0 0 -upVector 0 ($behaviorMultiplier * 1) 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
					("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp")`;

					scale -r 1 0.667 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl");

					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
				}

				if ($fKJointSize > 1)
				{
					//ORIENT SPLINE CONTROLS
					if ($crntJnt == 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "JntFkGrp");
						
						if ($enableIk == 1)
						{
							//CONNECT BLEND
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIkGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFkGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.color2");
							
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIkGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFkGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.color2");
							
	
							//CREATE ADD
							
							//CREATE BLENDS TO DISABLE ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIkGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.color1");
							$JntIk_Pos = `getAttr ($modCore + $nPdCh + $crntCh + "JntIkGrp.translate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.color2"), $JntIk_Pos[0], $JntIk_Pos[1], $JntIk_Pos[2]);
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd");
							connectAttr -f ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIkGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.color1");
							$JntIk_Rot = `getAttr ($modCore + $nPdCh + $crntCh + "JntIkGrp.rotate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.color2"), $JntIk_Rot[0], $JntIk_Rot[1], $JntIk_Rot[2]);
							
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFkGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.input3D[1]");
		
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFkGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.input3D[1]");
							
							//CREATE MASTER BLEND FOR BLEND AND ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.output3D") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp.translate");
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.output3D") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp.rotate");
						}
					}
					else
					{
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk")`;
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt")`;

						makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk");
						if ($enableIk == 1)
						{
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk")`;
							makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk");
						}
					}
						
					parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk");
					
					if ($crntSide == "right" && $fKJointSize > 1 && $enableIk == 1)
					{
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide")`;
						//rotate -r -os 0 180 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide");
						makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide");
					}
					
					
					//SCALE CONSTRAINT Fk JOINTS TO CONTROLS
					if ($crntJnt == 1)
					{
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.scale");
					}
					else
					{
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFk_Scale_MD");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFk.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFk_Scale_MD.input1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFk_Scale_MD.input2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFk_Scale_MD.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.scale");
					}
						
					if ($crntJnt != 1)
					{
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Jnt");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFk");
						if ($enableIk == 1)
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntIk");
						
							if ($crntSide == "right")
							{
								parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntIkGuide");
							}
						}
	
						if ($fKJointSize > 1 && $enableIk == 1)
						{
							//ORIENT SPLINE CONTROLS
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp")`;
							parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_ScaleGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp");
	
							if ($crntJnt != 1)
							{
								//ADD ATTRIBUTES TO THE CONTROLS
								addAttr -ln "localSpace" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
								setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace");
		
								addAttr -ln "parentInfluence" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
								setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.parentInfluence");
								
								//ATTRIBUTE CONNECTIONS
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
								shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD");
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_ParentInf_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD.input1X");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD.input1Y");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.parentInfluence") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD.input2X");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.parentInfluence") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_ParentInf_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_ParentInf_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD.input2Y");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp_parentConstraint1." + $modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "_Spline_CtrlW2");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp_parentConstraint1." + $modCore + "_ScaleGrpW1");
							}
						}
					}
					else if ($crntJnt == 1 && $fKJointSize > 1)
					{
						if ($enableIk == 1)
						{
							//ORIENT SPLINE CONTROLS
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp")`;
							if ($crntCh == 1 || $crntCh == $fKChainSize)
							{
								parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_ScaleGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp");
							}
							parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "JntIkGrp");
		
							//ADD ATTRIBUTES TO THE FIRST CONTROL
							addAttr -ln "localSpace" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace");
							
							addAttr -ln "stretch" -at double -min 0 -max 1 -dv 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.stretch");
							
							addAttr -ln "autoVolume" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl");
							setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.autoVolume");
		
							//ATTRIBUTE CONNECTIONS
							if ($crntCh == 1 || $crntCh == $fKChainSize)
							{
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp_parentConstraint1." + $modCore + "_ScaleGrpW1");
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.localSpace") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl_Follow_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW0");
							}
	
							//CONNECT SPLINE ATTRIBUTE TO CONDITIONALS FOR THE VISIBILITY OF THE CONTROLS
							shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_Spline_Ctrl_Vis_Condition");
							connectAttr -f ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_Spline_Ctrl_Vis_Condition.firstTerm");
							setAttr ($modCore + $nPdCh + $crntCh + "_Spline_Ctrl_Vis_Condition.secondTerm") 0;
							setAttr ($modCore + $nPdCh + $crntCh + "_Spline_Ctrl_Vis_Condition.operation") 0;
							
							shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_Fk_Ctrl_Vis_Condition");
							connectAttr -f ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_Fk_Ctrl_Vis_Condition.firstTerm");
							setAttr ($modCore + $nPdCh + $crntCh + "_Fk_Ctrl_Vis_Condition.secondTerm") 1;
							setAttr ($modCore + $nPdCh + $crntCh + "_Fk_Ctrl_Vis_Condition.operation") 0;
							
							//CREATE CONDITIONAL TO OVERRIDE VISIBILITY IF ADDITIVE IS ON.
							shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition");
							connectAttr -f ($modCore + "_Master_Ctrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.firstTerm");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_Fk_Ctrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.colorIfTrueR");
						}
					}
					
					if ($fKJointSize > 1)
					{
						//CREATE BLEND FOR THE STARTING GROUP IF IT DOESN'T ALREADY EXIST
						//CONNECT SPLINE ATTRIBUTE TO BLEND THE SKINNING JOINTS
						//BLENDS
						if ($enableIk == 1)
						{
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Blnd.color2");
							
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Blnd.color2");
							
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Scale_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Scale_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Scale_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Scale_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Scale_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.scale");
						
							//ADDS
							//CREATE BLENDS TO DISABLE ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Add_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Add_Blnd.color1");
							$JntFk_Pos = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.translate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Add_Blnd.color2"), $JntFk_Pos[0], $JntFk_Pos[1], $JntFk_Pos[2]);
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Add_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.splineIk" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Add_Blnd.color1");
							$JntFk_Rot = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.rotate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Add_Blnd.color2"), $JntFk_Rot[0], $JntFk_Rot[1], $JntFk_Rot[2]);
		
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Pma.input3D[1]");
		
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFk.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Pma.input3D[1]");
						
							//CREATE SUBTRACT TO ZERO OUT JOINTS
							$jointTranslate = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.translate")`;
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_PosSubtract_Pma");
							setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_PosSubtract_Pma.operation") 2;
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_PosSubtract_Pma.input3D[0]");
							setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_PosSubtract_Pma.input3D[1]"), ($jointTranslate[0]*1), ($jointTranslate[1]*1), ($jointTranslate[2]*1));
							
							//CREATE MASTER BLEND FOR BLEND AND ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Master_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_PosSubtract_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Pos_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.translate");
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Master_Blnd");
							connectAttr ($modCore + "_Master_Ctrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIk_Rot_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.rotate");
					
							//CONNECT SPLINE ATTRIBUTE TO THE VISIBILITY OF THE CONTROLS
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.v");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_Spline_Ctrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.v");
							setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl.v");
						}
					}
					//ORIENT CONSTRAINT RIGHT Ik JOINTS TO GUIDE JOINTS
					if ($crntSide == "right" && $fKJointSize > 1 && $enableIk == 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk");
						connectAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIkGuide.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIk.scale");
					}
						
					//CREATE SPLINE Ik
					if (($crntJnt == $fKJointSize) && ($fKJointSize > 2) && $enableIk == 1)
					{
						$JntIk = "JntIk";
						if ($crntSide == "right")
						{
							$JntIk = "JntIkGuide";
						}
						
						select ($modCore + $nPdCh + $crntCh + "_01" + $JntIk) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIk);
						ikHandle -n ($modCore + $nPdCh + $crntCh + "_IkHandle") -sol ikSplineSolver -scv false;
						$SplineCurve = `listConnections -type "nurbsCurve" ($modCore + $nPdCh + $crntCh + "_IkHandle")`;
						rename $SplineCurve ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						arclen -ch 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						$curveInfoNode = `listConnections -t curveInfo -d 1 -s 0 ($modCore + $nPdCh + $crntCh + "_SplineCurveShape")`;
						rename $curveInfoNode[0] ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Spline_Ctrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_SplineCurve.v");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurve.template") 1;

						addAttr -ln "nonControl" -dt "string" ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						setAttr -e -k 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve.nonControl");
						setAttr -l 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve.nonControl");

						parent ($modCore + $nPdCh + $crntCh + "_SplineCurve") ($modCore + "_extraCurveNodesGrp");
						
						parent ($modCore + $nPdCh + $crntCh + "_IkHandle") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $nPdCh + $crntCh + "_IkHandle.v") 0;
						
						//CONNECT SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo.arcLength") ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.input1X");
						connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.input2X");
						
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input1X");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.operation") 2;
						
						float $splineLengthValue = `getAttr ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo.arcLength")`;
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input2X") $splineLengthValue;
						
						//BLEND SCALE
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01_Spline_Ctrl.stretch") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.outputX") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk + ".sx");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIk + ".sx");
						
						//INVERSE SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input1X") 1;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input2X");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.operation") 2;
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01_Spline_Ctrl.autoVolume") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk + ".sy");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk + ".sz");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIk + ".sy");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIk + ".sz");
	
						//ADVANCED TWIST
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IkTwistStartLctr");
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IkTwistEndLctr");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_01_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_IkTwistStartLctr");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_IkTwistEndLctr");
	
						parent ($modCore + $nPdCh + $crntCh + "_IkTwistStartLctr") ($modCore + $nPdCh + $crntCh + "_IkTwistEndLctr") ($modCore + "Grp");
						setAttr ($modCore + $nPdCh + $crntCh + "_IkTwistStartLctr.v") 0;
						setAttr ($modCore + $nPdCh + $crntCh + "_IkTwistEndLctr.v") 0;
						
						setAttr ($modCore + $nPdCh + $crntCh + "_IkHandle.dTwistControlEnable") 1;
						setAttr ($modCore + $nPdCh + $crntCh + "_IkHandle.dWorldUpType") 4;
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IkTwistStartLctr.xformMatrix") ($modCore + $nPdCh + $crntCh + "_IkHandle.dWorldUpMatrix");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IkTwistEndLctr.xformMatrix") ($modCore + $nPdCh + $crntCh + "_IkHandle.dWorldUpMatrixEnd");
	
						
						////////////CREATE CLUSTERS////////////
						//START CLUSTER
						select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[0:1]");
						newCluster " -envelope 1";
						rename ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr");
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_01_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr") ($modCore + "_curveNodesGrp");
						
						//MIDDLE CLUSTERS
						int $midClstrInt = 2;
						int $prevMidClstrInt = 1;
						string $prevMidControlnPd;
						while ($midClstrInt < $crntJnt)
						{
							$midControlnPd = "0";
							if ($midClstrInt > 9)
							{
								$midControlnPd = "";
							}
							$prevMidControlnPd = "0";
							if ($midClstrInt > 9)
							{
								$prevMidControlnPd = "";
							}
	
							select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[" + $midClstrInt + "]");
							newCluster " -envelope 1";
							rename ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr");
							parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr");
							setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr.v") 0;
							parent ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr") ($modCore + "_curveNodesGrp");
							
							//CONNECT STRETCH TO MIDDLE JOINTS
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIk + ".sx");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIk + ".sy");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIk + ".sz");
							$midClstrInt++;
							$prevMidClstrInt++;
						}
						//END CLUSTER
						select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[" + $crntJnt + ":" + ($crntJnt + 1) + "]");
						newCluster " -envelope 1";
						rename ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr");
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr") ($modCore + "_curveNodesGrp");

					}
					else if (($crntJnt == $fKJointSize) && ($fKJointSize == 2) && $enableIk == 1)
					{
						$JntIk = "JntIk";
						if ($crntSide == "right")
						{
							$JntIk = "JntIkGuide";
							$multiplier = -1;
						}
						//USE AIM CONSTRAINTS IF ONLY TWO JOINTS PER CHAIN
						aimConstraint -mo -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + $nPdCh + $crntCh + "_01" + "_Spline_Ctrl")
						($modCore + $nPdCh + $crntCh + "_02" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk);
						if ($crntSide == "right")
						{
							pointConstraint ($modCore + $nPdCh + $crntCh + "_01" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk);
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_02" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIk)`;
							rotate -r 0 -180 0 ($modCore + $nPdCh + $crntCh + "_02" + $JntIk);
							parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_02" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIk);
						}
						else
						{
							parentConstraint ($modCore + $nPdCh + $crntCh + "_02" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIk);
						}
						
						//STRETCH
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IkStretch_AimLctr");
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IkStretch_TargetLctr");
						parent ($modCore + $nPdCh + $crntCh + "_IkStretch_TargetLctr") ($modCore + $nPdCh + $crntCh + "_IkStretch_AimLctr");
						setAttr ($modCore + $nPdCh + $crntCh + "_IkStretch_AimLctr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_IkStretch_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spline_CtrlGrp");
						pointConstraint ($modCore + $nPdCh + $crntCh + "_01" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_IkStretch_AimLctr");
						aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none"
						($modCore + $nPdCh + $crntCh + "_02" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_IkStretch_AimLctr");
						pointConstraint ($modCore + $nPdCh + $crntCh + "_02" + "_Spline_Ctrl") ($modCore + $nPdCh + $crntCh + "_IkStretch_TargetLctr");
						$targetLctrPos = `getAttr ($modCore + $nPdCh + $crntCh + "_IkStretch_TargetLctr.tx")`;
						
						//SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IkStretch_TargetLctr.tx") ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input1X");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input2X") $targetLctrPos;
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01_Spline_Ctrl.stretch") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.outputX") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk + ".sx");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIk + ".sx");
						
						//INVERSE SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.operation") 2;
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input1X") 1;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input2X");
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01_Spline_Ctrl.autoVolume") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color1R");
						                                   
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk + ".sy");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIk + ".sz");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIk + ".sy");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIk + ".sz");
					}
				}
				else
				{
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "JntGrp");
				}
				//if ($crntSide == "right")
				//{
				//	select "break";
				//}
				
				if ($enableIk == 0)
				{
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
					connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.scale");
					//scaleConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
				}

				//CONNECT LAST FK CONTROL VISIBILITY
				if ($fKJointSize == $crntJnt)
				{
					connectAttr -f ($modCore + "_Master_Ctrl.hideEndFkControls") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.v");
					setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Ctrl.v");
				}

				//SET DRIVEN KEYS ON MASTER CONTROL
				if (!`objExists ($modCore + "_Master_Ctrl.drivenControls")`)
				{
					addAttr -ln "drivenControls" -at bool ($modCore + "_Master_Ctrl");
					setAttr -e -k 1 -l true ($modCore + "_Master_Ctrl.drivenControls");
				}
				if (!`objExists ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt)`)
				{
					addAttr -ln ("joint_inf" + "_" + $nPd + $crntJnt) -at double -min 0 -max 1 -dv 1 ($modCore + "_Master_Ctrl");
					setAttr -e -k 1 ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt);
				}
				//MASTER CURL
				if (!`objExists ($modCore + $nPd + $crntJnt + "_Curl_MD")`)
				{
					shadingNode -asUtility multiplyDivide -n ($modCore + $nPd + $crntJnt + "_Curl_MD");
					connectAttr -force ($modCore + "_Master_Ctrl.curl") ($modCore + $nPd + $crntJnt + "_Curl_MD.input1X");
					connectAttr -force ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPd + $crntJnt + "_Curl_MD.input2X");
				}


				//shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD");
				//connectAttr -force ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.input1X");
				//connectAttr -force ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.input2X");

				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Curl_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + "_Master_Ctrl.curl") 10;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ") -90;
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Curl_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + "_Master_Ctrl.curl") -10;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ") 90;
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Curl_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + "_Master_Ctrl.curl") 0;

				//THUMB CURL
				/*
				setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setAttr ($modCore + "_Master_Ctrl.curl") -10;
				rotate -r -90 0 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setAttr ($modCore + "_Master_Ctrl.curl") 10;
				rotate -r 90 0 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				//SCRUNCH
				setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				*/
				//SCRUNCH
				/*
				setAttr ($modCore + "_Master_Ctrl.curl") -10;
				rotate -r -90 0 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setAttr ($modCore + "_Master_Ctrl.curl") 10;
				rotate -r 90 0 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp");
				*/

				//THUMB SCRUNCH

				//CUP

				//MASTER SPREAD
				//if (`size $fKChain` > 1)
				if ($fKChainSize > 1 && $fKJointSize > 1)
				{
					//if ($crntJnt == 1 || $crntJnt == 2)
					//{
					//	if (!`objExists ($modCore + $nPd + $crntJnt + "_Spread_Condition")`)
					//	{
					//		shadingNode -asUtility condition -n ($modCore + $nPd + $crntJnt + "_Spread_Condition");
					//		connectAttr -f ($modCore + "_Master_Ctrl.spreadJoint") ($modCore + $nPd + $crntJnt + "_Spread_Condition.firstTerm");
					//		setAttr ($modCore + $nPd + $crntJnt + "_Spread_Condition.secondTerm") ($crntJnt - 1);
					//		connectAttr -f ($modCore + "_Master_Ctrl.spread") ($modCore + $nPd + $crntJnt + "_Spread_Condition.colorIfTrueR");
					//		setAttr ($modCore + $nPd + $crntJnt + "_Spread_Condition.colorIfFalseR") 0;
//
					//		shadingNode -asUtility multiplyDivide -n ($modCore + $nPd + $crntJnt + "_Spread_MD");
					//		connectAttr -force ($modCore + $nPd + $crntJnt + "_Spread_Condition.outColorR") ($modCore + $nPd + $crntJnt + "_Spread_MD.input1X");
					//		connectAttr -force ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPd + $crntJnt + "_Spread_MD.input2X");
					//	}
					//	if ($crntJnt == 2)
					//	{
					//		setAttr ($modCore + "_Master_Ctrl.spreadJoint") 1;
					//	}	
					//	setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
					//	setAttr ($modCore + "_Master_Ctrl.spread") 10;
					//	setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") $outSpreadRatio;
				//
					//	setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
					//	setAttr ($modCore + "_Master_Ctrl.spread") -10;
					//	setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") $inSpreadRatio;
					//	setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");				
					//	setAttr ($modCore + "_Master_Ctrl.spread") 0;
//
					//	setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
					//	setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
//
					//	setAttr ($modCore + "_Master_Ctrl.spreadJoint") 0;
					//}
				
					if ($crntJnt == 1 || $crntJnt == 2)
					{
						//if (!`objExists ($modCore + $nPd + $crntJnt + "_Spread_MD")`)
						//{
						//	shadingNode -asUtility multiplyDivide -n ($modCore + $nPd + $crntJnt + "_Spread_MD");
						//	connectAttr -force ($modCore + "_Master_Ctrl.spread" + $crntJnt) ($modCore + $nPd + $crntJnt + "_Spread_MD.input1X");
						//	connectAttr -force ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPd + $crntJnt + "_Spread_MD.input2X");
						//}

						setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.spread" + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
						setAttr ($modCore + "_Master_Ctrl.spread" + $crntJnt) 10;
						setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") $outSpreadRatio;
				
						setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.spread" + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
						setAttr ($modCore + "_Master_Ctrl.spread" + $crntJnt) -10;
						setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") $inSpreadRatio;
						setDrivenKeyframe -currentDriver ($modCore + "_Master_Ctrl.spread" + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");				
						setAttr ($modCore + "_Master_Ctrl.spread" + $crntJnt) 0;

						setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
						setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
					}
				}			

				//THUMB SPREAD

				//MASTER LEAN
				if (!`objExists ($modCore + $nPd + $crntJnt + "_Lean_MD")`)
				{
					shadingNode -asUtility multiplyDivide -n ($modCore + $nPd + $crntJnt + "_Lean_MD");
					connectAttr -force ($modCore + "_Master_Ctrl.lean") ($modCore + $nPd + $crntJnt + "_Lean_MD.input1X");
					connectAttr -force ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPd + $crntJnt + "_Lean_MD.input2X");
				}

				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Lean_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				setAttr ($modCore + "_Master_Ctrl.lean") 100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") -250;
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Lean_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				setAttr ($modCore + "_Master_Ctrl.lean") -100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") 250;
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Lean_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");				
				setAttr ($modCore + "_Master_Ctrl.lean") 0;

				setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");


				//MASTER LENGTH
				if (!`objExists ($modCore + $nPd + $crntJnt + "_Length_MD")`)
				{
					shadingNode -asUtility multiplyDivide -n ($modCore + $nPd + $crntJnt + "_Length_MD");
					connectAttr -force ($modCore + "_Master_Ctrl.length") ($modCore + $nPd + $crntJnt + "_Length_MD.input1X");
					connectAttr -force ($modCore + "_Master_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPd + $crntJnt + "_Length_MD.input2X");
				}

				$length = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.tx")`;
				//print ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt's length is " + $length + "\n");
				//select "break";
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Length_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");
				setAttr ($modCore + "_Master_Ctrl.length") 101;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX") 20;
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Length_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");
				setAttr ($modCore + "_Master_Ctrl.length") -99;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX") -20;
				setDrivenKeyframe -currentDriver ($modCore + $nPd + $crntJnt + "_Length_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");		
				setAttr ($modCore + "_Master_Ctrl.length") 0;

				setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");
				setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");

				keyTangent -itt spline -ott spline
				($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_scaleX");


				keyTangent -itt spline -ott spline
				($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_rotateY")
				($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_rotateZ");


				//SET DRIVEN KEYS ON EACH FINGER
				//CURL


				shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD");
				connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.curl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.input1X");
				connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.joint_inf_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.input2X");

				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.outputX") 100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ") -900;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.curl") -100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ") 900;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Curl_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.curl") 0;
			

				//SCRUNCH

				//SPREAD

				//if ($crntJnt == 1 && `size $fKChain` > 1)
				//{
				//	shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread_MD");
				//	connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.spread") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread_MD.input1X");
				//	connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.joint_inf_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread_MD.input2X");
//
				//	setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				//	setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.spread") 100;
				//	setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") ($outSpreadRatio * 10);
				//	setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				//	setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.spread") -100;
				//	setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") ($inSpreadRatio * 10);
				//	setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");				
				//	setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.spread") 0;
//
				//	setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				//	setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				//}

				if (`size $fKChain` > 1)
				{
					if ($crntJnt == 1 || $crntJnt == 2)
				{
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread" + $crntJnt + "_MD");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.spread" + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread" + $crntJnt + "_MD.input1X");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.joint_inf" + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread" + $crntJnt + "_MD.input2X");
					
						setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread" + $crntJnt + "_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
						setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.spread" + $crntJnt) 100;
						setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") ($outSpreadRatio * 10);
				
						setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread" + $crntJnt + "_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
						setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.spread" + $crntJnt) -100;
						setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") ($inSpreadRatio * 10);
						setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Spread" + $crntJnt + "_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");				
						setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.spread" + $crntJnt) 0;

						setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
						setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
					}
				}



				//ORBIT

				//TWIST
				shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Twist_MD");
				connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.twist") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Twist_MD.input1X");
				connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.joint_inf_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Twist_MD.input2X");

				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Twist_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateX");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.twist") 100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateX") -900;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Twist_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateX");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.twist") -100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateX") 900;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Twist_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateX");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.twist") 0;

				//LEAN
				shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Lean_MD");
				connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.lean") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Lean_MD.input1X");
				connectAttr -force ($modCore + $nPdCh + $crntCh + "_Ctrl.joint_inf_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Lean_MD.input2X");

				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Lean_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.lean") 100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") -250;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Lean_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.lean") -100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY") 250;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_Lean_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateY");				
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.lean") 0;

				//BENDS
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $nPd + $crntJnt) 100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ") -900;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $nPd + $crntJnt) -100;
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ") 900;
				setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.rotateZ");
				setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.bend_" + $nPd + $crntJnt) 0;

				keyTangent -itt spline -ott spline
				($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_rotateX")
				($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_rotateY")
				($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_rotateZ");

				//JOINT INFLUENCE

				if ($crntJnt > 1)
				{
					$length = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.tx")`;
					setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_Ctrl.length") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");
					setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.length") 101;
					setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX") 20;
					setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_Ctrl.length") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");
					setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.length") -99;
					setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX") -20;
					setDrivenKeyframe -currentDriver ($modCore + $nPdCh + $crntCh + "_Ctrl.length") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");		
					setAttr ($modCore + $nPdCh + $crntCh + "_Ctrl.length") 0;
					
					$animCurves = `listConnections -c 0 -d 1 -type "animCurveUA" ($modCore + $nPdCh + $crntCh + "_Ctrl")`;
					for ($anim in $animCurves)
					{
						setInfinity -pri linear $anim;
						setInfinity -poi linear $anim;
						keyTangent -itt spline -ott spline $anim;

					}
						

					setInfinity -pri linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");
					setInfinity -poi linear ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp.scaleX");

					keyTangent -itt spline -ott spline
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_CtrlSdkGrp_scaleX");
				}

				$crntJnt++;
			}

			if (`size $fKChain` > 1)
			{
				float $sizeFloat = `size $fKChain`;
				float $sizeCnt = $crntCh;
				$outSpreadRatio = (-20 + (40 * (($sizeCnt) / ($sizeFloat - 1))));
				$inSpreadRatio = (20 - (40 * (($sizeCnt) / ($sizeFloat - 1))));
			}

			$crntCh++;
		}
		
		
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*_Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("" + $prfx + $core);
			setAttr -e-l 1 ($crntModControl + ".modCoreName");
			
			//ADD MODULE TYPE
			addAttr -ln "moduleType" -dt "string" ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "fkChain";
			setAttr -l true ($crntModControl + ".moduleType");
			
			//ADD DIRECTION
			$direction = `getAttr ($topNode + ".direction")`;
			addAttr -ln "direction" -at long ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".direction");
			setAttr ($crntModControl + ".direction") $direction;
			setAttr -l true ($crntModControl + ".direction");

			setAttr -l 1 -k 0 ($crntModControl + ".v");
		}

		//LOCK MASTER CONTROL ATTRIBUTES
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_Master_Ctrl.v");
		
		select -cl;

		//SETUP FOR RIGHT SIDE
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;

	}
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Parent")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Parent")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Parent");}
	else if (`objExists ("RRM_" + $modRigName + "Parent")`)
		{select ("RRM_" + $modRigName + "Parent");}
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE HEAD MODULE////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigHead(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;  

	//INTEGER FOR LOOP
	$mirrorInt = 2;
	$multiplier = 1;
	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";

	float $behavior = 1;
	float $behaviorMultiplier = 1;

	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = $lPrfx;
		$oppPrfx = $rPrfx;

		$mirrorInt = 1;
		if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behavior = 0;
			}
		}
	}
	$crntSide = "left";
	$oppSide = "right";
	

	while ($mirrorInt <= 2)
	{
		if ($crntSide == "right" && `objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behaviorMultiplier = -1;
			}
		}

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$modOppCore = ($modRigName + "" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "head";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}
		
		//NODE-SPECIFI_Ctrl ATTRIBUTES
		//JAW
		if (`objExists ("RRM_" + $prfx + $core + "_Jaw")`)
		{
			addAttr -ln "jaw" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.jaw");
			setAttr -l true ($modCore + "Grp.jaw");
		}
	
	
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		delete `aimConstraint -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		("RRM_" + $prfx + $core + "_Top") ($modCore + "_ScaleGrp")`;
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");
		
		//MASTER SCALE GROUP
		group -em -n ($modCore + "_Master_CtrlScaleGrp");
	
		//HEAD CONTROL
		curve -n ($modCore + "_Master_Ctrl") -d 1 -p -1 0 -1 -p 1 0 -1 -p 1 0 1 -p -1 0 1 -p -1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modCore + "_Master_Ctrl")` ($modCore + "_Master_CtrlShape");
		
		//GET SIZE
		spaceLocator -n ($modCore + "_HeadStartLctr");
		spaceLocator -n ($modCore + "_HeadEndLctr");
		parent ($modCore + "_HeadEndLctr") ($modCore + "_HeadStartLctr");
		pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_HeadStartLctr");
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $core + "_Top") ($modCore + "_HeadStartLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_HeadEndLctr");
		$scale = `getAttr ($modCore + "_HeadEndLctr.tx")`;
		scale -r ($scale /5) ($scale /5) ($scale /5) ($modCore + "_Master_Ctrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Master_Ctrl");
	
		group -n ($modCore + "_Master_CtrlGrp") ($modCore + "_Master_Ctrl");
		parent ($modCore + "_Master_CtrlGrp") ($modCore + "_ScaleGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_Master_CtrlGrp")`;
		if ($crntSide == "right" && $behavior == 0)
		{
			$rz = `getAttr ($modCore + "_Master_CtrlGrp.rz")`;
			rotate -r -os 180 0 ($rz * -1) ($modCore + "_Master_CtrlGrp");
			rotate -r -os -180 0 0 ($modCore + "_Master_Ctrl");
		}
		//makeIdentity -apply false -t 1 -r 1 ($modCore + "_Master_CtrlGrp");
		move -r -os -wd 0 ($scale * 1.3) 0 ($modCore + "_Master_Ctrl.cv[0:24]");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Master_Ctrl");
		parentConstraint -mo ($modCore) ($modCore + "_Master_CtrlGrp");
		 
		//PARENT ORIENT
		$parentOrient = ($modCore + "_Master_Ctrl");
		RRM_ParentOrient($modRigName, $modCore, $modAttachNode, $parentOrient);
		
	
		if (`objExists ("RRM_" + $prfx + $core + "_Jaw")`)
		{
		//JAW CONTROL
			circle -n ($modCore + "_Jaw_Ctrl") -nr 0 0 1 -r 1 -ch 0;
			scale -r 1 0.5 1 ($modCore + "_Jaw_Ctrl");
			move -r -os -wd 0 0 1.2 ($modCore + "_Jaw_Ctrl.cv[1]") ($modCore + "_Jaw_Ctrl.cv[5]");
			move -r -os -wd 0 0 0.58 ($modCore + "_Jaw_Ctrl.cv[0]") ($modCore + "_Jaw_Ctrl.cv[2]") ($modCore + "_Jaw_Ctrl.cv[4]") ($modCore + "_Jaw_Ctrl.cv[6]");
			select ($modCore + "_Jaw_Ctrl") ;
			rotate -r -os 35 0 0 ($modCore + "_Jaw_Ctrl");
			scale -r ($scale /3) ($scale /3) ($scale /3);
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Jaw_Ctrl");
			group -n ($modCore + "_Jaw_CtrlGrp");
			parent ($modCore + "_Jaw_CtrlGrp") ($modCore + "_Master_CtrlScaleGrp");
			
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Jaw") ($modCore + "_Jaw_CtrlGrp")`;
			if ($crntSide == "right" && $behavior == 0)
			{
				$rz = `getAttr ($modCore + "_Jaw_CtrlGrp.rz")`;
				rotate -r -os 180 0 ($rz * -1) ($modCore + "_Jaw_CtrlGrp");
				rotate -r -os -180 0 0 ($modCore + "_Jaw_Ctrl");
			}
			delete `pointConstraint ("RRM_" + $prfx + $core + "_JawEnd") ($modCore + "_Jaw_Ctrl")`;
			$jawCOffset = `getAttr ($modCore + "_Jaw_Ctrl.translate")`;
			move -r ($jawCOffset[0] * 1.2) ($jawCOffset[1] * 1.2) ($jawCOffset[2] * 1.2) ($modCore + "_Jaw_Ctrl.translate");
			makeIdentity -apply true ($modCore + "_Jaw_Ctrl");
			$jawPivot = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Jaw")`;
			move -a $jawPivot[0] $jawPivot[1] $jawPivot[2] ($modCore + "_Jaw_Ctrl.scalePivot") ($modCore + "_Jaw_Ctrl.rotatePivot") ;
			
		
			//JOINTS
			select -cl;
			joint -n ($modCore + "_JawJnt");
			joint -n ($modCore + "_JawEndJnt");

			delete `parentConstraint ($modCore + "_Jaw_Ctrl") ($modCore + "_JawJnt")`;
			parentConstraint -mo ($modCore + "_Jaw_Ctrl") ($modCore + "_JawJnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_JawEnd") ($modCore + "_JawEndJnt")`;
			if ($crntSide == "right" && $behavior == 0)
			{
				$rz = `getAttr ($modCore + "_JawEndJnt.rz")`;
				rotate -r -os 180 0 ($rz * -1) ($modCore + "_JawEndJnt");
			}

			parent ($modCore + "_JawJnt") ($modCore + "_Master_CtrlScaleGrp");
		}
		
		parent ($modCore + "_Master_CtrlScaleGrp") ($modCore + "_ScaleGrp");
			
		
		select -cl;
		joint -n ($modCore + "_TopJnt");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_TopJnt")`;
		
		parent ($modCore + "_TopJnt") ($modCore + "_Master_CtrlScaleGrp");
		
		//SET JAW AND END NODES TO SCALE WITH MASTER CTRL
		scaleConstraint ($modCore + "_Master_Ctrl") ($modCore + "_Master_CtrlScaleGrp");
		parentConstraint -mo ($modCore + "_Master_Ctrl") ($modCore + "_Master_CtrlScaleGrp");
		
		delete ($modCore + "_HeadStartLctr") ($modCore + "_HeadEndLctr");
	
		//ADD CORE NAME
		select ($modCore + "_Master_Ctrl");
		if (`objExists ($modCore + "_Jaw_Ctrl")`)
		{
			select -add ($modCore + "_Jaw_Ctrl");
		}
		$modControls = `ls -sl`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("" + $prfx + $core);
			setAttr -e-l 1 ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType" -dt "string" ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "head";
			setAttr -l true ($crntModControl + ".moduleType");
		}
		
		//SETUP FOR RIGHT SIDE
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
	}
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Parent")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Parent")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Parent");}
	else if (`objExists ("RRM_" + $modRigName + "Parent")`)
		{select ("RRM_" + $modRigName + "Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE LOOK AT MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EyeControl()
{
	circle -n "RRM_EyeControl" -nr 0 1 0 -r 1 -ch 0;
	curve -n "RRM_EyeControl1" -d 1 -p 0 0 -1 -p 0 0 1 -k 0 -k 1 ;
	rename `listRelatives -c "RRM_EyeControl1"` "RRM_EyeControl1Shape";
	curve -n "RRM_EyeControl2" -d 1 -p -1 0 0 -p 1 0 0 -k 0 -k 1 ;
	rename `listRelatives -c "RRM_EyeControl2"` "RRM_EyeControl2Shape";
		
	parent -r -s "RRM_EyeControl1Shape" "RRM_EyeControl2Shape" "RRM_EyeControl";
	delete "RRM_EyeControl1" "RRM_EyeControl2";
}

global proc RRM_GenerateRigLookAt(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	$mirrorInt = 1;
	float $rotOffset = 0;
	float $lookAtSize;
	string $modAttachNode;
	string $modCore;
	
	string $prfx = "";
	string $oppPrfx = "";

	float $behavior = 1;
	float $behaviorMultiplier = 1;

	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = $lPrfx;
		$oppPrfx = $rPrfx;

		$mirrorInt = 1;
		if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behavior = 0;
			}
		}
	}

	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = $lPrfx;
		$oppPrfx = $rPrfx;

		$mirrorInt = 0;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		$modOppCore = ($modRigName + "" + $oppPrfx + $core);
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "lookAt";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
	
		addAttr -ln "lookAts" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.lookAts") ;
		setAttr -type "string" ($modCore + "Grp.lookAts") `size $lookAts`;
		setAttr -l true ($modCore + "Grp.lookAts");
	
		//SCALE GROUP
		spaceLocator -n ($modCore + "_AveragePosition_Lctr");
		parentConstraint $lookAts ($modCore + "_AveragePosition_Lctr");

		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modCore + "_ScaleGrp");
		}
		delete ($modCore + "_AveragePosition_Lctr");
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");
	
	
		//MASTER CONTROLLER
		circle -n ($modCore + "_Master_Ctrl") -nr 1 0 0 -r 1 -d 1 -s 4 -ch 0;
		rotate -r 45 90 0 ($modCore + "_Master_Ctrl");
		makeIdentity -apply true -r 1 ($modCore + "_Master_Ctrl");
		group -n ($modCore + "_Master_CtrlGrp") ($modCore + "_Master_Ctrl");
		parent ($modCore + "_Master_CtrlGrp") ($modCore + "_ScaleGrp");
	
		//SCALE MASTER CONTROLLER
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		
		if (`size $lookAts` == 1)
		{
			$lookAtSize = `getAttr "RRM_MAIN.scaleY"`;
			scale -a ($lookAtSize * 1) ($lookAtSize * 1) $lookAtSize ($modCore + "_Master_CtrlGrp");
			delete `parentConstraint $lookAts ($modCore + "_Master_CtrlGrp")`;
		}
		else
		{
			spaceLocator -n ($modCore + "_Master_Ctrl_StartAttachLctr");
			spaceLocator -n ($modCore + "_Master_Ctrl_EndAttachLctr");
			parent ($modCore + "_Master_Ctrl_EndAttachLctr") ($modCore + "_Master_Ctrl_StartAttachLctr");
			pointConstraint $lookAts[0] ($modCore + "_Master_Ctrl_StartAttachLctr");
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "Grp")
			$lookAts ($modCore + "_Master_Ctrl_StartAttachLctr");
			pointConstraint $lookAts ($modCore + "_Master_Ctrl_EndAttachLctr");
			$lookAtSize = `getAttr ($modCore + "_Master_Ctrl_EndAttachLctr.tx")`;
			scale -a ($lookAtSize * 2.5) ($lookAtSize * 1.25) $lookAtSize ($modCore + "_Master_CtrlGrp");
			
			//POSITION
			delete `parentConstraint $lookAts ($modCore + "_Master_CtrlGrp")`;
			delete ($modCore + "_Master_Ctrl_StartAttachLctr") ($modCore + "_Master_Ctrl_EndAttachLctr");
		}
	
		parentConstraint -mo ($modCore) ($modCore + "_Master_CtrlGrp");
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_Master_Ctrl");
		RRM_ParentOrient($modRigName, $modCore, $modAttachNode, $parentOrient); 
		
		
		//EYE CONTROLS
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		string $crntLookAt;
		$crntNum = 1;
		for ($crntLookAt in $lookAts)
		{
			string $nPd = "";
			if ($crntNum < 10)
			{
				$nPd = "0";
			}
			RRM_EyeControl;
			rename "RRM_EyeControl" ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			rotate -r 90 90 0 ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			group -n ($modCore + "_" + $nPd + $crntNum + "Grp1") ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			group -n ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Grp1");
			parent ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_ScaleGrp");
			delete `pointConstraint $crntLookAt ($modCore + "_" + $nPd + $crntNum + "Grp2")`;
			
			//GET END LOCATION OF EYE CONTROL
			$lookAtUpLoc = `xform -q -ws -t ($crntLookAt + "Shape.cv[3]")`;
			$lookAtAimLoc = `xform -q -ws -t ($crntLookAt + "_5Shape.cv[1]")`;
			spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "AimLctr");
			spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			move -a $lookAtAimLoc[0] $lookAtAimLoc[1] $lookAtAimLoc[2] ($modCore + "_" + $nPd + $crntNum + "AimLctr");
			move -a $lookAtUpLoc[0] $lookAtUpLoc[1] $lookAtUpLoc[2] ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "UpLctr")
			($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "Grp2")`;
			
			delete `pointConstraint ($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "Grp1")`;
			
			select -cl;
			joint -n ($modCore + "_" + $nPd + $crntNum + "Jnt");
			parent ($modCore + "_" + $nPd + $crntNum + "Jnt") ($modCore + "_ScaleGrp");		
			pointConstraint ($modCore + "_Master_Ctrl") ($modCore + "_" + $nPd + $crntNum + "Jnt");
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "Grp2")
			($modCore + "_" + $nPd + $crntNum + "_Ctrl") ($modCore + "_" + $nPd + $crntNum + "Jnt");
	
			//AIM EYE CONTROL AT JOINT
			//aimConstraint -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "Grp2")
			//($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			
			//SCALE EACH CONTROLLER
			if (`size $lookAts` == 1)
			{
				$lookAtSize = `getAttr "RRM_MAIN.scaleY"`;
				scale -a ($lookAtSize * .75) ($lookAtSize * .75) ($lookAtSize * .75) ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			}
			else
			{
				spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "EndLctr");
				parent ($modCore + "_" + $nPd + $crntNum + "EndLctr") ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				pointConstraint $lookAts[0] ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "UpLctr")
				$lookAts ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				pointConstraint $lookAts ($modCore + "_" + $nPd + $crntNum + "EndLctr");
				$lookAtSize = `getAttr ($modCore + "_" + $nPd + $crntNum + "EndLctr.tx")`;
				scale -a ($lookAtSize * .75) ($lookAtSize * .75) ($lookAtSize * .75) ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
				delete ($modCore + "_" + $nPd + $crntNum + "StartLctr") ($modCore + "_" + $nPd + $crntNum + "EndLctr");
			}
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_" + $nPd + $crntNum + "_Ctrl");
			
			
			//CREATE CONNECTOR
			curve -n ($modCore + "_" + $nPd + $crntNum + "Connector_Curve") -d 1 -p 0 0 0 -p 0 0 -1 -k 0 -k 1 ;
			rename `listRelatives -c ($modCore + "_" + $nPd + $crntNum + "Connector_Curve")` ($modCore + "_" + $nPd + $crntNum + "Connector_CurveShape");
			parent ($modCore + "_" + $nPd + $crntNum + "Connector_Curve") ($modCore + "Grp");
		
			select ($modCore + "_" + $nPd + $crntNum + "Connector_CurveShape.cv[0]");
			newCluster " -envelope 1";
			rename ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster1");
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "_Ctrl") ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster1");
			
			select ($modCore + "_" + $nPd + $crntNum + "Connector_CurveShape.cv[1]");
			newCluster " -envelope 1";
			rename ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster2");
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster2");
	
			parent ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster1")	($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster2") ($modCore + "Grp");
			setAttr ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster1.visibility") 0;
			setAttr ($modCore + "_" + $nPd + $crntNum + "Connector_Curve_Cluster2.visibility") 0;
			
			toggle -state on -template ($modCore + "_" + $nPd + $crntNum + "Connector_Curve");
			
			delete ($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			
			addAttr -ln "nonControl" -dt "string" ($modCore + "_" + $nPd + $crntNum + "Connector_Curve");
			setAttr -e -k 1 ($modCore + "_" + $nPd + $crntNum + "Connector_Curve.nonControl");
			setAttr -l 1 ($modCore + "_" + $nPd + $crntNum + "Connector_Curve.nonControl");

			$crntNum++;
		}
	
		//ADD CORE NAME AND LOCK CHANNELS
		$modControls = `ls ($modCore + "_*_Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName" -dt "string" $crntModControl;
			setAttr -e -k 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("" + $prfx + $core);
			setAttr -e-l 1 ($crntModControl + ".modCoreName");
			
			//ADD MODULE TYPE
			addAttr -ln "moduleType" -dt "string" ($crntModControl);
			setAttr -e -k 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "lookAt";
			setAttr -l true ($crntModControl + ".moduleType");

			setAttr -l 1 -k 0 ($crntModControl + ".rx");
			setAttr -l 1 -k 0 ($crntModControl + ".ry");
			setAttr -l 1 -k 0 ($crntModControl + ".rz");
		}
		
		//SETUP FOR RIGHT SIDE
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	//ADD MASTER CONTROL FOR ALL EYES
	
	//CONTROL
	circle -n ($modRigName + "" + $core + "_LookAt_Ctrl1") -nr 0 1 0 -sw 75 -r 1 -s 3 -ch 0;
	rotate -r -os 0 7.5 0 ($modRigName + "" + $core + "_LookAt_Ctrl1");
	makeIdentity -apply true -r 1 ($modRigName + "" + $core + "_LookAt_Ctrl1");
	
	curve -n ($modRigName + "" + $core + "_LookAt_Ctrl") -d 1 -p -0.130526 0 -0.991445 -p -0.130526 0 -0.130526 -p -0.991445 0 -0.130526 -k 0 -k 1 -k 2 ;
	rename `listRelatives -c ($modRigName + "" + $core + "_LookAt_Ctrl")` ($modRigName + "" + $core + "_LookAt_CtrlShape");
	parent -r -s ($modRigName + "" + $core + "_LookAt_Ctrl1Shape") ($modRigName + "" + $core + "_LookAt_Ctrl");
	delete ($modRigName + "" + $core + "_LookAt_Ctrl1");
	select ($modRigName + "" + $core + "_LookAt_Ctrl");
	duplicate -rr; rotate -r 0 90 0; for ($i=1; $i<3; ++$i) duplicate -rr -st; select ($modRigName + "" + $core + "_LookAt_Ctrl2") ($modRigName + "" + $core + "_LookAt_Ctrl22") ($modRigName + "" + $core + "_LookAt_Ctrl222");
	makeIdentity -apply true -r 1 ($modRigName + "" + $core + "_LookAt_Ctrl2") ($modRigName + "" + $core + "_LookAt_Ctrl22") ($modRigName + "" + $core + "_LookAt_Ctrl222");
	select -hi ($modRigName + "" + $core + "_LookAt_Ctrl2") ($modRigName + "" + $core + "_LookAt_Ctrl22") ($modRigName + "" + $core + "_LookAt_Ctrl222");
	select -d ($modRigName + "" + $core + "_LookAt_Ctrl2") ($modRigName + "" + $core + "_LookAt_Ctrl22") ($modRigName + "" + $core + "_LookAt_Ctrl222");
	select -add ($modRigName + "" + $core + "_LookAt_Ctrl");
	parent -r -s;
	delete ($modRigName + "" + $core + "_LookAt_Ctrl2") ($modRigName + "" + $core + "_LookAt_Ctrl22") ($modRigName + "" + $core + "_LookAt_Ctrl222");
	group -n ($modRigName + "" + $core + "_LookAt_CtrlGrp") ($modRigName + "" + $core + "_LookAt_Ctrl");
	parent ($modRigName + "" + $core + "_LookAt_CtrlGrp") ($modRigName + "MAIN_Inner_Ctrl");
	rotate -r 90 0 0 ($modRigName + "" + $core + "_LookAt_CtrlGrp") ;
	scale -r ($lookAtSize/.75) ($lookAtSize/.75) ($lookAtSize/.75) ($modRigName + "" + $core + "_LookAt_CtrlGrp");
	makeIdentity -apply true -r 1 -s 1 ($modRigName + "" + $core + "_LookAt_CtrlGrp") ;
	
	//MOVE INTO POSITION
	select ($modRigName + "*" + $core + "_??_Ctrl");
	select -d ($modRigName + "" + $core + "_LookAt_Ctrl");
	$eyeControls = `ls -sl`;
	$eyeControlsGrp = `listRelatives -p $eyeControls`;
	
	delete `pointConstraint $eyeControls ($modRigName + "" + $core + "_LookAt_CtrlGrp")`;
	makeIdentity -apply true -t 1 ($modRigName + "" + $core + "_LookAt_CtrlGrp");
	
	//AIM CONSTRAINT
	$eyeControlsGrp2 = `ls ($modRigName + "*" + $core + "_??Grp2")`;
	
	//aimConstraint -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
	//$eyeControlsGrp2 ($modRigName + "" + $core + "_LookAt_Ctrl");
	
	setAttr -l 1 -k 0 ($modRigName + "" + $core + "_LookAt_Ctrl.rx");
	setAttr -l 1 -k 0 ($modRigName + "" + $core + "_LookAt_Ctrl.ry");
	setAttr -l 1 -k 0 ($modRigName + "" + $core + "_LookAt_Ctrl.rz");
	setAttr -l 1 -k 0 ($modRigName + "" + $core + "_LookAt_Ctrl.v");	
	
	string $each;
	for ($each in $eyeControlsGrp)
	{
		parentConstraint -mo ($modRigName + "" + $core + "_LookAt_Ctrl") $each;
	}
	
	//ADD ATTRIBUTE FOR PARENT ORIENT
	addAttr -ln "localSpace" -at double -min 0 -max 1 -dv 1 ($modRigName + "" + $core + "_LookAt_Ctrl");
	setAttr -e -k 1 ($modRigName + "" + $core + "_LookAt_Ctrl.localSpace");
	
	if ($modAttachNode != "ROOT")
	{
		parentConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "" + $core + "_LookAt_CtrlGrp");
		connectAttr -f ($modRigName + "" + $core + "_LookAt_Ctrl.localSpace") ($modRigName + "" + $core + "_LookAt_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW0");
	}
	else
	{
		parentConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "" + $core + "_LookAt_CtrlGrp");
		connectAttr -f ($modRigName + "" + $core + "_LookAt_Ctrl.localSpace") ($modRigName + "" + $core + "_LookAt_CtrlGrp_parentConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0");
	}

	shadingNode -asUtility reverse -n ($modRigName + "" + $core + "_LookAt_CtrlGrp_Rev");
	connectAttr -f ($modRigName + "" + $core + "_LookAt_Ctrl.localSpace") ($modRigName + "" + $core + "_LookAt_CtrlGrp_Rev.inputX");
	connectAttr -f ($modRigName + "" + $core + "_LookAt_CtrlGrp_Rev.outputX") ($modRigName + "" + $core + "_LookAt_CtrlGrp_parentConstraint1." + $modRigName + "MAIN_Inner_CtrlW1");

	
	addAttr -ln "modCoreName" -dt "string" ($modRigName + "" + $core + "_LookAt_Ctrl");
	setAttr -e -k 1 ($modRigName + "" + $core + "_LookAt_Ctrl.modCoreName");
	setAttr -type "string" ($modRigName + "" + $core + "_LookAt_Ctrl.modCoreName") $modCore;
	setAttr -e-l 1 ($modRigName + "" + $core + "_LookAt_Ctrl.modCoreName");
	
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Parent")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Parent");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Parent")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Parent");}
	else if (`objExists ("RRM_" + $modRigName + "Parent")`)
		{select ("RRM_" + $modRigName + "Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE AUXILIARY MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRigAuxiliary(string $modRigName, string $rigGrp, string $moduleName, string $topNode, string $lPrfx, string $rPrfx, int $ea)
{
	$core = `getAttr ($topNode + ".core")`;
	$mirrorInt = 1;
	string $modAttachNode;
	string $modCore;
	
	string $prfx = "";
	string $oppPrfx = "";
	
	float $behavior = 1;
	//float $behaviorMultiplier = 1;

	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = $lPrfx;
		$oppPrfx = $rPrfx;
  
		$mirrorInt = 0;
		if (`objExists ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $rPrfx + $core + "_Parent.mirrorType")` == 0)
			{	
				$behavior = 0;
			}
		}
	}
	$crntSide = "left";
	$oppSide = "right";


	while ($mirrorInt <= 1)
	{
		if ($crntSide == "right" && `objExists ("RRM_" + $prfx + $core + "_Aux.mirrorType")`)
		{
			if (`getAttr ("RRM_" + $prfx + $core + "_Aux.mirrorType")` == 0)
			{	
				$behaviorMultiplier = -1;
				$behavior = 0;
			}
		}

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Aux.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core + "_Aux");
		$modOppCore = ($modRigName + "" + $oppPrfx + $core + "_Aux");
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		group -em -n ($modCore);
	
		if ($modAttachNode != "ROOT")
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			delete `parentConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore)`;
		
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			delete `orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_OffsetLctr")`;
			parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modCore + "_OffsetLctr");
			delete `parentConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore)`;
		
			pointConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "ROOT_Ctrl") ($modRigName + "ROOTSecondary_Ctrl") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modRigName + "MAIN_Inner_Ctrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
		
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "auxiliary";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ($prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName" -dt "string" ($modCore + "Grp");
		setAttr -e -k 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ($oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side" -dt "string" ($modCore + "Grp");
			setAttr -e -k 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");

			addAttr -ln "mirror" -at bool ($modCore + "Grp");
			setAttr -e -k 0 ($modCore + "Grp.mirror");
			setAttr ($modCore + "Grp.mirror") $behavior;
			setAttr -l 1 ($modCore + "Grp.mirror");
		}

		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modRigName + "ROOT_Ctrl") ($modCore + "_OffsetLctr") ($modCore + "_ScaleGrp");
		}
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modRigName + "MAIN_Ctrl.scale") ($modCore + "_ScaleGrp.scale");

		//CONTROL
		//GET SCALE OF THE PROXY
		
		//LOCATOR FOR CONSTRAINTS
		spaceLocator -n ($modCore + "_CtrlGrp2Lctr");
		parent ($modCore + "_CtrlGrp2Lctr") ($modCore + "Grp");

		if ($modAttachNode != "ROOT")
		{
			delete `parentConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_CtrlGrp2Lctr")`;
			delete `scaleConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_CtrlGrp2Lctr")`;
		}
		else
		{
			delete `parentConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_CtrlGrp2Lctr")`;
			delete `scaleConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_CtrlGrp2Lctr")`;			
		}

		circle -n ($modCore + "_Ctrl") -nr 0 1 0 -r .375 -ch 0;
		circle -n ($modCore + "_Ctrl2") -nr 1 0 0 -r .375 -ch 0;
		circle -n ($modCore + "_Ctrl3") -nr 0 0 1 -r .375 -ch 0;
		parent -r -s ($modCore + "_Ctrl2Shape") ($modCore + "_Ctrl3Shape") ($modCore + "_Ctrl");
		delete ($modCore + "_Ctrl2") ($modCore + "_Ctrl3");
		delete `scaleConstraint ("RRM_" + $prfx + $core + "_Aux") ($modCore + "_Ctrl")`;
		makeIdentity -apply 1 ($modCore + "_Ctrl");
		group -n ($modCore + "_CtrlGrp") ($modCore + "_Ctrl");
		group -n ($modCore + "_CtrlGrp2") ($modCore + "_CtrlGrp");
		parent ($modCore + "_CtrlGrp2") ($modCore);
		
		setAttr ($modCore + "_CtrlGrp2Lctr.v") 0;
		setAttr -l 1 -k 0 ($modCore + "_CtrlGrp2Lctr.v");
		setAttr -l 1 -k 0 ($modCore + "_Ctrl.v");

		
		if ($modAttachNode != "ROOT")
		{
			delete `parentConstraint ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_CtrlGrp2")`;
		}
		else
		{
			delete `parentConstraint ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_CtrlGrp2")`;
		}
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Aux") ($modCore + "_CtrlGrp")`;
		if ($crntSide == "right" && $behavior == 0)
		{
			//$rz = `getAttr ($modCore + "_CtrlGrp.rz")`;
			//rotate -r -os 180 0 ($rz * -1) ($modCore + "_CtrlGrp");
			rotate -r -os 180 0 0 ($modCore + "_CtrlGrp");
		}

		if ($modAttachNode != "ROOT")
		{
			parentConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_CtrlGrp2Lctr") ($modCore + "_CtrlGrp2");
			orientConstraint -mo ($modRigName + "" + $modAttachNode + "Jnt") ($modCore + "_CtrlGrp2Lctr") ($modCore + "_CtrlGrp");

			addAttr -ln "followParentOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_Ctrl");
			setAttr -e -k 1 ($modCore + "_Ctrl.followParentOrient");
			addAttr -ln "followParentPosition" -at double -min 0 -max 1 -dv 1 ($modCore + "_Ctrl");
			setAttr -e -k 1 ($modCore + "_Ctrl.followParentPosition");
			connectAttr -f ($modCore + "_Ctrl.followParentOrient") ($modCore + "_CtrlGrp_orientConstraint1." + $modRigName + "" + $modAttachNode + "JntW0");
			setAttr ($modCore + "_Ctrl.followParentOrient") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentOrient") ($modCore + "_CtrlGrp_orientConstraint1." + $modCore + "_CtrlGrp2LctrW1");
			setAttr ($modCore + "_Ctrl.followParentOrient") 0;
			setAttr ($modCore + "_Ctrl.followParentOrient") 1;
			setAttr ($modCore + "_CtrlGrp_orientConstraint1." + $modCore + "_CtrlGrp2LctrW1") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentOrient") ($modCore + "_CtrlGrp_orientConstraint1." + $modCore + "_CtrlGrp2LctrW1");

			connectAttr -f ($modCore + "_Ctrl.followParentPosition") ($modCore + "_CtrlGrp2_parentConstraint1." + $modRigName + "" + $modAttachNode + "JntW0");
			setAttr ($modCore + "_Ctrl.followParentPosition") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentPosition") ($modCore + "_CtrlGrp2_parentConstraint1." + $modCore + "_CtrlGrp2LctrW1");
			setAttr ($modCore + "_Ctrl.followParentPosition") 0;
			setAttr ($modCore + "_Ctrl.followParentPosition") 1;
			setAttr ($modCore + "_CtrlGrp2_parentConstraint1." + $modCore + "_CtrlGrp2LctrW1") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentPosition") ($modCore + "_CtrlGrp2_parentConstraint1." + $modCore + "_CtrlGrp2LctrW1");
		}
		else
		{
			parentConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_CtrlGrp2Lctr") ($modCore + "_CtrlGrp2");
			orientConstraint -mo ($modRigName + "" + $modAttachNode + "Secondary_Ctrl") ($modCore + "_CtrlGrp2Lctr") ($modCore + "_CtrlGrp");

			addAttr -ln "followParentOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_Ctrl");
			setAttr -e -k 1 ($modCore + "_Ctrl.followParentOrient");
			addAttr -ln "followParentPosition" -at double -min 0 -max 1 -dv 1 ($modCore + "_Ctrl");
			setAttr -e -k 1 ($modCore + "_Ctrl.followParentPosition");
			connectAttr -f ($modCore + "_Ctrl.followParentOrient") ($modCore + "_CtrlGrp_orientConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0");
			setAttr ($modCore + "_Ctrl.followParentOrient") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentOrient") ($modCore + "_CtrlGrp_orientConstraint1." + $modCore + "_CtrlGrp2LctrW1");
			setAttr ($modCore + "_Ctrl.followParentOrient") 0;
			setAttr ($modCore + "_Ctrl.followParentOrient") 1;
			setAttr ($modCore + "_CtrlGrp_orientConstraint1." + $modCore + "_CtrlGrp2LctrW1") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentOrient") ($modCore + "_CtrlGrp_orientConstraint1." + $modCore + "_CtrlGrp2LctrW1");

			connectAttr -f ($modCore + "_Ctrl.followParentPosition") ($modCore + "_CtrlGrp2_parentConstraint1." + $modRigName + "" + $modAttachNode + "Secondary_CtrlW0");
			setAttr ($modCore + "_Ctrl.followParentPosition") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentPosition") ($modCore + "_CtrlGrp2_parentConstraint1." + $modCore + "_CtrlGrp2LctrW1");
			setAttr ($modCore + "_Ctrl.followParentPosition") 0;
			setAttr ($modCore + "_Ctrl.followParentPosition") 1;
			setAttr ($modCore + "_CtrlGrp2_parentConstraint1." + $modCore + "_CtrlGrp2LctrW1") 0;
			setDrivenKeyframe -currentDriver ($modCore + "_Ctrl.followParentPosition") ($modCore + "_CtrlGrp2_parentConstraint1." + $modCore + "_CtrlGrp2LctrW1");
		}


		keyTangent -itt spline -ott spline
		($modCore + "_CtrlGrp_orientConstraint1_" + $modCore + "_CtrlGrp2LctrW1")
		($modCore + "_CtrlGrp2_parentConstraint1_" + $modCore + "_CtrlGrp2LctrW1");
		

		//ADD MODULE CORE NAME
		addAttr -ln "modCoreName" -dt "string" ($modCore + "_Ctrl");
		setAttr -e -k 1 ($modCore + "_Ctrl.modCoreName");
		setAttr -type "string" ($modCore + "_Ctrl.modCoreName") ("" + $prfx + $core);
		setAttr -e-l 1 ($modCore + "_Ctrl.modCoreName");
		
		//ADD MODULE TYPE
		addAttr -ln "moduleType" -dt "string" (($modCore + "_Ctrl"));
		setAttr -e -k 1 ($modCore + "_Ctrl.moduleType");
		setAttr -type "string" ($modCore + "_Ctrl.moduleType") "auxiliary";
		setAttr -l true ($modCore + "_Ctrl.moduleType");
				
		//JOINT
		joint -n ($modCore + "Jnt");
		parent ($modCore + "Jnt") ($modCore + "_ScaleGrp");
		parentConstraint ($modCore + "_Ctrl") ($modCore + "Jnt");
		connectAttr ($modCore + "_Ctrl.scale") ($modCore + "Jnt.scale");
		
		//SETUP FOR RIGHT SIDE
		$prfx = $rPrfx;
		$oppPrfx = $lPrfx;
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	if (`objExists ("RRM_" + $lPrfx + $modRigName + "Aux")`)
		{select ("RRM_" + $lPrfx + $modRigName + "Aux");}
	if (`objExists ("RRM_" + $rPrfx + $modRigName + "Aux")`)
		{select -add ("RRM_" + $rPrfx + $modRigName + "Aux");}
	else if (`objExists ("RRM_" + $modRigName + "Aux")`)
		{select ("RRM_" + $modRigName + "Aux");}
}
	


//////////////////////////////////////SINGLE HIERARCHY////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE ROOT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigRootSH(string $modRigName, string $rigGrp, int $freeze, int $ea)
{
	//CREATE LAYERS
	//LAYER
	createDisplayLayer -n ($modRigName + "SHJointsLayer") -number 1 -empty;
	select -cl;	
	joint -n ($modRigName + "ROOTSHJnt");
	delete `parentConstraint ($modRigName + "ROOTJnt") ($modRigName + "ROOTSHJnt")`;
	if ($ea == 1)
	{
		rotate -r -os 180 0 0 ($modRigName + "ROOTSHJnt");
	}
	makeIdentity -apply 1 -r $freeze ($modRigName + "ROOTSHJnt");
	parentConstraint -mo ($modRigName + "ROOTJnt") ($modRigName + "ROOTSHJnt");
	group -n ($modRigName + "SHJntGrp") ($modRigName + "ROOTSHJnt"); xform -os -piv 0 0 0;
	parent ($modRigName + "SHJntGrp") $rigGrp;
	connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modRigName + "SHJntGrp.scaleX");
	connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modRigName + "SHJntGrp.scaleY");
	connectAttr -f ($modRigName + "MAIN_Ctrl.scaleY") ($modRigName + "SHJntGrp.scaleZ");
	
	editDisplayLayerMembers -noRecurse ($modRigName + "SHJointsLayer") `ls ($modRigName + "SHJntGrp")`;
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////GENERATE ROOT AND MAIN SH MODULE/////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigRootMainSH(string $modRigName, string $rigGrp, int $freeze, int $ea)
{
	//CREATE LAYERS
	//LAYER
	createDisplayLayer -n ($modRigName + "SHJointsLayer") -number 1 -empty;

	select -cl;	
	joint -n ($modRigName + "MAINSHJnt");
	delete `parentConstraint ($modRigName + "MAIN_Ctrl") ($modRigName + "MAINSHJnt")`;
	makeIdentity -apply 1 -r $freeze ($modRigName + "MAINSHJnt");
	parentConstraint -mo ($modRigName + "MAIN_Inner_Ctrl") ($modRigName + "MAINSHJnt");
	group -n ($modRigName + "SHJntGrp") ($modRigName + "MAINSHJnt"); xform -os -piv 0 0 0;
	parent ($modRigName + "SHJntGrp") $rigGrp;
	select -cl;	
	joint -n ($modRigName + "ROOTSHJnt");
	addAttr -ln "hips" -at bool ($modRigName + "ROOTSHJnt");
	setAttr -e -k 1 ($modRigName + "ROOTSHJnt.hips");

	parent ($modRigName + "ROOTSHJnt") ($modRigName + "MAINSHJnt");
	setAttr (($modRigName + "ROOTSHJnt.jointOrient"), 0, 0, 0);
	delete `parentConstraint ($modRigName + "ROOTJnt") ($modRigName + "ROOTSHJnt")`;
	if ($ea == 1)
	{
		rotate -r -os 180 0 0 ($modRigName + "ROOTSHJnt");
	}

	makeIdentity -apply 1 -r $freeze ($modRigName + "ROOTSHJnt");
	parentConstraint -mo ($modRigName + "ROOTJnt") ($modRigName + "ROOTSHJnt");
	
	editDisplayLayerMembers -noRecurse ($modRigName + "SHJointsLayer") `ls ($modRigName + "SHJntGrp")`;
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////GENERATE SPLINE SH MODULE/////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigSplineSH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$mirror = 0;
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$mirror = 1;
		$prfx = `getAttr RRM_MAIN.lPrfx`;
	}
	
	$mirrorInt = 0;
	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + $prfx + $core);

		//GENERATE JOINTS
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		int $crntNum = 0;
		$numPadding = "_0";
		$prevPadding = "_0";
		float $splineLoc[];
		for ($crntProxy in $splineProxies)
		{
			$crntNum++;
			if ($crntNum >= 10)
			{$numPadding = "_";}
				
			select -cl;
			joint -n ($modCore + $numPadding + $crntNum + "SHJnt");
			if ($crntNum == 1)
			{
				parent ($modCore + $numPadding + $crntNum + "SHJnt") ($modRigName + "" + $modAttachNode + "SHJnt");
				setAttr (($modCore + $numPadding + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
				addAttr -ln "splineStart" -at bool ($modCore + $numPadding + $crntNum + "SHJnt");
				setAttr -e -k 1 ($modCore + $numPadding + $crntNum + "SHJnt.splineStart");
			}
			else
			{
				int $previousNum = ($crntNum - 1);
				if ($previousNum >=10)
				{$prevPadding = "_";}
				parent ($modCore + $numPadding + $crntNum + "SHJnt") ($modCore + $prevPadding + $previousNum + "SHJnt");
				setAttr (($modCore + $numPadding + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
			}
			delete `parentConstraint ($modCore + $numPadding + $crntNum + "Jnt") ($modCore + $numPadding + $crntNum + "SHJnt")`;
			if ($ea == 1)
			{
				rotate -r -os 180 0 0 ($modCore + $numPadding + $crntNum + "SHJnt");
			}
			makeIdentity -apply 1 -r $freeze ($modCore + $numPadding + $crntNum + "SHJnt");
			parentConstraint -mo ($modCore + $numPadding + $crntNum + "Jnt") ($modCore + $numPadding + $crntNum + "SHJnt");
		}
		
		select -cl;
		joint -n ($modCore + "_TopSHJnt");
		addAttr -ln "splineEnd" -at bool ($modCore + "_TopSHJnt");
		setAttr -e -k 1 ($modCore + "_TopSHJnt.splineEnd");

		parent ($modCore + "_TopSHJnt") ($modCore + $numPadding + $crntNum + "SHJnt");
		setAttr (($modCore + "_TopSHJnt.jointOrient"), 0, 0, 0);
		delete `parentConstraint ($modCore + "_TopJnt") ($modCore + "_TopSHJnt")`;
		if ($ea == 1)
		{
			rotate -r -os 180 0 0 ($modCore + "_TopSHJnt");
		}
		makeIdentity -apply 1 -r $freeze ($modCore + "_TopSHJnt");
		parentConstraint -mo ($modCore + "_TopJnt") ($modCore + "_TopSHJnt");
		
		if (`objExists ("RRM_" + $prfx + $core + "_Hip")`)
		{
			select -cl;
			joint -n ($modCore + "_HipSHJnt");
			
			parent ($modCore + "_HipSHJnt") ($modRigName + "" + $modAttachNode + "SHJnt");
			setAttr (($modCore + "_HipSHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_HipJnt") ($modCore + "_HipSHJnt")`;
			if ($ea == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_HipSHJnt");
			}
			makeIdentity -apply 1 -r $freeze ($modCore + "_HipSHJnt");
			parentConstraint -mo ($modCore + "_HipJnt") ($modCore + "_HipSHJnt");
		}

		$prfx = `getAttr RRM_MAIN.rPrfx`;
		$mirrorInt++;
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigArmSH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$core = `getAttr ($topNode + ".core")`;
	$mulitplier = 1;
	$mirror = 0;

	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$mirror = 1;
		$prfx = `getAttr RRM_MAIN.lPrfx`;
	}
	
	$mirrorInt = 0;
	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
				
		//GENERATE JOINTS
		select -cl;
		joint -n ($modCore + "_ClavicleSHJnt");
		addAttr -ln "shoulder" -at bool ($modCore + "_ClavicleSHJnt");
		setAttr -e -k 1 ($modCore + "_ClavicleSHJnt.shoulder");
		addAttr -ln "arm" -at bool ($modCore + "_ClavicleSHJnt");
		setAttr -e -k 1 ($modCore + "_ClavicleSHJnt.arm");

		parent ($modCore + "_ClavicleSHJnt") ($modRigName + "" + $modAttachNode + "SHJnt");
		setAttr (($modCore + "_ClavicleSHJnt.jointOrient"), 0, 0, 0); 
		delete `parentConstraint ($modCore + "_ClavicleJnt") ($modCore + "_ClavicleSHJnt")`;
		if ($ea == 1)
		{
			if ($mirrorInt == 0)
			{
				rotate -r -os 90 0 0 ($modCore + "_ClavicleSHJnt");
			}
			else
			{
				rotate -r -os -90 0 180 ($modCore + "_ClavicleSHJnt");
			}

		}
		makeIdentity -apply 1 -r $freeze ($modCore + "_ClavicleSHJnt");
		parentConstraint -mo ($modCore + "_ClavicleJnt") ($modCore + "_ClavicleSHJnt");
		
		$parentJnt = ($modCore + "_ClavicleSHJnt");
		
		//SHOULDER JOINTS
		if ($ea == 0)
		{
			if (!`objExists ($modCore + "_Shoulder_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + "_ShoulderSHJnt");
				addAttr -ln "upperArm" -at bool ($modCore + "_ShoulderSHJnt");
				setAttr -e -k 1 ($modCore + "_ShoulderSHJnt.upperArm");
				addAttr -ln "arm" -at bool ($modCore + "_ShoulderSHJnt");
				setAttr -e -k 1 ($modCore + "_ShoulderSHJnt.arm");
			
				parent ($modCore + "_ShoulderSHJnt") $parentJnt;
				setAttr (($modCore + "_ShoulderSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_ShoulderSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_ShoulderSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_ShoulderSHJnt");
				parentConstraint -mo ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderSHJnt");
				$parentJnt = ($modCore + "_ShoulderSHJnt");
			}
			else
			{
				select -cl;
				joint -n ($modCore + "_ShoulderSHJnt");
				addAttr -ln "upperArm" -at bool ($modCore + "_ShoulderSHJnt");
				setAttr -e -k 1 ($modCore + "_ShoulderSHJnt.upperArm");
				addAttr -ln "arm" -at bool ($modCore + "_ShoulderSHJnt");
				setAttr -e -k 1 ($modCore + "_ShoulderSHJnt.arm");

				parent ($modCore + "_ShoulderSHJnt") $parentJnt;
				setAttr (($modCore + "_ShoulderSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Shoulder_CurveJnt") ($modCore + "_ShoulderSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_ShoulderSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_ShoulderSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_ShoulderSHJnt");
				parentConstraint -mo ($modCore + "_Shoulder_CurveJnt") ($modCore + "_ShoulderSHJnt");
				$parentJnt = ($modCore + "_ShoulderSHJnt");
			}
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_ShoulderSHJnt");
			addAttr -ln "upperArm" -at bool ($modCore + "_ShoulderSHJnt");
			setAttr -e -k 1 ($modCore + "_ShoulderSHJnt.upperArm");
			addAttr -ln "arm" -at bool ($modCore + "_ShoulderSHJnt");
			setAttr -e -k 1 ($modCore + "_ShoulderSHJnt.arm");
		
			parent ($modCore + "_ShoulderSHJnt") $parentJnt;
			setAttr (($modCore + "_ShoulderSHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderSHJnt")`;
			if ($ea == 1)
			{
				if ($mirrorInt == 0)
				{
					rotate -r -os 90 0 0 ($modCore + "_ShoulderSHJnt");
				}
				else
				{
					rotate -r -os -90 0 180 ($modCore + "_ShoulderSHJnt");
				}
			}
			makeIdentity -apply 1 -r $freeze ($modCore + "_ShoulderSHJnt");
			parentConstraint -mo ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderSHJnt");
			$parentJnt = ($modCore + "_ShoulderSHJnt");

			if (`objExists ($modCore + "_Shoulder_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + "_Upper_CurveSHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Upper_CurveSHJnt");
				setAttr -e -k 1 ($modCore + "_Upper_CurveSHJnt.arm");

				parent ($modCore + "_Upper_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Upper_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Shoulder_CurveJnt") ($modCore + "_Upper_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_Upper_CurveSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_Upper_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Upper_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Shoulder_CurveJnt") ($modCore + "_Upper_CurveSHJnt");
			}
		}

		//CHECK FOR TOON ARMS
		int $crntNum = 1;
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$upperJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
			for ($crntUpper in $upperJnt)
			{
				if (!`objExists ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`)
				{
					select -cl;
					joint -n ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					addAttr -ln "arm" -at bool ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					setAttr -e -k 1 ($modCore + "_Upper_Curve" + $crntNum + "SHJnt.arm");
					parent ($modCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
					setAttr (($modCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
					delete `pointConstraint ($modCore + "_Upper_Curve" + $crntNum + "Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
					//if ($ea == 1)
					//{
					//	rotate -r -os 90 0 0 ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					//}
					//makeIdentity -apply 1 -r $freeze ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					pointConstraint -mo ($modCore + "_Upper_Curve" + $crntNum + "Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					orientConstraint -mo ($modCore + "_Upper_Curve" + $crntNum + "Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					
					$crntNum++;
				}
			}
		}

		if ($ea == 1)
		{
			select -cl;
			joint -n ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
			addAttr -ln "arm" -at bool ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
			setAttr -e -k 1 ($modCore + "_Upper_Curve" + $crntNum + "SHJnt.arm");
		
			parent ($modCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
			setAttr (($modCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
			if (`objExists ($modCore + "_ElbowJnt")`)
			{
				delete `pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
			}
			else if (`objExists ($modCore + "_Elbow1Jnt")`)
			{
				delete `pointConstraint ($modCore + "_Elbow1Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
			}
		}

		if (`objExists ($modCore + "_ElbowJnt")`)
		{
			select -cl;
			if (!`objExists ($modCore + "_Elbow_CurveJnt")` || $ea == 1)
			{
				joint -n ($modCore + "_ElbowSHJnt");
				addAttr -ln "forearm" -at bool ($modCore + "_ElbowSHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_ElbowSHJnt");
		
				parent ($modCore + "_ElbowSHJnt") $parentJnt;
				setAttr (($modCore + "_ElbowSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_ElbowJnt") ($modCore + "_ElbowSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_ElbowSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_ElbowSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_ElbowSHJnt");
				parentConstraint -mo ($modCore + "_ElbowJnt") ($modCore + "_ElbowSHJnt");
				$parentJnt = ($modCore + "_ElbowSHJnt");
			}
			if (`objExists ($modCore + "_Elbow_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + "_Elbow_CurveSHJnt");
				addAttr -ln "forearm" -at bool ($modCore + "_Elbow_CurveSHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Elbow_CurveSHJnt");
		
				parent ($modCore + "_Elbow_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Elbow_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Elbow_CurveJnt") ($modCore + "_Elbow_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_Elbow_CurveSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_Elbow_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Elbow_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Elbow_CurveJnt") ($modCore + "_Elbow_CurveSHJnt");
				if ($ea == 0)
				{
					$parentJnt = ($modCore + "_Elbow_CurveSHJnt");
				}
			}
		}
		else
		{
			select -cl;
			if (!`objExists ($modCore + "_Elbow1_CurveJnt")`)
			{
				joint -n ($modCore + "_Elbow1SHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Elbow1SHJnt");
				setAttr -e -k 1 ($modCore + "_Elbow1SHJnt.arm");
		
				parent ($modCore + "_Elbow1SHJnt") $parentJnt;
				setAttr (($modCore + "_Elbow1SHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Elbow1Jnt") ($modCore + "_Elbow1SHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_Elbow1SHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_Elbow1SHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Elbow1SHJnt");
				parentConstraint -mo ($modCore + "_Elbow1Jnt") ($modCore + "_Elbow1SHJnt");
				$parentJnt = ($modCore + "_Elbow1SHJnt");
			}
			else
			{
				select -cl;
				joint -n ($modCore + "_Elbow1_CurveSHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Elbow1_CurveSHJnt");
				addAttr -ln "elbow" -at bool ($modCore + "_Elbow1_CurveSHJnt");
		
				parent ($modCore + "_Elbow1_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Elbow1_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Elbow1_CurveJnt") ($modCore + "_Elbow1_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_Elbow1_CurveSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_Elbow1_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Elbow1_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Elbow1_CurveJnt") ($modCore + "_Elbow1_CurveSHJnt");
				$parentJnt = ($modCore + "_Elbow1_CurveSHJnt");
			}

			if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
			{
				$middleCurveJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
				int $crntNum = 1;
				for ($crntMiddleCurve in $middleCurveJnt)
				{
					select -cl;
					joint -n ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					addAttr -ln "arm" -at bool ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					setAttr -e -k 1 ($modCore + "_Middle_Curve" + $crntNum + "SHJnt.arm");
					
					parent ($modCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
					setAttr (($modCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
					delete `pointConstraint ($modCore + "_Middle_Curve" + $crntNum + "Jnt") ($modCore + "_Middle_Curve" + $crntNum + "SHJnt")`;
					//if ($ea == 1)
					//{
					//	rotate -r -os 90 0 0 ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					//}
					//makeIdentity -apply 1 -r $freeze ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					pointConstraint -mo ($modCore + "_Middle_Curve" + $crntNum + "Jnt") ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					orientConstraint -mo ($modCore + "_Middle_Curve" + $crntNum + "Jnt") ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					
					$crntNum++;
				}
			}
			
			select -cl;
			if (!`objExists ($modCore + "_Elbow2_CurveJnt")`)
			{
				joint -n ($modCore + "_Elbow2SHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Elbow2SHJnt");
				setAttr -e -k 1 ($modCore + "_Elbow2SHJnt.arm");
		
				parent ($modCore + "_Elbow2SHJnt") $parentJnt;
				setAttr (($modCore + "_Elbow2SHJnt.jointOrient"), 0, 0, 0);
				makeIdentity -apply 1 -r $freeze ($modCore + "_Elbow2SHJnt");
				delete `parentConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_Elbow2SHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_Elbow2SHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_Elbow2SHJnt");
					}
				}
				parentConstraint -mo ($modCore + "_Elbow2Jnt") ($modCore + "_Elbow2SHJnt");
				$parentJnt = ($modCore + "_Elbow2SHJnt");
			}
			else
			{
				joint -n ($modCore + "_Elbow2_CurveSHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Elbow2_CurveSHJnt");
				setAttr -e -k 1 ($modCore + "_Elbow2_CurveSHJnt.arm");
		
				parent ($modCore + "_Elbow2_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Elbow2_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Elbow2_CurveJnt") ($modCore + "_Elbow2_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_Elbow2_CurveSHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_Elbow2_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Elbow2_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Elbow2_CurveJnt") ($modCore + "_Elbow2_CurveSHJnt");
				$parentJnt = ($modCore + "_Elbow2_CurveSHJnt");
			}
		}

		//ADD ELBOW OUT JOINT
		if ($ea == 1 && `objExists ($modCore + "_Upper_Curve3SHJnt")`)
		{

			//CONSTRAIN UPPER END JOINT
			makeIdentity -apply 1 -r $freeze ($modCore + "_Upper_Curve3SHJnt");
			if (`objExists ($modCore + "_Elbow_CurveJnt")`)
			{
				pointConstraint ($modCore + "_Elbow_CurveJnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_Elbow_CurveSHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}
			else if (`objExists ($modCore + "_Elbow1_CurveJnt")`)
			{
				pointConstraint ($modCore + "_Elbow1_CurveJnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_Elbow1_CurveSHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}
			else if (`objExists ($modCore + "_ElbowJnt")`)
			{
				pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_ElbowSHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}
			else if (`objExists ($modCore + "_Elbow1Jnt")`)
			{
				pointConstraint ($modCore + "_Elbow1Jnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_Elbow1Jnt") ($modCore + "_Upper_Curve3SHJnt");
			}

			select -cl;
			joint -n ($modCore + "_Elbow_OutSHJnt");
			addAttr -ln "elbowOut" -at bool ($modCore + "_Elbow_OutSHJnt");
			setAttr -e -k 1 ($modCore + "_Elbow_OutSHJnt.elbowOut");
			float $elbowOffset;
			if (`objExists ($modCore + "_ElbowJnt")`)
			{
				parent ($modCore + "_Elbow_OutSHJnt") ($modCore + "_ElbowSHJnt");
				$elbowOffset = `getAttr ($modCore + "_ElbowSHJnt.tx")`;
			}
			else
			{
				parent ($modCore + "_Elbow_OutSHJnt") ($modCore + "_Elbow1SHJnt");
				$elbowOffset = `getAttr ($modCore + "_Elbow1SHJnt.tx")`;
			}
			setAttr (($modCore + "_Elbow_OutSHJnt.jointOrient"), 0, 0, 0);
			//$elbowOffset = `getAttr ($modCore + "_ShoulderSHJnt.tx")`;
			setAttr (($modCore + "_Elbow_OutSHJnt.translate"), 0, ($elbowOffset * -0.15), 0);
		}

		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$upperJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				addAttr -ln "arm" -at bool ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				setAttr -e -k 1 ($modCore + "_Lower_Curve" + $crntNum + "SHJnt.arm");
				
				parent ($modCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
				setAttr (($modCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
				delete `pointConstraint ($modCore + "_Lower_Curve" + $crntNum + "Jnt") ($modCore + "_Lower_Curve" + $crntNum + "SHJnt")`;
				//if ($ea == 1)
				//{
				//	rotate -r -os 90 0 0 ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				//}
				//makeIdentity -apply 1 -r $freeze ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				pointConstraint -mo ($modCore + "_Lower_Curve" + $crntNum + "Jnt") ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				orientConstraint -mo ($modCore + "_Lower_Curve" + $crntNum + "Jnt") ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				
				$crntNum++;
			}
		}
		
		select -cl;
		joint -n ($modCore + "_WristSHJnt");
		addAttr -ln "hand" -at bool ($modCore + "_WristSHJnt");
		setAttr -e -k 1 ($modCore + "_WristSHJnt.hand");

		parent ($modCore + "_WristSHJnt") $parentJnt;
		setAttr (($modCore + "_WristSHJnt.jointOrient"), 0, 0, 0);
		delete `parentConstraint ($modCore + "_WristJnt") ($modCore + "_WristSHJnt")`;
		if ($ea == 1)
		{
			if ($mirrorInt == 0)
			{
				rotate -r -os 90 0 0 ($modCore + "_WristSHJnt");
			}
			else
			{
				rotate -r -os -90 0 180 ($modCore + "_WristSHJnt");
			}
		}
		makeIdentity -apply 1 -r $freeze ($modCore + "_WristSHJnt");
		parentConstraint -mo ($modCore + "_WristJnt") ($modCore + "_WristSHJnt");

		if ($ea == 1)
		{
			select -cl;
			joint -n ($modCore + "_WristTwistSHJnt");
			addAttr -ln "arm" -at bool ($modCore + "_WristTwistSHJnt");
			setAttr -e -k 1 ($modCore + "_WristTwistSHJnt.arm");

			parent ($modCore + "_WristTwistSHJnt") $parentJnt;
			setAttr (($modCore + "_WristTwistSHJnt.jointOrient"), 0, 0, 0);
			delete `pointConstraint ($modCore + "_WristJnt") ($modCore + "_WristTwistSHJnt")`;

			orientConstraint -mo -skip y -skip z ($modCore + "_WristSHJnt") ($modCore + "_WristTwistSHJnt");
			pointConstraint ($modCore + "_WristJnt") ($modCore + "_WristTwistSHJnt");
		}

		$prfx = `getAttr RRM_MAIN.rPrfx`;
		$mirrorInt++;
	}
}



////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE LEG SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigLegSH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$mirror = 0;
	$multiplier = 1;
	$core = `getAttr ($topNode + ".core")`;

	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$mirror = 1;
		$prfx = `getAttr RRM_MAIN.lPrfx`;
	}

	$mirrorInt = 0;
	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		
		//GENERATE JOINTS
		$parentJnt = ($modRigName + "" + $modAttachNode + "SHJnt");

		//HIP JOINTS
		if (!`objExists ($modCore + "_Hip_CurveJnt")` || ($ea == 1))
		{
			select -cl;
			joint -n ($modCore + "_HipSHJnt");
			addAttr -ln "upLeg" -at bool ($modCore + "_HipSHJnt");
			setAttr -e -k 1 ($modCore + "_HipSHJnt.upLeg");
			addAttr -ln "leg" -at bool ($modCore + "_HipSHJnt");
			setAttr -e -k 1 ($modCore + "_HipSHJnt.leg");
		
			parent ($modCore + "_HipSHJnt") $parentJnt;
			setAttr (($modCore + "_HipSHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_HipJnt") ($modCore + "_HipSHJnt")`;
			if ($ea == 1)
			{
				if ($mirrorInt == 0)
				{
					rotate -r -os -90 0 0 ($modCore + "_HipSHJnt");
				}
				else
				{
					rotate -r -os 90 0 180 ($modCore + "_HipSHJnt");
				}
			}
			makeIdentity -apply 1 -r $freeze ($modCore + "_HipSHJnt");
			parentConstraint -mo ($modCore + "_HipJnt") ($modCore + "_HipSHJnt");
			$parentJnt = ($modCore + "_HipSHJnt");
		}
		if (`objExists ($modCore + "_Hip_CurveJnt")`)
		{
			select -cl;
			joint -n ($modCore + "_HipCurveSHJnt");
			addAttr -ln "upLeg" -at bool ($modCore + "_HipCurveSHJnt");
			addAttr -ln "leg" -at bool ($modCore + "_HipCurveSHJnt");
			setAttr -e -k 1 ($modCore + "_HipCurveSHJnt.leg");

			parent ($modCore + "_HipCurveSHJnt") $parentJnt;
			setAttr (($modCore + "_HipCurveSHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_Hip_CurveJnt") ($modCore + "_HipCurveSHJnt")`;
			$parentJnt = ($modCore + "_HipCurveSHJnt");
			if ($ea == 1)
			{
			if ($mirrorInt == 0)
				{
					rotate -r -os -90 0 0 ($modCore + "_HipCurveSHJnt");
				}
				else
				{
					rotate -r -os 90 0 180 ($modCore + "_HipCurveSHJnt");
				}
				$parentJnt = ($modCore + "_HipSHJnt");
			}
			makeIdentity -apply 1 -r $freeze ($modCore + "_HipCurveSHJnt");
			parentConstraint -mo ($modCore + "_Hip_CurveJnt") ($modCore + "_HipCurveSHJnt");
		}



		//CHECK FOR TOON LEGS
		int $crntNum = 1;
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$upperJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
			string $crntUpper;
			for ($crntUpper in $upperJnt)
			{
				if (!`objExists ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`)
				{
					select -cl;
					joint -n ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					addAttr -ln "leg" -at bool ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");

					parent ($modCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
					setAttr (($modCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
					delete `pointConstraint ($modCore + "_Upper_Curve" + $crntNum + "Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`;

					pointConstraint -mo ($modCore + "_Upper_Curve" + $crntNum + "Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					orientConstraint -mo ($modCore + "_Upper_Curve" + $crntNum + "Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
					
					$crntNum++;
				}
			}
		}

		if ($ea == 1)
		{
			//TWIST JOINT FROM THE HIP LOCATED AT THE KNEE
			select -cl;
			joint -n ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
			addAttr -ln "leg" -at bool ($modCore + "_Upper_Curve" + $crntNum + "SHJnt");
		
			parent ($modCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
			setAttr (($modCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
			if (`objExists ($modCore + "_KneeJnt")`)
			{
				delete `pointConstraint ($modCore + "_KneeJnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
			}
			else if (`objExists ($modCore + "_Knee1Jnt")`)
			{
				delete `pointConstraint ($modCore + "_Knee1Jnt") ($modCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
			}
		}

		if (`objExists ($modCore + "_KneeJnt")`)
		{
			select -cl;
			if (!`objExists ($modCore + "_Knee_CurveJnt")` || $ea == 1)
			{
				joint -n ($modCore + "_KneeSHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_KneeSHJnt");
				addAttr -ln "knee" -at bool ($modCore + "_KneeSHJnt");
		
				parent ($modCore + "_KneeSHJnt") $parentJnt;
				setAttr (($modCore + "_KneeSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_KneeJnt") ($modCore + "_KneeSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os -90 0 0 ($modCore + "_KneeSHJnt");
					}
					else
					{
						rotate -r -os 90 0 180 ($modCore + "_KneeSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_KneeSHJnt");
				parentConstraint -mo ($modCore + "_KneeJnt") ($modCore + "_KneeSHJnt");
				$parentJnt = ($modCore + "_KneeSHJnt");
			}
			if (`objExists ($modCore + "_Knee_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + "_Knee_CurveSHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_Knee_CurveSHJnt");
				addAttr -ln "knee" -at bool ($modCore + "_Knee_CurveSHJnt");
		
				parent ($modCore + "_Knee_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Knee_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Knee_CurveJnt") ($modCore + "_Knee_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os -90 0 0 ($modCore + "_Knee_CurveSHJnt");
					}
					else
					{
						rotate -r -os 90 0 180 ($modCore + "_Knee_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Knee_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Knee_CurveJnt") ($modCore + "_Knee_CurveSHJnt");
				if ($ea == 0)
				{
					$parentJnt = ($modCore + "_Knee_CurveSHJnt");
				}
			}
		}
		else
		{
			select -cl;
			if (!`objExists ($modCore + "_Knee1_CurveJnt")` || $ea == 1)
			{
				joint -n ($modCore + "_Knee1SHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_Knee1SHJnt");
				setAttr -e -k 1 ($modCore + "_Knee1SHJnt.leg");
		
				parent ($modCore + "_Knee1SHJnt") $parentJnt;
				setAttr (($modCore + "_Knee1SHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Knee1Jnt") ($modCore + "_Knee1SHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os -90 0 0 ($modCore + "_Knee1SHJnt");
					}
					else
					{
						rotate -r -os 90 0 180 ($modCore + "_Knee1SHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Knee1SHJnt");
				parentConstraint -mo ($modCore + "_Knee1Jnt") ($modCore + "_Knee1SHJnt");
				$parentJnt = ($modCore + "_Knee1SHJnt");
			}
			if (`objExists ($modCore + "_Knee1_CurveJnt")`)
			{
				joint -n ($modCore + "_Knee1_CurveSHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_Knee1_CurveSHJnt");
				addAttr -ln "knee" -at bool ($modCore + "_Knee1_CurveSHJnt");
		
				parent ($modCore + "_Knee1_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Knee1_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Knee1_CurveJnt") ($modCore + "_Knee1_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os -90 0 0 ($modCore + "_Knee1_CurveSHJnt");
					}
					else
					{
						rotate -r -os 90 0 180 ($modCore + "_Knee1_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Knee1_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Knee1_CurveJnt") ($modCore + "_Knee1_CurveSHJnt");
				$parentJnt = ($modCore + "_Knee1_CurveSHJnt");
			}
			
			if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
			{
				$middleCurveJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
				int $crntNum = 1;
				for ($crntMiddleCurve in $middleCurveJnt)
				{
					
					select -cl;
					joint -n ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					addAttr -ln "leg" -at bool ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					setAttr -e -k 1 ($modCore + "_Middle_Curve" + $crntNum + "SHJnt.leg");

					parent ($modCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
					setAttr (($modCore + "_Middle_Curve.jointOrient"), 0, 0, 0);
					delete `pointConstraint ($modCore + "_Middle_Curve" + $crntNum + "Jnt") ($modCore + "_Middle_Curve" + $crntNum + "SHJnt")`;
					//if ($ea == 1)
					//{
					//	rotate -r -os -90 0 0 ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					//}
					//makeIdentity -apply 1 -r $freeze ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					pointConstraint -mo ($modCore + "_Middle_Curve" + $crntNum + "Jnt") ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					orientConstraint -mo ($modCore + "_Middle_Curve" + $crntNum + "Jnt") ($modCore + "_Middle_Curve" + $crntNum + "SHJnt");
					
					$crntNum++;
				}
			}
			
			select -cl;
			if (!`objExists ($modCore + "_Knee2_CurveJnt")`)
			{
				joint -n ($modCore + "_Knee2SHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_Knee2SHJnt");
				setAttr -e -k 1 ($modCore + "_Knee2SHJnt.leg");
		
				parent ($modCore + "_Knee2SHJnt") $parentJnt;
				setAttr (($modCore + "_Knee2SHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Knee2Jnt") ($modCore + "_Knee2SHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os -90 0 0 ($modCore + "_Knee2SHJnt");
					}
					else
					{
						rotate -r -os 90 0 180 ($modCore + "_Knee2SHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Knee2SHJnt");
				parentConstraint -mo ($modCore + "_Knee2Jnt") ($modCore + "_Knee2SHJnt");
				$parentJnt = ($modCore + "_Knee2SHJnt");
			}
			else
			{
				joint -n ($modCore + "_Knee2_CurveSHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_Knee2_CurveSHJnt");
				setAttr -e -k 1 ($modCore + "_Knee2_CurveSHJnt.leg");
		
				parent ($modCore + "_Knee2_CurveSHJnt") $parentJnt;
				setAttr (($modCore + "_Knee2_CurveSHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_Knee2_CurveJnt") ($modCore + "_Knee2_CurveSHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os -90 0 0 ($modCore + "_Knee2_CurveSHJnt");
					}
					else
					{
						rotate -r -os 90 0 180 ($modCore + "_Knee2_CurveSHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_Knee2_CurveSHJnt");
				parentConstraint -mo ($modCore + "_Knee2_CurveJnt") ($modCore + "_Knee2_CurveSHJnt");
				$parentJnt = ($modCore + "_Knee2_CurveSHJnt");
			}
		}

		//ADD KNEE OUT JOINT
		if ($ea == 1 && `objExists ($modCore + "_Upper_Curve3SHJnt")`)
		{
			//CONSTRAIN UPPER END JOINT
			makeIdentity -apply 1 -r $freeze ($modCore + "_Upper_Curve3SHJnt");
			if (`objExists ($modCore + "_Knee_CurveJnt")`)
			{
				pointConstraint ($modCore + "_Knee_CurveJnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_Knee_CurveSHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}
			else if (`objExists ($modCore + "_Knee1_CurveJnt")`)
			{
				pointConstraint ($modCore + "_Knee1_CurveJnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_Knee1_CurveSHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}
			else if (`objExists ($modCore + "_KneeJnt")`)
			{
				pointConstraint ($modCore + "_KneeJnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_KneeSHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}
			else if (`objExists ($modCore + "_Knee1Jnt")`)
			{
				pointConstraint ($modCore + "_Knee1Jnt") ($modCore + "_Upper_Curve3SHJnt");
				orientConstraint -mo -skip y -skip z ($modCore + "_Knee1SHJnt") ($modCore + "_Upper_Curve3SHJnt");
			}

			select -cl;
			joint -n ($modCore + "_Knee_OutSHJnt");
			addAttr -ln "leg" -at bool ($modCore + "_Knee_OutSHJnt");
			setAttr -e -k 1 ($modCore + "_Knee_OutSHJnt.leg");
			addAttr -ln "kneeOut" -at bool ($modCore + "_Knee_OutSHJnt");
			setAttr -e -k 1 ($modCore + "_Knee_OutSHJnt.kneeOut");

			float $kneeOffset;
			if (`objExists ($modCore + "_KneeJnt")`)
			{
				parent ($modCore + "_Knee_OutSHJnt") ($modCore + "_KneeSHJnt");
				$kneeOffset = `getAttr ($modCore + "_KneeSHJnt.tx")`;
			}
			else
			{
				parent ($modCore + "_Knee_OutSHJnt") ($modCore + "_Knee1SHJnt");
				$kneeOffset = `getAttr ($modCore + "_Knee1SHJnt.tx")`;
			}	
			//parent ($modCore + "_Knee_OutSHJnt") $parentJnt;
			setAttr (($modCore + "_Knee_OutSHJnt.jointOrient"), 0, 0, 0);
			//delete `parentConstraint ($modCore + "_Knee_CurveJnt") ($modCore + "_Knee_OutSHJnt")`;
			//$kneeOffset = `getAttr ($modCore + "_HipSHJnt.tx")`;
			setAttr (($modCore + "_Knee_OutSHJnt.translate"), 0, ($kneeOffset * -0.15), 0);
		}

		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$upperJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				addAttr -ln "leg" -at bool ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				setAttr -e -k 1 ($modCore + "_Lower_Curve" + $crntNum + "SHJnt.leg");

				parent ($modCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
				setAttr (($modCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
				delete `pointConstraint ($modCore + "_Lower_Curve" + $crntNum + "Jnt") ($modCore + "_Lower_Curve" + $crntNum + "SHJnt")`;
				//if ($ea == 1)
				//{
				//	rotate -r -os -90 0 0 ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				//}
				//makeIdentity -apply 1 -r $freeze ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				pointConstraint -mo ($modCore + "_Lower_Curve" + $crntNum + "Jnt") ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				orientConstraint -mo ($modCore + "_Lower_Curve" + $crntNum + "Jnt") ($modCore + "_Lower_Curve" + $crntNum + "SHJnt");
				
				$crntNum++;
			}
		}
		if ($ea == 1)
		{
			select -cl;
			joint -n ($modCore + "_AnkleTwistSHJnt");
			addAttr -ln "leg" -at bool ($modCore + "_AnkleTwistSHJnt");
			setAttr -e -k 1 ($modCore + "_AnkleTwistSHJnt.leg");

			parent ($modCore + "_AnkleTwistSHJnt") $parentJnt;
			setAttr (($modCore + "_AnkleTwistSHJnt.jointOrient"), 0, 0, 0);
			delete `pointConstraint ($modCore + "_AnkleJnt") ($modCore + "_AnkleTwistSHJnt")`;

			pointConstraint ($modCore + "_AnkleJnt") ($modCore + "_AnkleTwistSHJnt");
		}

		select -cl;
		joint -n ($modCore + "_AnkleSHJnt");
		addAttr -ln "foot" -at bool ($modCore + "_AnkleSHJnt");
		setAttr -e -k 1 ($modCore + "_AnkleSHJnt.foot");
		addAttr -ln "leg" -at bool ($modCore + "_AnkleSHJnt");
		setAttr -e -k 1 ($modCore + "_AnkleSHJnt.leg");

		parent ($modCore + "_AnkleSHJnt") $parentJnt;
		setAttr (($modCore + "_AnkleSHJnt.jointOrient"), 0, 0, 0);
		delete `parentConstraint ($modCore + "_AnkleJnt") ($modCore + "_AnkleSHJnt")`;
		if ($ea == 1)
		{
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 (-1 * $multiplier) 0 -worldUpType "objectrotation" -worldUpVector 0 0 1
			-worldUpObject ($modCore + "_BallJnt") ($modCore + "_BallJnt") ($modCore + "_AnkleSHJnt")`;
			
			delete `aimConstraint -aimVector 0 -1 0 -upVector 1 0 0 -worldUpType "object"
			-worldUpObject ($modCore + "_BallJnt") $parentJnt ($modCore + "_AnkleTwistSHJnt")`;
			//rotate -r -os -90 0 0 ($modCore + "_AnkleSHJnt");
			orientConstraint -mo -skip x -skip z ($modCore + "_AnkleSHJnt") ($modCore + "_AnkleTwistSHJnt");
		}
		makeIdentity -apply 1 -r $freeze ($modCore + "_AnkleSHJnt");
		pointConstraint -mo ($modCore + "_AnkleJnt") ($modCore + "_AnkleSHJnt");
		orientConstraint -mo ($modCore + "_AnkleJnt") ($modCore + "_AnkleSHJnt");
		$parentJnt = ($modCore + "_AnkleSHJnt");
		

		select -cl;
		joint -n ($modCore + "_BallSHJnt");
		addAttr -ln "leg" -at bool ($modCore + "_BallSHJnt");
		setAttr -e -k 1 ($modCore + "_BallSHJnt.leg");
		addAttr -ln "toeBase" -at bool ($modCore + "_BallSHJnt");
		setAttr -e -k 1 ($modCore + "_BallSHJnt.toeBase");

		parent ($modCore + "_BallSHJnt") $parentJnt;
		setAttr (($modCore + "_BallSHJnt.jointOrient"), 0, 0, 0);
		delete `parentConstraint ($modCore + "_BallJnt") ($modCore + "_BallSHJnt")`;
		if ($ea == 1)
		{
			if ($mirrorInt == 0)
			{
				rotate -r -os -90 0 0 ($modCore + "_BallSHJnt");
			}
			else
			{
				rotate -r -os 90 0 180 ($modCore + "_BallSHJnt");
			}
		}
		makeIdentity -apply 1 -r $freeze ($modCore + "_BallSHJnt");
		parentConstraint -mo ($modCore + "_BallJnt") ($modCore + "_BallSHJnt");
		$parentJnt = ($modCore + "_BallSHJnt");
		
		select -cl;
		joint -n ($modCore + "_ToeSHJnt");
		addAttr -ln "leg" -at bool ($modCore + "_ToeSHJnt");
		setAttr -e -k 1 ($modCore + "_ToeSHJnt.leg");

		parent ($modCore + "_ToeSHJnt") $parentJnt;
		setAttr (($modCore + "_ToeSHJnt.jointOrient"), 0, 0, 0);
		delete `parentConstraint ($modCore + "_ToeJnt") ($modCore + "_ToeSHJnt")`;
		if ($ea == 1)
		{
			if ($mirrorInt == 0)
			{
				rotate -r -os -90 0 0 ($modCore + "_ToeSHJnt");
			}
			else
			{
				rotate -r -os 90 0 180 ($modCore + "_ToeSHJnt");
			}
		}
		makeIdentity -apply 1 -r $freeze ($modCore + "_ToeSHJnt");
		parentConstraint -mo ($modCore + "_ToeJnt") ($modCore + "_ToeSHJnt");

		$prfx = `getAttr RRM_MAIN.rPrfx`;
		$mirrorInt++;
		$multiplier = -1;
	}
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////GENERATE Fk CHAIN SH MODULE////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigFkChainSH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$mirror = 0;
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;  
	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = `getAttr RRM_MAIN.lPrfx`;
		$mirror = 1;
	}
	$mirrorInt = 0;

	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$parentJnt = ($modRigName + "" + $modAttachNode + "SHJnt");
		
		$allJoints = `ls ("RRM_" + $prfx + $core + "_??_??")`;
		$fKChain = `ls ("RRM_" + $prfx + $core + "_??_01")`;
		$fKChainSize = `size $fKChain`;
		string $crntFkChain;
		$crntCh = 1;
		$crntJnt = 1;
			
		for ($crntFkChain in $fKChain)         
		{
			$parentJnt = ($modRigName + "" + $modAttachNode + "SHJnt");
			string $nPdCh = "";
			if ($crntCh < 10)
			{
				$nPdCh = "0";
			}
			
			$fKJoints = `ls ("RRM_" + $prfx + $core + "_" + $nPdCh + $crntCh + "_" + "??")`;
			string $crntFkJoint;
			$crntJnt = 1;
			for ($crntFkJoint in $fKJoints)
			{
				string $nPd = "";
				if ($crntJnt < 10)
				{
					$nPd = "0";
				}
				$nextJnt = ($crntJnt + 1);
				$nPdNext = "";
				if ($nextJnt <10)
				{
					$nPdNext = "0";
				}
				select -cl;
				joint -n ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				
				parent ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt") $parentJnt;
				setAttr (($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt.jointOrient"), 0, 0, 0);
				delete `parentConstraint ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt")`;
				if ($ea == 1)
				{
					if ($mirrorInt == 0)
					{
						rotate -r -os 90 0 0 ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
					}
					else
					{
						rotate -r -os -90 0 180 ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
					}
				}
				makeIdentity -apply 1 -r $freeze ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				parentConstraint -mo ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				//$JointOrient = `getAttr ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.jointOrient")`;
				//setAttr (($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$parentJnt = ($modCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				
				$crntJnt++;
			}
			$crntCh++;
		}

		$prfx = `getAttr RRM_MAIN.rPrfx`;
		$mirrorInt++;
	}
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////GENERATE HEAD SH MODULE////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigHeadSH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$mirror = 0;
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$mirror = 1;
		$prfx = `getAttr RRM_MAIN.lPrfx`;
	}
	
	$mirrorInt = 0;
	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$parentJnt = ($modRigName + "" + $modAttachNode + "SHJnt");
		

		if (`objExists ($modCore + "_JawJnt")`)
		{
			select -cl;
			joint -n ($modCore + "_JawSHJnt");
			addAttr -ln "head"  -at bool ($modCore + "_JawSHJnt");
			
			parent ($modCore + "_JawSHJnt") $parentJnt;
			setAttr (($modCore + "_JawSHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_JawJnt") ($modCore + "_JawSHJnt")`;
			if ($ea == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_JawSHJnt");
			}		
			makeIdentity -apply 1 -r $freeze ($modCore + "_JawSHJnt");
			parentConstraint -mo ($modCore + "_JawJnt") ($modCore + "_JawSHJnt");
			//$JointOrient = `getAttr ($modCore + "_JawJnt.jointOrient")`;
			//setAttr (($modCore + "_JawSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			select -cl;
			joint -n ($modCore + "_JawEndSHJnt");
			addAttr -ln "head"  -at bool ($modCore + "_JawEndSHJnt");
			
			parent ($modCore + "_JawEndSHJnt") ($modCore + "_JawSHJnt");
			setAttr (($modCore + "_JawEndSHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_JawEndJnt") ($modCore + "_JawEndSHJnt")`;
			if ($ea == 1)
			{
				rotate -r -os 180 0 0 ($modCore + "_JawEndSHJnt");
			}		
			makeIdentity -apply 1 -r $freeze ($modCore + "_JawEndSHJnt");
			parentConstraint -mo ($modCore + "_JawEndJnt") ($modCore + "_JawEndSHJnt");
			//$JointOrient = `getAttr ($modCore + "_JawEndJnt.jointOrient")`;
			//setAttr (($modCore + "_JawEndSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}

		select -cl;
		joint -n ($modCore + "_TopSHJnt");
		addAttr -ln "head"  -at bool ($modCore + "_TopSHJnt");
		
		parent ($modCore + "_TopSHJnt") $parentJnt;
		setAttr (($modCore + "_TopSHJnt.jointOrient"), 0, 0, 0);
		delete `parentConstraint ($modCore + "_TopJnt") ($modCore + "_TopSHJnt")`;
		if ($ea == 1)
		{
			rotate -r -os 180 0 0 ($modCore + "_TopSHJnt");
		}		
		makeIdentity -apply 1 -r $freeze ($modCore + "_TopSHJnt");
		parentConstraint -mo ($modCore + "_TopJnt") ($modCore + "_TopSHJnt");

		$prfx = `getAttr RRM_MAIN.rPrfx`;	
		$mirrorInt++;
	}
}
		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE LOOK AT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigLookAtSH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$mirror = 0;
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$mirror = 1;
		$prfx = `getAttr RRM_MAIN.lPrfx`;
	}
	
	$mirrorInt = 0;
	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core);
		
		$parentJnt = ($modRigName + "" + $modAttachNode + "SHJnt");
		
		//EYE JOINTS
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		string $crntLookAt;
		$crntNum = 1;
		for ($crntLookAt in $lookAts)
		{
			string $nPd = "";
			if ($crntNum < 10)
			{
				$nPd = "0";
			}
			select -cl;
			joint -n ($modCore + "_" + $nPd + $crntNum + "SHJnt");
			
			parent ($modCore + "_" + $nPd + $crntNum + "SHJnt") $parentJnt;
			setAttr (($modCore + "_" + $nPd + $crntNum + "SHJnt.jointOrient"), 0, 0, 0);
			delete `parentConstraint ($modCore + "_" + $nPd + $crntNum + "Jnt") ($modCore + "_" + $nPd + $crntNum + "SHJnt")`;
			if ($ea == 1)
			{
				rotate -r -os 180 0 90 ($modCore + "_" + $nPd + $crntNum + "SHJnt");
			}
			makeIdentity -apply 1 -r $freeze ($modCore + "_" + $nPd + $crntNum + "SHJnt");
			parentConstraint -mo ($modCore + "_" + $nPd + $crntNum + "Jnt") ($modCore + "_" + $nPd + $crntNum + "SHJnt");
			//$JointOrient = `getAttr ($modCore + "_" + $nPd + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($modCore + "_" + $nPd + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
		$prfx = `getAttr RRM_MAIN.rPrfx`;
		$mirrorInt++;
	}
}

		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE AUX AT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigAuxiliarySH(string $modRigName, string $rigGrp, string $topNode, int $freeze, int $ea)
{
	$mirror = 0;
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;  
		
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$mirror = 1;
		$prfx = `getAttr RRM_MAIN.lPrfx`;
	}
	
	$mirrorInt = 0;
	while ($mirrorInt <= $mirror)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Aux.attachNode")`;
		
		$modCore = ($modRigName + "" + $prfx + $core + "_Aux");
		
		$parentJnt = ($modRigName + "" + $modAttachNode + "SHJnt");
		
		select -cl;
		joint -n ($modCore + "SHJnt");
		
		delete `parentConstraint ($modCore + "Jnt") ($modCore + "SHJnt")`;
		if ($ea == 1)
		{
			rotate -r -os 90 0 90 ($modCore + "Jnt"); 
		}
		parent ($modCore + "SHJnt") $parentJnt;
		setAttr (($modCore + "SHJnt.jointOrient"), 0, 0, 0);
		makeIdentity -apply 1 -r $freeze ($modCore + "SHJnt");
		parentConstraint ($modCore + "Jnt") ($modCore + "SHJnt");
		//$JointOrient = `getAttr ($modCore + "Jnt.jointOrient")`;
		//setAttr (($modCore + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

		$prfx = `getAttr RRM_MAIN.rPrfx`;
		$mirrorInt++;			
	}
}


global proc RRM_MirrorAttributes(string $modRigName, string $rigGrp, string $moduleName, string $lPrfx, string $rPrfx)
{
	if (`objExists ($modRigName + $lPrfx + $moduleName + "*_Ctrl")`)
	{
		$lControls = `ls -type "transform" ($modRigName + $lPrfx + $moduleName + "*_Ctrl")`;
		
		for ($lCurrentControl in $lControls)
		{
			if (!`objExists ($lCurrentControl + ".rightControl")`)
			{
				addAttr -ln "rightControl" -dt "string" $lCurrentControl;
				setAttr -e -k 1 ($lCurrentControl + ".rightControl");
				$baseName = stringRemovePrefix($lCurrentControl, ($modRigName + $lPrfx));
				setAttr -type "string" ($lCurrentControl + ".rightControl") ($modRigName + $rPrfx + $baseName);
				//setAttr -l true ($lCurrentControl + ".rightControl");
			}
		}
		
		if (`objExists ($modRigName + $rPrfx + $moduleName + "*_Ctrl")`) 
		{
			$rControls = `ls -type "transform" ($modRigName + $rPrfx + $moduleName + "*_Ctrl")`;
			
			for ($rCurrentControl in $rControls)
			{
				if (!`objExists ($rCurrentControl + ".leftControl")`)
				{
					addAttr -ln "leftControl" -dt "string" $rCurrentControl;
					setAttr -e -k 1 ($rCurrentControl + ".leftControl");
					$baseName = stringRemovePrefix($rCurrentControl, ($modRigName + $rPrfx));
					//setAttr -type "string" ($rCurrentControl + ".rightControl") ($lPrfx + $lCurrentControl);
					connectAttr -f ($rCurrentControl + ".leftControl") ($modRigName + $lPrfx + $baseName + ".rightControl") ;
					setAttr -l 1 ($rCurrentControl + ".leftControl");
					setAttr -l true ($modRigName + $lPrfx + $baseName + ".rightControl");
				}
			}
		}
	}
}

global proc RRM_AddRigName(string $modRigName, string $rigGrp, string $modControls[])
{
	for ($crntControl in $modControls)
	{
		//if (!`objExists ($crntControl + ".modRigName")`)
		//{
			addAttr -ln "modRigName" -dt "string" $crntControl;
			setAttr -e -k 1 ($crntControl + ".modRigName");
			setAttr -type "string" ($crntControl + ".modRigName") $modRigName;
			setAttr -l true ($crntControl + ".modRigName");
		//}
	}
	
	addAttr -ln "modRigConnection" -dt "string" $rigGrp;
	setAttr -e -k 1 ($rigGrp + ".modRigConnection");
	setAttr -type "string" ($rigGrp + ".modRigConnection") $modRigName;
	setAttr -l true ($rigGrp + ".modRigConnection");
	
	for ($crntControl in $modControls)
	{
		//if (!`objExists ($crntControl + ".modRigConnection")`)
		//{
			addAttr -ln "modRigConnection" -dt "string" $crntControl;
			setAttr -e -k 1 ($crntControl + ".modRigConnection");
			connectAttr -f ($rigGrp + ".modRigConnection") ($crntControl + ".modRigConnection");
			setAttr -l true ($crntControl + ".modRigConnection");
		//}
	}
}

global proc RRM_AddControlsSize(string $modControls[])
{
	for ($each in $modControls)
	{
		if (!`objExists ($each + ".nonControl")`)
		{
			//if (!`objExists ($each + ".controlSizeX")`)
			//{
				addAttr -ln "controlSizeX" -at double -dv 1 $each;
				setAttr -e -k 1 ($each + ".controlSizeX");
				setAttr -l 1 ($each + ".controlSizeX");

				addAttr -ln "controlSizeY" -at double -dv 1 $each;
				setAttr -e -k 1 ($each + ".controlSizeY");
				setAttr -l 1 ($each + ".controlSizeY");

				addAttr -ln "controlSizeZ" -at double -dv 1 $each;
				setAttr -e -k 1 ($each + ".controlSizeZ");
				setAttr -l 1 ($each + ".controlSizeZ");
			//}
			
			//ADD MIRROR ATTRIBUTE
			//if (!`objExists ($each + ".isMirrored")`)
			//{
				addAttr -ln "isMirrored" -at double -dv 1 $each;
				setAttr -e -k 0 ($each + ".isMirrored");
				setAttr ($each + ".isMirrored") 1015;
			//}
		}
	}
}

global proc RRM_LockAndHideNonModNodes(string $modRigName, string $rigGrp)
{
	$allNodes = `listRelatives -ad $rigGrp`;
	$nurbsCurveShapes = `listRelatives -ad -type "nurbsCurve" $rigGrp`;
	$nurbsCurves = `listRelatives -p $nurbsCurveShapes`;
	$joints = `ls -type "joint" $allNodes`;
	$constraints = `ls -type "constraint" $allNodes`;
	
	select $allNodes;
	select -d $nurbsCurves $nurbsCurveShapes;
	$nonKeyableNodes = `ls -sl`;
	
	global string $gMainProgressBar;
	progressBar -edit
 	-beginProgress
 	-isInterruptable true
 	-status "Finishing Up Rig Build..."
 	-maxValue (`size $nonKeyableNodes`)
 	$gMainProgressBar;
 	
 	$crntNum = 1;
 	string $crntNode;
	for ($crntNode in $nonKeyableNodes)
	{
		if (!`gmatch $crntNode "*_RestPoseGrp"`)
		{
			if ( `nodeType $crntNode` == "transform" || `nodeType $crntNode` == "ikHandle" || `nodeType $crntNode` == "effector")
			{
				setAttr -l 1 -k 0 ($crntNode + ".tx");
				setAttr -l 1 -k 0 ($crntNode + ".ty");
				setAttr -l 1 -k 0 ($crntNode + ".tz");
				setAttr -l 1 -k 0 ($crntNode + ".rx");
				setAttr -l 1 -k 0 ($crntNode + ".ry");
				setAttr -l 1 -k 0 ($crntNode + ".rz");
				setAttr -l 1 -k 0 ($crntNode + ".sx");
				setAttr -l 1 -k 0 ($crntNode + ".sy");
				setAttr -l 1 -k 0 ($crntNode + ".sz");
				setAttr -l 1 -k 0 ($crntNode + ".visibility");
			}
			if (`gmatch $crntNode "*Constraint*"`)
			{
				$keyableAttributes = `listAttr -lf -k -v $crntNode`;
				for ($crntAttribute in $keyableAttributes)
				{
					if (`attributeExists $crntAttribute $crntNode`)
					{
						setAttr -l 1 ($crntNode + "." + $crntAttribute);
					}
				}
			}
		}
		progressBar -edit -step 1 $gMainProgressBar;		
		$crntNum++;
	}
	progressBar -edit -endProgress $gMainProgressBar;
}


global proc RRM_SingleHierarchyInterface(string $modRigName, string $rigGrp, int $rebuild, int $singleHierarchy, int $overrideSHRot, int $ea)
{
	int $freeze = 0;
	string $returnVal_SH_Generate;
	if ($rebuild == 0)
	{
		if ($ea == 1)
		{
			$returnVal_SH_Generate = `confirmDialog
			-title "Do you wish to Generate a Single Hierarchy Joint Set?"
				-message "A single hierarchy is only recommended for use in a game environment.\n-Some features may not work properly.\n-Joints do not stretch, but will maintain volume."
				-button "No"
				-button "Yes"
				-button "Yes, and Create Joint at Origin"
				-button "Yes, with EA Orientation"
				-defaultButton "No"`;
		}
		else
		{
			$returnVal_SH_Generate = `confirmDialog
			-title "Do you wish to Generate a Single Hierarchy Joint Set?"
				-message "A single hierarchy is only recommended for use in a game environment.\n-Some features may not work properly.\n-Joints do not stretch, but will maintain volume."
				-button "No"
				-button "Yes"
				-button "Yes, and Create Joint at Origin"
				-defaultButton "No"`;			
		}
	}
	else if ($singleHierarchy == 0)
	{
		$returnVal_SH_Generate = "No";
	}
	else if ($singleHierarchy == 1)
	{
		$returnVal_SH_Generate = "Yes";
	}
	else if ($singleHierarchy == 2)
	{
		$returnVal_SH_Generate = "Yes, and Create Joint at Origin";
	}
		
	
	if ($returnVal_SH_Generate == "Yes"||$returnVal_SH_Generate == "Yes, and Create Joint at Origin"||$returnVal_SH_Generate == "Yes, with EA Orientation") 
	{
		if ($returnVal_SH_Generate == "Yes, with EA Orientation") 
		{	
			$ea = 1;
		}

		if ($overrideSHRot == 2)
		{//NEW RIG
			$freezeDialog = `confirmDialog
			-title "How would you like your joints to be oriented?"
				-message "Would you like to have single hierarchy joints' rotations frozen or preserved?"
				-button "Freeze Joint Rotation"
				-button "Preserve Joint Rotation"`;
				
			if ($freezeDialog == "Freeze Joint Rotation")
			{
				$freeze = 1;
			}
			if (!`objExists ($modRigName + "MAIN_Ctrl.sh_joint_freeze")`)
			{
				lockNode -lock 0 ($modRigName + "MAIN_Ctrl");
				addAttr -ln "sh_joint_freeze" -at bool ($modRigName + "MAIN_Ctrl");
				lockNode -lock 1 ($modRigName + "MAIN_Ctrl");
			}
			setAttr -e -l 0 ($modRigName + "MAIN_Ctrl.sh_joint_freeze");
			setAttr ($modRigName + "MAIN_Ctrl.sh_joint_freeze") $freeze;
			setAttr -e -k 0 -l 1 ($modRigName + "MAIN_Ctrl.sh_joint_freeze");
		}
		else if ($overrideSHRot == 0)
		{
			if (!`objExists ($modRigName + "MAIN_Ctrl.sh_joint_freeze")`)
			{
				lockNode -lock 0 ($modRigName + "MAIN_Ctrl");
				addAttr -ln "sh_joint_freeze" -at bool ($modRigName + "MAIN_Ctrl");
				$SHRoot = `listConnections -s 1 -d 0 ($rigGrp + ".singleHierarchy")`;
				if (`size $SHRoot` > 0)
				{
					if (`getAttr ($SHRoot + ".jointOrientX")` == 0 && `getAttr ($SHRoot + ".jointOrientY")` == 0 && `getAttr ($SHRoot + ".jointOrientZ")` == 0)
					{
						setAttr ($modRigName + "MAIN_Ctrl.sh_joint_freeze") 0;
						$ea = 1;
					}
					else
					{
						setAttr ($modRigName + "MAIN_Ctrl.sh_joint_freeze") 1;
					}
				}
				setAttr -e -k 0 -l 1 ($modRigName + "MAIN_Ctrl.sh_joint_freeze");
				lockNode -lock 1 ($modRigName + "MAIN_Ctrl");
			}
			$freeze = `getAttr ($modRigName + "MAIN_Ctrl.sh_joint_freeze")`;
		}
		else if ($overrideSHRot == 1)
		{
			$freeze = (`radioButtonGrp -q -sl RRM_SHJointRotationRadiButtonGrp` - 1);
		}


		print {"\nBUILDING \"" + $rigGrp + "\" SINGLE HIERARCHY...\n"};

		select -hi RRM_MAIN;
		$hierarchy = `ls -sl -type "transform"`;
		string $topNodes[];
		string $crntNode;
   
		//SELECT TOP NODES			
		for ($crntNode in $hierarchy)
		{
		 if (`objExists ($crntNode + ".top")`)
		 {
		 $topNodes = `ls $crntNode $topNodes`;
		 }
		}
		//REORDER
		int $topNodesSize = `size $topNodes`;
		int $crntNum = $topNodesSize;
		
		string $reOrder[];
		while ($topNodesSize > 0)
		{
			$topNodesSize--;
			$reOrder = `ls $reOrder $topNodes[$topNodesSize]`;
		}
		
		//GENERATE RIG
		if ($returnVal_SH_Generate == "Yes" || $returnVal_SH_Generate == "Yes, with EA Orientation")
		{
			RRM_GenerateRigRootSH($modRigName, $rigGrp, $freeze, $ea);
		}
		else
		{
			RRM_GenerateRigRootMainSH($modRigName, $rigGrp, $freeze, $ea);
		}
		string $topNode;
		for ($topNode in $reOrder)
		{
			$modType = `getAttr ($topNode + ".top")`;
			if ($modType == "spline")
			{
				RRM_GenerateRigSplineSH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
			else if ($modType == "arm")
			{
				RRM_GenerateRigArmSH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
			else if ($modType == "leg")
			{
				RRM_GenerateRigLegSH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
			else if ($modType == "fkChain")
			{
				RRM_GenerateRigFkChainSH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
			else if ($modType == "head")
			{
				RRM_GenerateRigHeadSH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
			else if ($modType == "lookAt")
			{
				RRM_GenerateRigLookAtSH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
			else if ($modType == "auxiliary")
			{
				RRM_GenerateRigAuxiliarySH($modRigName, $rigGrp, $topNode, $freeze, $ea);
			}
		}
		if (`objExists ($modRigName + "ROOTSHJnt")`)
		{
			$sHJnts = `ls -type "joint" ($modRigName + "*SHJnt")`;
			for ($jnt in $sHJnts)
			{
				addAttr -ln "origName" -dt "string" $jnt;
				setAttr -e-keyable true ($jnt + ".origName");
				setAttr -type "string" ($jnt + ".origName") $jnt;
			}
			//ADD ATTRIBUTE TO HIPS AND MAIN CONTROL JOINT
			addAttr -ln "singleHierarchy" -dt "string" ($rigGrp);
			setAttr -e -k 1 ($rigGrp + ".singleHierarchy");
			connectAttr -f ($modRigName + "ROOTSHJnt.origName") ($rigGrp + ".singleHierarchy");

			addAttr -ln "singleHierarchy" -dt "string" ($modRigName + "ROOTJnt");
			setAttr -e -k 1 ($modRigName + "ROOTJnt.singleHierarchy");
			connectAttr -f ($modRigName + "ROOTSHJnt.origName") ($modRigName + "ROOTJnt.singleHierarchy");
		}

		//CREATE TRAJECTORY, ETC
		if ($ea == 1)		
		{
			if (!`objExists "Reference"`)
			{
				//TRAJECTORY
				select -cl;
				joint -n "Trajectory";
				rotate -r 0 -90 0 "Trajectory";

				select -cl;
				joint -n "TrajectoryEnd";
				setAttr "TrajectoryEnd.tz" 0.12;
				parent "TrajectoryEnd" "Trajectory";
				setAttr ("TrajectoryEnd.rotate", 0, 180, 0);

				if (`objExists ($modRigName + "Trajectory_Ctrl")`)
				{
					delete `pointConstraint ($modRigName + "Trajectory_Ctrl") "Trajectory"`;
					parentConstraint -mo ($modRigName + "Trajectory_Ctrl") "Trajectory";
				}

				select -cl;
				joint -n "Connect";

				select -cl;
				joint -n "CameraBase";

				select -cl;
				joint -n "CameraJoint";

				select -cl;
				joint -n "Root_Prop_01";
				setAttr "Root_Prop_01.tx" -0.08;

				select -cl;
				joint -n "Root_Prop_02";

				select -cl;
				joint -n "Root_Prop_03";
				setAttr "Root_Prop_03.tx" 0.08;

				select -cl;
				joint -n "GroundNormal";

				select -cl;

				group -n "AITrajectory" "Trajectory" "Connect" "CameraBase" "CameraJoint" "Root_Prop_01" "Root_Prop_02" "Root_Prop_03" "GroundNormal";
				group -n "Reference" "AITrajectory";
			}
			if (`objExists "AITrajectory"`)
			{
				if (`objExists ($modRigName + "ROOTSHJnt")`)
				{
					rename ($modRigName + "ROOTSHJnt") "Hips";
				}
				$parent = `listRelatives -p "Hips"`;
				if (`objExists "Hips"` && $parent[0] != "Trajectory")
				{
					parent "Hips" "AITrajectory";						
				}
			}
		}

		print "\nSINGLE HIERARCHY COMPLETED!\n";
	}
}


////////////////////////////////////////////////////////////////////////////////
//BUTTON PROC
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig(string $modRigName, string $rigGrp, int $rebuild, int $singleHierarchy, int $overrideSHRot, string $lPrfx, string $rPrfx, int $ea)
{
	if (`objExists RRM_MAIN`)
	{
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl -type "transform"`;
		if (`size $hierarchy` > 2)
		{
			string $topNodes[];
			string $crntNode;

			//SELECT TOP NODES			
			for ($crntNode in $hierarchy)
			{
			 if (`objExists ($crntNode + ".top")`)
			 {
			 	$topNodes = `ls $crntNode $topNodes`;
			 }
			}
			
			int $nodeNum = `size $topNodes`;
			if ($nodeNum > 0)
			{
				global string $gMainProgressBar;
				progressBar -edit
 				-beginProgress
 				-isInterruptable true
 				-status "Generating Rig"
 				-maxValue ($nodeNum + 2)
 				$gMainProgressBar;
 			
				//REORDER
				$topNodesSize = `size $topNodes`;
				$crntNum = $topNodesSize;
				
				string $reOrder[];
				while ($topNodesSize > 0)
				{
					$topNodesSize--;
					$reOrder = `ls $reOrder $topNodes[$topNodesSize]`;
				}
				
				//GENERATE RIG
				RRM_GenerateRigRoot($modRigName, $rigGrp, $lPrfx, $rPrfx, $ea);
				string $topNode;
				int $shoulderCheck = 0;
				int $hipCheck = 0;
				for ($topNode in $reOrder)
				{
					$modType = `getAttr ($topNode + ".top")`;
					$moduleName = `getAttr ($topNode + ".core")`;
					if ($modType == "spline")
					{
						progressBar -edit -step 1 -status ("Building Spline: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigSpline($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
					} 
					else if ($modType == "arm")
					{
						progressBar -edit -step 1 -status ("Building Arm: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigArm($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
						$shoulderCheck = 1;
					}
					else if ($modType == "leg")
					{
						progressBar -edit -step 1 -status ("Building Leg: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigLeg($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
						$hipCheck = 1;
					}
					else if ($modType == "fkChain")
					{
						progressBar -edit -step 1 -status ("Building Fk Chain: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigFkChain($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
					}
					else if ($modType == "head")
					{
						progressBar -edit -step 1 -status ("Building Head: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigHead($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
					}
					else if ($modType == "lookAt")
					{
						progressBar -edit -step 1 -status ("Building Look-At: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigLookAt($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
					}
					else if ($modType == "auxiliary")
					{
						progressBar -edit -step 1 -status ("Building Auxiliary: " + $moduleName) $gMainProgressBar;
						RRM_GenerateRigAuxiliary($modRigName, $rigGrp, $moduleName, $topNode, $lPrfx, $rPrfx, $ea);
					}
					//ADD MIRROR OBJECT ATTRIBUTE
					RRM_MirrorAttributes($modRigName, $rigGrp, $moduleName, $lPrfx, $rPrfx);
					select -cl;
					refresh;
				}
				
				string $modControls[];
				for ($shape in `listRelatives -ad -type "nurbsCurve" $rigGrp`)
				{
					string $ctrl[] = `listRelatives -p $shape`;
					if (`gmatch $ctrl[0] "*_Ctrl"`)
					{
						$modControls = `ls $modControls $ctrl[0]`;
						$modControls = stringArrayRemoveDuplicates($modControls);
					}

				}
				
				//ADD RIG NAME TO CONTROLS
				RRM_AddRigName($modRigName, $rigGrp, $modControls);
				
				//ADD CORE CONTROL NAME
				RRM_ControlName($modRigName, $rigGrp, $modControls);
				
				//ADD CONTROL SIZE TO CONTROLS
				RRM_AddControlsSize($modControls);

				//CREATE REST POSE GROUPS
				string $ctrl;
				for ($ctrl in $modControls)
				{
					//ONLY FOR CONTROLS THAT HAVE ONE OR MORE TRANSFORMS UNLOCKED
					if (`getAttr -l ($ctrl + ".tx")` && `getAttr -l ($ctrl + ".ty")` && `getAttr -l ($ctrl + ".tz")` &&
					`getAttr -l ($ctrl + ".rx")` && `getAttr -l ($ctrl + ".ry")` && `getAttr -l ($ctrl + ".rz")` &&
					`getAttr -l ($ctrl + ".sx")` && `getAttr -l ($ctrl + ".sy")` && `getAttr -l ($ctrl + ".sz")`)
					{
						//DO NOTHING IF ALL CHANNELS ARE LOCKED
					}
					else
					{
						$pivot = `xform -q -ws -rp $ctrl`;
						if (`objExists ($ctrl + ".moduleType")` )
						{
							if (`getAttr ($ctrl + ".moduleType")` == "fkChain")
							{
								group -n ($ctrl + "_RestPoseGrp") `listRelatives -p $ctrl`; xform -ws -piv $pivot[0] $pivot[1] $pivot[2];	
							}
							else
							{
								group -n ($ctrl + "_RestPoseGrp") $ctrl; xform -ws -piv $pivot[0] $pivot[1] $pivot[2];							
							}
						}
						else
						{
							group -n ($ctrl + "_RestPoseGrp") $ctrl; xform -ws -piv $pivot[0] $pivot[1] $pivot[2];							
						}
						//PARENT IN FK AND IK SWITCH LOCATORS
						if (`gmatch $ctrl "*WristIk_Ctrl"`)
						{
							parent (`getAttr ($ctrl + ".modRigName")` + `getAttr ($ctrl + ".modCoreName")` + "_WristIkToFkLctr") `listRelatives -p $ctrl`;
						}
						else if (`gmatch $ctrl "*ElbowIk_Ctrl"`)
						{
							parent (`getAttr ($ctrl + ".modRigName")` + `getAttr ($ctrl + ".modCoreName")` + "_ElbowIkToFkAimLctr") `listRelatives -p $ctrl`;
						}
						if (`gmatch $ctrl "*FootIk_Ctrl"`)
						{
							parent (`getAttr ($ctrl + ".modRigName")` + `getAttr ($ctrl + ".modCoreName")` + "_AnkleIkToFkLctr") `listRelatives -p $ctrl`;
						}
						else if (`gmatch $ctrl "*KneeIk_Ctrl"`)
						{
							parent (`getAttr ($ctrl + ".modRigName")` + `getAttr ($ctrl + ".modCoreName")` + "_KneeIkToFkAimLctr") `listRelatives -p $ctrl`;
						}
							
							
						//MATCH ROTATE ORDER
						setAttr ($ctrl + "_RestPoseGrp.rotateOrder") `getAttr ($ctrl + ".rotateOrder")`;
						if (`getAttr -l ($ctrl + ".tx")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.tx");
						}
						else
						{
							addAttr -ln "TX" -at double -dv 0 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".ty")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.ty");
						}
						else
						{
							addAttr -ln "TY" -at double -dv 0 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".tz")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.tz");
						}
						else
						{
							addAttr -ln "TZ" -at double -dv 0 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".rx")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.rx");
						}
						else
						{
							addAttr -ln "RX" -at double -dv 0 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".ry")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.ry");
						}
						else
						{
							addAttr -ln "RY" -at double -dv 0 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".rz")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.rz");
						}
						else
						{
							addAttr -ln "RZ" -at double -dv 0 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".sx")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.sx");
						}
						else
						{
							addAttr -ln "SX" -at double -dv 1 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".sy")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.sy");
						}
						else
						{
							addAttr -ln "SY" -at double -dv 1 ($ctrl + "_RestPoseGrp");
						}
						if (`getAttr -l ($ctrl + ".sz")`)
						{
							setAttr -l 1 -k 0 ($ctrl + "_RestPoseGrp.sz");
						}
						else
						{
							addAttr -ln "SZ" -at double -dv 1 ($ctrl + "_RestPoseGrp");
						}
					}
				}

				
				//CREATE LAYERS
				//LAYER
				progressBar -edit -step 1 -status "Setting up Controls Layer" $gMainProgressBar;
				
				createDisplayLayer -n ($modRigName + "ControlsLayer") -number 1 -empty;
				$shapes = `listRelatives -ad -type "nurbsCurve" $rigGrp`;
				$curves = `listRelatives -p $shapes`;
				$curves = stringArrayRemoveDuplicates($curves);
				
				string $ctrls[];
				string $ctrl;
				for ($ctrl in $curves)
				{
					if (`gmatch $ctrl "*_Ctrl"`)
					{
						$ctrls = `ls $ctrls $ctrl`;
					}
				}


				editDisplayLayerMembers -noRecurse ($modRigName + "ControlsLayer") $ctrls;
				
				progressBar -edit -step 1 -status "Setting up Joints Layer" $gMainProgressBar;
				createDisplayLayer -n ($modRigName + "JointsLayer") -number 1 -empty;	
				select ($modRigName + "*Jnt");
				if ($shoulderCheck == 1)
				{
					select -d -hierarchy ($modRigName + "*ShoulderJnt");
				}
				if ($hipCheck == 1)
				{
					if (`objExists ($modRigName + "*KneeJnt")`)
					{
						select -d -hierarchy ($modRigName + "*KneeJnt");
					}
					else
					{
						select -d -hierarchy ($modRigName + "*Knee1Jnt");
					}
				}
				
				editDisplayLayerMembers -noRecurse ($modRigName + "JointsLayer") `ls -sl`;
				
				progressBar -edit -endProgress $gMainProgressBar;
				//MAKE ALL NODES UNKEYABLE
				RRM_LockAndHideNonModNodes($modRigName, $rigGrp);
				select -cl;
				refresh;
				RRM_SingleHierarchyInterface($modRigName, $rigGrp, $rebuild, $singleHierarchy, $overrideSHRot, $ea);

				//ADD CUSTOM ATTR TO RRM BUILT SHAPES
				for ($shape in `listRelatives -ad -type "nurbsCurve" ($modRigName + "MAIN_Ctrl")`)
				{
					addAttr -ln "curveCheck" -dt "string" $shape;
					setAttr -e-keyable true ($shape + ".curveCheck");
					setAttr -type "string" ($shape + ".curveCheck") $modRigName;
					setAttr -e -l true ($shape + ".curveCheck");
				}
				
				select ($modRigName + "MAIN_Ctrl");
			}
			else
			{
			string $returnVal_Generate = `confirmDialog
			-title "Your Rig Has No Modules"
			-message "You must create modules and attach them to your rig.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
			}
		}
		else
		{
			string $returnVal_Generate = `confirmDialog
			-title "Your Rig Has No Modules"
			-message "You must create modules and attach them to your rig.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
		-title "No Rig Exists"
		-message "You must first create a Proxy rig to RRM_Generate a final rig from.\n"
		-button "OK"
		-defaultButton "OK"
		-cancelButton "OK"
		-icon "critical"`;
	}
	if (`objExists ($modRigName + "MAIN_Ctrl")`)
	{
		lockNode ($rigGrp) ($modRigName + "MAIN_Ctrl") ($modRigName + "ROOTSecondary_Ctrl");
		select ($modRigName + "MAIN_Ctrl");
	}
	
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;
}

///PROMPTS
global proc RRM_GenerateRigPrompts(int $useName, string $modRigName, int $ea)
{
	int $modRigNameSize = `size $modRigName`;
	string $rigGrp;
	
	if ($modRigNameSize == "0" && ($useName == 1))
	{
		string $returnVal_Generate = `confirmDialog
			-title "Modular Rig Needs a Name"
			-message "You must enter a name for the rig\n in the \"Rig Name\" text field,\nor disable Custom Prefix."
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (! RRM_CheckName($modRigName) && ($useName == 1))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is Invalid"
			-message "A valid name must begin with a letter.\n The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modRigName)` && ($useName == 1))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is not Unique"
			-message "A rig already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if ($useName == 0 && `objExists "MAIN*Ctrl"`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "A non-named rig already exists"
			-message "A rig already exists with no prefix.\nYou must create a unique prefix\nfor new rigs in this scene.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else
	{
		//CHECK IF NODE EDITOR IS OPEN
		string $nodeEditor[] = `getPanel -scriptType nodeEditorPanel `;
		
		for ($editor in $nodeEditor )
		{
			string $tokens[];
			string $control = `scriptedPanel -q -ctl $editor`;
		
			if ( $control != "" )
			{
				if ( 0 < `tokenize $control "|" $tokens` )
				{
					//print ( "Window for Node Editor: " + $tokens[0] + "\n" );
				 
					string $NodeEditorUI = `confirmDialog
						-title "Close Node Editor Before Proceeding?"
						-message "The Node Editor is open.\nGenerating a rig with the node editor opened will cause the rig to take much longer to RRM_Generate \n"
						-button "Close Node Editor"
						-button "Ignore"
						-button "Cancel"
						-defaultButton "Close Node Editor"
						-dismissString "Ignore"
						-cancelButton "Ignore"`;
						//-icon "critical"`;
						
					if ($NodeEditorUI == "Close Node Editor")
					{
						deleteUI -window $tokens[0];
					}
				}
		 	}
		}
		
		$lPrfx = "l_";
		$rPrfx = "r_";
		if (`objExists RRM_MAIN.lPrfx`)
		{
			$lPrfx = `getAttr RRM_MAIN.lPrfx`;
			$rPrfx = `getAttr RRM_MAIN.rPrfx`;
		}
		
		//vv 2 IS FOR SINGLE HIERARCHY JOINT ORIENTS vv
		$rigGrp = $modRigName;
		if ($useName == 1)
		{
			$modRigName = ($modRigName + "_");
		}
		else if ($useName == 0)
		{
			$rigGrp = "ControlRig";
			$modRigName = "";
		}
		RRM_GenerateRig($modRigName, $rigGrp, 0, 0, 2, $lPrfx, $rPrfx, $ea);
		if (`objExists ($modRigName + "MAIN_Ctrl")`)
		{
			RRM_ColorControls($modRigName);
			if (`objExists RRM_ProxiesLayer`)
			{
				setAttr RRM_ProxiesLayer.visibility 0;
			}
		}
	}
	//LOAD RIG NAME INTO TEXT FIELD
	textFieldButtonGrp -e -tx $rigGrp RRM_LoadRigTextFieldButtonGrp;
	
	select -cl;
}

///////DEPENDENCIES
global proc RRM_ElbowNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_ElbowJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_ElbowNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_ElbowNum;
	}
}

global proc RRM_KneeNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_KneeJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_KneeNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_KneeNum;
	}
}

global proc RRM_ElbowEditNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_ElbowEditJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_ElbowEditNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_ElbowEditNum;
	}
}

global proc RRM_KneeEditNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_KneeEditJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_KneeEditNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_KneeEditNum;
	}
}

global proc RRM_ToggleTemplate()
{
	$crntSetting = `checkBox -q -v RRM_TemplateCheckBox`;
	if ($crntSetting == 1)
	{
		optionMenu -e -enable 1 RRM_TemplateType;
		button -e -label "Create Template Proxy Rig" RRM_CreateProxyMainProxyButton;
	}
	else
	{
		optionMenu -e -enable 0 RRM_TemplateType;
		button -e -label "Create New Proxy Rig" RRM_CreateProxyMainProxyButton;
	}
}

global proc RRM_ToggleTransferParent()
{
	$crntSetting = `radioButtonGrp -q -select RRM_TransferSelectionButton`;
	if ($crntSetting == 1)
	{
		checkBox -e -enable 0 RRM_TransferParent;
	}
	else
	{
		checkBox -e -enable 1 RRM_TransferParent;
	}
}

//DELETE PROXY RIG
global proc RRM_DeleteProxyRig()
{
	if (`objExists RRM_MAIN`)
	{
		string $confirmDeleteProxies = `confirmDialog
			-title "Delete Proxies"
			-message "Are you sure you want to delete your proxy rig?\n"
			-button "Delete Proxies"
			-button "Cancel"
			-defaultButton "Cancel"
			-dismissString "Cancel"
			-cancelButton "Cancel"`;
			//-icon "critical"`;
			
		if ($confirmDeleteProxies == "Delete Proxies")
		{
			if (`objExists RRM_MAIN`)
			{
				select -hi RRM_MAIN;
				$rigHierarchy = `ls -sl`;
				lockNode -l off $rigHierarchy;
				delete RRM_MAIN;
				
				if (`objExists RRM_ProxiesLayer`)
				{
					delete RRM_ProxiesLayer;
				}
			}
		}
	}
	else
	{
		warning "A proxy rig (that is not referenced) does not exist in this scene.";
	}
}


//STANDARD JOINT SELECTION
global proc RRM_SelectStandardJoints(string $modRigName, string $rigGrp, string $modifier)
{
	$sel = `ls -sl`;
	//select ($modRigName + "*Jnt");
	select -cl;
	$allJoints = `listRelatives -ad -type "joint" $rigGrp`;
	//print $allJoints;
	//string $joints[];
	string $j;
	for ($j in $allJoints)
	{
		if (`gmatch $j ($modRigName + "*Jnt")`)
		{
			select -add $j;
		}
		if (`objExists ($modRigName + "ROOTSHJnt")`)
		{
			select -d ($modRigName + "*SHJnt");
		}
	}
	$allStandardJoints = `ls -sl`;
	string $skinningJoints[];
	for ($each in $allStandardJoints)
	{
		$drawStyle = `getAttr ($each + ".drawStyle")`;
		$visibility = `getAttr ($each + ".visibility")`;

		if ($drawStyle == 0 && $visibility == 1)
		{
			$skinningJoints = `ls $skinningJoints $each`;
		}
	}
	select $skinningJoints;
	if ($modifier == 1)
	{
		select $sel;
		select -add $skinningJoints;
	}
}

//SINGLE HIERARCHY JOINT SELECTION
global proc RRM_SelectSingleHierarchyJoints(string $modRigName, string $rigGrp, string $modifier)
{
	$sel = `ls -sl`;
	string $joints[];
	if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
	{
		$connections = `listConnections -s 1 -d 0 ($modRigName + "ROOTJnt.singleHierarchy")`;
		if (`size $connections` > 0)
		{
			$jointParent = `listRelatives -p $connections[0]`;
			if (`nodeType $jointParent[0]` == "joint")
			{
				$joints = `listRelatives -ad -type "joint" $jointParent[0]`;
				$joints = `ls $jointParent[0] $joints`;
			}
			else
			{
				$joints = `listRelatives -ad -type "joint" $connections[0]`;
				$joints = `ls $connections[0] $joints`;
			}
		}
		select $joints;
		if ($modifier == 1)
		{
			select $sel;
			select -add $joints;
		}		
	}
}


///SELECT JOINTS
global proc RRM_LoadRig()
{
	$selection = `ls -sl`;
	if (`size $selection` > 0)
	{
		if (`objExists ($selection[0] + ".modRigConnection")`)
		{
			string $modRigConnections[] = `listConnections ($selection[0] + ".modRigConnection")`;
			string $modRigName = $modRigConnections[0];
			textFieldButtonGrp -e -tx $modRigName RRM_LoadRigTextFieldButtonGrp;
		}
		else
		{warning "Selected Object is not a Rapid Rig Modular Control";}
	}
	else
	{warning "Nothing Selected. Please Select a Rapid Rig Modular Control";}
}

global proc RRM_SelectJoints(string $rigGrp)
{
	$modifier = `getModifiers`;
	$modRigName = `getAttr ($rigGrp + ".modRigConnection")`;
	//print ("modRigName is " + $modRigName + "\n");
	if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
	{
		string $returnVal_Skin = `confirmDialog
		-title "Select Skinning Joints"
		-message "Which joints do you wish to select?"
		-button "Standard"
		-button "Single Hierarchy"
		-button "Cancel"
		-defaultButton "Cancel"
		-cancelButton "Cancel"`;
	
		if ($returnVal_Skin == "Standard")
		{
			RRM_SelectStandardJoints($modRigName, $rigGrp, $modifier);
			print "Standard joints selected.\n";
		}
	
		if ($returnVal_Skin == "Single Hierarchy")
		{
			RRM_SelectSingleHierarchyJoints($modRigName, $rigGrp, $modifier);
			print "Single hierarchy joints selected.\n";
		}
	}
	else if (`objExists ($modRigName + "ROOTJnt")`)
	{
		RRM_SelectStandardJoints($modRigName, $rigGrp, $modifier);
		print "Joints have been selected.\n";		
	}
	else
	{
		error "No joints have been created yet.\n";
	}
}

global proc RRM_CreateCharacterSet(int $subCharSet)
{
	$selection = `ls -sl`;
	if (`size $selection` == 1)
	{
		//CHECK IF MAINC IS SELECTED
		if (`objExists ($selection[0] + ".isMain")`)
		{
			//CREATE CHARACTER SET
			$modRigName = `getAttr ($selection[0] + ".modRigName")`;
			if (!`objExists ($modRigName + "CharSet")`)
			{
				character -em -name ($modRigName + "CharSet") -excludeVisibility;
				if ($subCharSet == 0)
				{
					$curveHierarchy = `listRelatives -ad -type "nurbsCurve" $selection[0]`;
					$hierarchy = `listRelatives -p $curveHierarchy`;
					$hierarchy = stringArrayRemoveDuplicates($hierarchy);
					for ($each in $hierarchy)
					{
						if (`objExists ($each + ".modControlName")` && !`objExists ($each + ".nonControl")`)
						{
							character -add ($modRigName + "CharSet") $each;
							print ("Adding \"" + $each + "\" to " + ($modRigName + "CharSet") + ".\n");
						}
					}
				}
				else
				{
					//CREATE SUB CHARACTER SETS
					select -hi $selection[0];
					$hierarchy = `ls -sl -type "transform"`;
					$hierarchy = `listRelatives -ad -type "transform" $selection[0]`;
					
					//FIND MODULE TOP GROUPS
					$children = `listRelatives -c $selection[0]`;
					string $modules[];
					for ($eachChild in $children)
					{
						if (`objExists ($eachChild + ".topNode")`)
						{
							$modules = `ls $modules $eachChild`;
						}
					}					
					
					for ($each in $modules)
					{
						int $i;
						character -em -name ($each + "_CharSet") -excludeVisibility;
						character -add ($modRigName + "CharSet") ($each + "_CharSet");
						
						$curveHierarchy = `listRelatives -ad -type "nurbsCurve" $selection[0]`;
						$hierarchy = `listRelatives -p $curveHierarchy`;
						for ($eachControl in $hierarchy)
						{
							if (`objExists ($eachControl + ".modControlName")` && !`objExists ($eachControl + ".nonControl")`)
							{
								$existingChar = `listConnections -d 0 -t "character" $eachControl`;
								$charSize = `size $existingChar`;
								if ($charSize == 0)
								{
									character -add ($each + "_CharSet") $eachControl;
									print ("Adding \"" + $eachControl + "\" to " + ($each + "_CharSet") + ".\n");
								}
							}
						}
					}
				}
			}
			else
			{
				warning ("A character set already exists for \"" + $modRigName + "\".");
			}
		}
		else
		{
			warning "Select the Main Ctrl of your rig.";
		}
	}
	else if (`size $selection` > 1)
	{
		warning "Please select only the MAINC of your rig";
	}
	else
	{
		warning "You must select the MAINC of your rig";
	}
	select $selection;
}



//////////////////////////REBUILD RIG////////////////////////////////////////

global proc string[] RRM_SavePose(string $modRigName)
{
	$controls = `listRelatives -ad -type "transform" ($modRigName + "MAIN_Ctrl")`;
	$controls = `ls $modRigName $controls`; 
	string $ctrlVals[];
	$i = 0;
	for ($ctrl in $controls)
	{
		if (`objExists ($ctrl + ".modRigName")`)
		{
			if (`getAttr -l ($ctrl + ".tx")` == 0 && `getAttr ($ctrl + ".tx")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".tx\" " + `getAttr ($ctrl + ".tx")` + ";");
				$i++;
			}
			if (`getAttr -l ($ctrl + ".ty")` == 0 && `getAttr ($ctrl + ".ty")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".ty\" " + `getAttr ($ctrl + ".ty")` + ";");
				$i++;
			}
			if (`getAttr -l ($ctrl + ".tz")` == 0 && `getAttr ($ctrl + ".tz")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".tz\" " + `getAttr ($ctrl + ".tz")` + ";");
				$i++;
			}

			if (`getAttr -l ($ctrl + ".rx")` == 0 && `getAttr ($ctrl + ".rx")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".rx\" " + `getAttr ($ctrl + ".rx")` + ";");
				$i++;
			}
			if (`getAttr -l ($ctrl + ".ry")` == 0 && `getAttr ($ctrl + ".ry")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".ry\" " + `getAttr ($ctrl + ".ry")` + ";");
				$i++;
			}
			if (`getAttr -l ($ctrl + ".rz")` == 0 && `getAttr ($ctrl + ".rz")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".rz\" " + `getAttr ($ctrl + ".rz")` + ";");
				$i++;
			}

			if (`getAttr -l ($ctrl + ".sx")` == 0 && `getAttr ($ctrl + ".sx")` != 1)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".sx\" " + `getAttr ($ctrl + ".sx")` + ";");
				$i++;
			}
			if (`getAttr -l ($ctrl + ".sy")` == 0 && `getAttr ($ctrl + ".sy")` != 1)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".sy\" " + `getAttr ($ctrl + ".sy")` + ";");
				$i++;
			}
			if (`getAttr -l ($ctrl + ".sz")` == 0 && `getAttr ($ctrl + ".sz")` != 1)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".sz\" " + `getAttr ($ctrl + ".sz")` + ";");
				$i++;
			}

		}
	}
	return $ctrlVals;
}

global proc RRM_RebuildRig(int $saveSkinning, int $saveControlShapes, int $ea)
{
	string $modRigName;
	string $rigGrp;
	int $verts[];
	int $vertTotal= 0;
	//GET RIG NAME
	$selection = `ls -sl`;
	if (`size $selection` > 0)
	{
		//MAKE SURE A PROXY RIG EXISTS
		if (`objExists "RRM_MAIN"`)
		{
			string $lPrfx;
			string $rPrfx;
			if (`objExists RRM_MAIN.lPrfx`)
			{
				$lPrfx = `getAttr RRM_MAIN.lPrfx`;
				$rPrfx = `getAttr RRM_MAIN.rPrfx`;
			}

			if (`objExists ($selection[0] + ".modRigName")`)
			{
				$modRigName = `getAttr ($selection[0] + ".modRigName")`;
				string $modRigConnections[] = `listConnections ($selection[0] + ".modRigConnection")`;
				string $rigGrp = $modRigConnections[0];

				string $result = `confirmDialog -title "Rebuild Rig"
					-message "Are you sure you want to rebuild?\nThis is not undoable and all animation will be lost."
					-button "Yes" -button "Cancel" -defaultButton "Yes"
					-cancelButton "Cancel" -dismissString "Cancel"`;
 
 				if ($result == "Yes")
				{
					//CLOSE NODE EDITOR
					string $nodeEditor[] = `getPanel -scriptType nodeEditorPanel `;
					
					for ($editor in $nodeEditor )
					{
						string $tokens[];
						string $control = `scriptedPanel -q -ctl $editor`;
					
						if ( $control != "" )
						{
							if ( 0 < `tokenize $control "|" $tokens` )
							{
								deleteUI -window $tokens[0];
							}
						}
					}

					////////////////////////////////////////////////////////////////////////////
					//SAVE RENAMED SH JOINTS AND PREFERRED ANGLES///////////////////////////////
					////////////////////////////////////////////////////////////////////////////
					string $origName[];
					string $attr;
					int $iOR = 0;

					if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
					{
						$connections = `listConnections -s 1 -d 0 ($modRigName + "ROOTJnt.singleHierarchy")`;
						//print $connections;
						if (`size $connections` > 0)
						{
							//string $sHJnts[];
							//$jointParent = `listRelatives -p $connections[0]`;
							//if (`nodeType $jointParent[0]` == "joint")
							//{
							//	$sHJnts = `listRelatives -ad $jointParent[0]`;
							//	$sHJnts = `ls $jointParent[0] $sHJnts`;
							//}
							//else
							//{
							//	$sHJnts = `listRelatives -ad $connections[0]`;
							//	$sHJnts = `ls $connections[0] $sHJnts`;
							//}
							$attr = `getAttr ($connections[0] + ".origName")`;
							$prfAngle = `getAttr ($connections[0]  + ".preferredAngle")`;
							$origName[$iOR] = ($origName[$iOR] + "if (`objExists (\"" + $attr + "\")`){rename \"" + $attr + "\" \"" + $connections[0] + "\";");
							$origName[$iOR] = ($origName[$iOR] + " setAttr ((\"" + $connections[0] + ".preferredAngle\"), " + $prfAngle[0] + ", " + $prfAngle[1] + ", " + $prfAngle[2] + ");}");
							$iOR++;
							$sHJnts = `listRelatives -ad $connections[0]`;
							//	$sHJnts = `ls $connections[0] $sHJnts`;

							//print $sHJnts;
							for ($jnt in $sHJnts)
							{
								if (`objExists ($jnt + ".origName")`)
								{
									//print "attrExists\n";
									$attr = `getAttr ($jnt + ".origName")`;
									$prfAngle = `getAttr ($jnt + ".preferredAngle")`;
									$origName[$iOR] = ($origName[$iOR] + "if (`objExists (\"" + $attr + "\")`){rename \"" + $attr + "\" \"" + $jnt + "\";");
									$origName[$iOR] = ($origName[$iOR] + " setAttr ((\"" + $jnt + ".preferredAngle\"), " + $prfAngle[0] + ", " + $prfAngle[1] + ", " + $prfAngle[2] + ");}");
									$iOR++;
								}
							}
						}
					}



					////////////////////////////////////////////////////////////////////////////
					//SAVE WEIGHTS////////////////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////////////////
					//GET SKIN CLUSTERS
					string $skinPercentCommand[];
					string $skinnedMesh[];
					string $skinningCommand[];
					string $geomBind[];
					string $geomClusters[];
					int $skinNum = 0;
					if ($saveSkinning == 1)
					{
						RRM_SelectStandardJoints($modRigName, $rigGrp, 0);
						$stJoints = `ls -sl`;
						string $shJoints[];
						if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
						{
							RRM_SelectSingleHierarchyJoints($modRigName, $rigGrp, 0);
							$shJoints = `ls -sl`;
							select $stJoints;
						}
						if (`size $shJoints` > 0)
						{
							select -add $shJoints;
						}
						$allJnts = `ls -sl -type "joint"`;
						$skinClusters = `listConnections -d 1 -s 0 -type "skinCluster" $allJnts`;
						$allSkinClusters = stringArrayRemoveDuplicates($skinClusters);

						if (`getApplicationVersionAsFloat` >= 2015)
						{
							$geomBind = `listConnections -d 0 -s 1 -type "geomBind" $skinClusters`;
							if (`size $geomBind` > 0)
							{
								$geomBind = stringArrayRemoveDuplicates($geomBind);
								$geomClusters = `listConnections -d 1 -s 0 -type "skinCluster" $geomBind`;
								if (`size $geomClusters` > 0)
								{
									$geomClusters = stringArrayRemoveDuplicates($geomClusters);
									select $allSkinClusters;
									select -d $geomClusters;
									$allSkinClusters = `ls -sl`;
								}
							}
						}
						//print $allSkinClusters;
						//SAVE WEIGHTS
						for ($cluster in $allSkinClusters)
						{
							//GET THE MESHES ASSOCIATED WITH THE SKIN CLUSTERS
							$skinClusterSets = `listConnections -s 0 -d 1 -type "objectSet" $cluster`;
							$skinnedMesh = `listConnections -d 1 -type "mesh" $skinClusterSets`;
							//FOR MESH IN SKINNEDMESH:
							for ($mesh in `stringArrayRemoveDuplicates $skinnedMesh`)
							{
								//#GET ALL THE VERTICES
								$verts = `polyEvaluate -vertex $mesh`;
								$vertTotal = ($vertTotal + $verts[0]);
								int $v = 0;
								
								global string $gMainProgressBar;
								progressBar -edit
									-beginProgress
									-isInterruptable true
									-status ("Saving Weights on \"" + $mesh + "\"...")
									-maxValue ($verts[0])
									$gMainProgressBar;
							
								while ($v < $verts[0])
								{
									$skinInfluence = `skinPercent -q -t $cluster ($mesh + ".vtx[" + $v + "]")`;
									$skinWeight = `skinPercent -q -v $cluster ($mesh + ".vtx[" + $v + "]")`;
									
									//#DEFINE THE COMMAND STRING PER VERTEX
									$skinPercentCommand[$skinNum] = ("skinPercent" );
									$infNum = 0;
									for ($inf in $skinInfluence)
									{
										$skinPercentCommand[$skinNum] = ($skinPercentCommand[$skinNum] + " -transformValue \"" + $skinInfluence[$infNum] + "\" " + $skinWeight[$infNum]);
										$infNum ++;
										
									}
									$skinPercentCommand[$skinNum] = ($skinPercentCommand[$skinNum] + " \"" + $cluster + "\" \"" + $mesh + ".vtx[" + $v + "]\";");
									$v++;
									$skinNum++;
									progressBar -edit -step 1 $gMainProgressBar;
								}
								progressBar -edit -endProgress $gMainProgressBar;
							}
						}
						//select "break";
						
						$skinNum = 0;
						
						//SAVE SKIN CLUSTER DATA
						for ($cluster in $allSkinClusters)
						{
							//GET THE MESHES ASSOCIATED WITH THE SKIN CLUSTERS
							$skinClusterSets = `listConnections -s 0 -d 1 -type "objectSet" $cluster`;
							$skinnedMesh = `listConnections -d 1 -type "mesh" $skinClusterSets`;
							$skinnedMesh = `stringArrayRemoveDuplicates($skinnedMesh)`;
							
							//CREATE COMMAND FOR GENERATING SKIN CLUSTER
							//FOR MESH IN SKINNEDMESH:
							for ($mesh in $skinnedMesh)
							{
								$skinningCommand[$skinNum] = ("select " + $mesh + "; ");
							}
							//GET ALL THE JOINTS ASSOCIATED WITH THE SKIN CLUSTER
							$joints = `listConnections -d 0 -s 1 -type "joint" $cluster`;
							$joints = `stringArrayRemoveDuplicates($joints)`;
							for ($jnt in $joints)
							{
								$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "if (`objExists " + $jnt + "`){select -add " + $jnt + ";} "); 
							}
								
							//QUERY SKIN CLUSTER SETTINGS
							$skMthd = `skinCluster -q -skinMethod $cluster`;
							$nrml = `skinCluster -q -nw $cluster`;
							$mxInfNum = `skinCluster -q -mi $cluster`;
							$mxInfChk = `skinCluster -q -obeyMaxInfluences $cluster`;

								
							if (`getApplicationVersionAsFloat` >= 2013)
							{
								$bndMthd = `skinCluster -q -bindMethod $cluster`;
								$bndMthd = 0;
								$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + ("skinCluster -n " + $cluster + " -bindMethod " + $bndMthd + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";"));
							}
							else
							{
								$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + ("skinCluster -n " + $cluster + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";"));
							}
							$skinNum++;
						}
						//SAVE SKINNING DATA FOR GEODESIC CLUSTERS
						if (`size $geomClusters` > 0)
						{
							for ($gBnd in $geomBind)
							{
								$gBndClusters = `listConnections -d 1 -s 0 -type "skinCluster" $gBnd`;
								string $clstrString;
								int $mxInfNum;
								for ($clstr in $gBndClusters)
								{
									$joints = `listConnections -s 1 -d 0 -type "joint" $clstr`;
									$joints = `stringArrayRemoveDuplicates($joints)`;
									$skMthd = `skinCluster -q -skinMethod $clstr`;
									$nrml = `skinCluster -q -nw $clstr`;
									$mxInfNum = `skinCluster -q -mi $clstr`;
									$mxInfChk = `skinCluster -q -obeyMaxInfluences $clstr`;
									string $transform[] = `listConnections -d 1 -s 0 $clstr`;
									$transform = `ls -type "transform" $transform`;
									
									string $transformString;
									for ($tForm in $transform)
									{
										$transformString = ($transformString + " " + $tForm);
									}
									
									if (`size $joints` != 0)
									{
										$skinningCommand[$skinNum] = ("select " + $transformString + "; ");
										for ($jnt in $joints)
										{
											$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "if (`objExists " + $jnt + "`){select -add " + $jnt + ";} ");
										}
										
										$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "skinCluster -n " + $clstr + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";");
										$clstrString = ($clstrString + " " + $clstr);
									}
									else
									{
										$skinningCommand[$skinNum] = ("warning (\"The skin cluster " + $clstr + " has no influences. " + $transformString + " will not be skinned.\");");
									}
									$skinNum++;
								}

								$skinNum++;
							}
						}
						//print $skinningCommand;
						//select "break";
					}
					////////////////////////////////////////////////////////////////////////////
					//SAVE REST POSE////////////////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////////////////
					string $restPoseCommand[];
					$rpI = 0;
					$restPoseGrps = `ls ($modRigName + "*_RestPoseGrp")`;
					for ($grp in $restPoseGrps)
					{
						if (`objExists ($grp + ".TX")`)
						{
							$attr = `getAttr ($grp + ".TX")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".TX\"`){setAttr \"" + $grp + ".TX\" " + $attr + "; setAttr \"" + $grp + ".tx\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".TY")`)
						{
							$attr = `getAttr ($grp + ".TY")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".TY\"`){setAttr \"" + $grp + ".TY\" " + $attr + "; setAttr \"" + $grp + ".ty\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".TZ")`)
						{
							$attr = `getAttr ($grp + ".TZ")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".TZ\"`){setAttr \"" + $grp + ".TZ\" " + $attr + "; setAttr \"" + $grp + ".tz\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".RX")`)
						{
							$attr = `getAttr ($grp + ".RX")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".RX\"`){setAttr \"" + $grp + ".RX\" " + $attr + "; setAttr \"" + $grp + ".rx\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".RY")`)
						{
							$attr = `getAttr ($grp + ".RY")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".RY\"`){setAttr \"" + $grp + ".RY\" " + $attr + "; setAttr \"" + $grp + ".ry\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".RZ")`)
						{
							$attr = `getAttr ($grp + ".RZ")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".RZ\"`){setAttr \"" + $grp + ".RZ\" " + $attr + "; setAttr \"" + $grp + ".rz\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".SX")`)
						{
							$attr = `getAttr ($grp + ".SX")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".SX\"`){setAttr \"" + $grp + ".SX\" " + $attr + "; setAttr \"" + $grp + ".sx\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".SY")`)
						{
							$attr = `getAttr ($grp + ".SY")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".SY\"`){setAttr \"" + $grp + ".SY\" " + $attr + "; setAttr \"" + $grp + ".sy\" " + $attr + ";}");
							$rpI++;
						}
						if (`objExists ($grp + ".SZ")`)
						{
							$attr = `getAttr ($grp + ".SZ")`;
							$restPoseCommand[$rpI] = ($restPoseCommand[$rpI] + "if (`objExists \"" + $grp + ".SZ\"`){setAttr \"" + $grp + ".SZ\" " + $attr + "; setAttr \"" + $grp + ".sz\" " + $attr + ";}");
							$rpI++;
						}
					}
					//CHECK FOR SINGLE HIERARCHY
					$singleHierarchy = 0;
					if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
					{
						$connections = `listConnections -s 1 -d 0 ($modRigName + "ROOTJnt.singleHierarchy")`;
						if (`size $connections` > 0)
						{
							$jointParent = `listRelatives -p $connections[0]`;
							if (`nodeType $jointParent[0]` == "joint")
							{
								$singleHierarchy = 2;
							}
							else
							{
								$singleHierarchy = 1;
							}
						}
					}


					//SAVE POSE
					string $pose[] = RRM_SavePose($modRigName);

					////////////////////////////////////////////////////////////////////////////
					//SAVE CONTROL SHAPES////////////////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////////////////
					string $rebuildShapes[];
					string $ctrlShapes[];
					string $shapes[];
					string $shapeLong;
					string $shapesLong[];
					string $ctrls[];			
					int $iRS = 0;
					string $curve[];
					if ($saveControlShapes == 1)
					{
						$origShapes = `listRelatives -ad -type "nurbsCurve" $rigGrp`;
						$origShapesLong = `listRelatives -ad -f -type "nurbsCurve" $rigGrp`;
						$ctrls = `listRelatives -p -type "transform" $origShapesLong`;
						$ctrlsSmall = stringArrayRemoveDuplicates($ctrls);
						global string $gMainProgressBar;
						progressBar -edit
						-beginProgress
						-isInterruptable true
						-status ("Saving Control Shapes...")
						-maxValue (`size $ctrls`)
						$gMainProgressBar;

						for ($ctrl in $ctrlsSmall)
						{
							if (`objExists ($ctrl + ".modControlName")`)
							{
								$rebuildShapes[$iRS] = ("if (`objExists (\"" + $ctrl + "\")`){");

								$shapesLong = `listRelatives -c -f -type "nurbsCurve" $ctrl`;
								for ($shapeLong in $shapesLong)
								{
									$shape = `ls $shapeLong`;
									$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "string $shapeName = \"" + $shapeLong + "\";");

									//GET ATTRIBUTES OF CURVE
									$spans = `getAttr ($shapeLong + ".spans")`;
									$form = `getAttr ($shapeLong + ".form")`;
									$degree = `getAttr ($shapeLong + ".degree")`;
									$overrideColor = `getAttr ($shapeLong + ".overrideColor")`;

									if (!`objExists ($shapeLong + ".curveCheck")`)
									{
										$rebuildShapes[$iRS] = $rebuildShapes[$iRS] + ("if (!`objExists (\"" + $shapeLong + "\")`){");
										if ($form == 2)
										{//CIRCLE
											$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "$curve = `circle -n " + $shape[0] + "_temp -sw 360 -s " + $spans + "-ch 0`;");
										}
										else if ($degree == 1 || $degree == 2 || $degree == 3)
										{//1, 2 & 3 CUBIC
											$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "$curve = `curve -n " + $shape[0] + "_temp -d " + $degree + " ");
											$cvNum = 0;
											//CV's
											for ($cv in `ls -fl ($shapeLong + ".cv[*]")`)
											{
												$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + " -p 0 0 " + $cvNum);
												$cvNum++;
											}
											//KNOTS
											$k = 0;
											while ($k < $degree)
											{
												$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + " -k 0 ");
												$k++;
											}

											$knotNum = 1;
											while (($knotNum + $degree) < $cvNum)
											{
												$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + " -k " + $knotNum);
												$knotNum++;
											}
											$knotNum++;
											$k = 0;
											while ($k < $degree)
											{
												$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + " -k " + $knotNum);
												$k++;
											}
											$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "`;");
										}

										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "$ctrlShape = `listRelatives -c -type \"nurbsCurve\" $curve`;");
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "$shapeName = `rename $ctrlShape[0] " + $shape[0] + "`;");
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "parent -r -s $shapeName " + $ctrl + ";");
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "delete $curve;");
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "$shapeName = `rename $shapeName " + $shape[0] + "`;");
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "}");
									}
									//END OF BUILDING NEW CURVE


									//SET COLOR
									if (`getAttr ($shapeLong + ".overrideEnabled")` == 1)
									{
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "setAttr ($shapeName + \".overrideEnabled\") 1;");
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "setAttr ($shapeName + \".overrideColor\") " + $overrideColor + ";");
									}
									//CURVE POINT LOCATIONS
									$cvNum = 0;
									for ($cv in `ls -fl ($shapeLong + ".cv[*]")`)
									{
										$pos = `xform -q -os -t ($shapeLong + ".cv[" + $cvNum + "]")`;
										$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "xform -a -os -t " + $pos[0] + " " + $pos[1] + " " + $pos[2] + " ($shapeName + \".cv[" + $cvNum + "]\");");
										$cvNum++;
									}


								}
								$rebuildShapes[$iRS] = $rebuildShapes[$iRS] + ("$shapes = `listRelatives -c -f -type \"nurbsCurve\" \"" + $ctrl + "\"`;string $shape; for ($shape in $shapes){if (");
								$shapesLong2 = `listRelatives -c -f -type "nurbsCurve" $ctrl`;
								for ($ctrlShape in $shapesLong2)
								{
									$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "!`gmatch $shape \"" + $ctrlShape + "\"` && ");
								}
								$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "!`gmatch $shape \"\"`){delete $shape;}}");
								$rebuildShapes[$iRS] = ($rebuildShapes[$iRS] + "}");

								$iRS++;

							}
							//print ($rebuildShapes[$iRS] + "\n");
							//select "break";
							progressBar -edit -step 1 $gMainProgressBar;
						}
						progressBar -edit -endProgress $gMainProgressBar;
					}
					//print $rebuildShapes;
					//select "break";

					
					//DELETE RIG
					RRM_DeleteRig($modRigName, $rigGrp, 0);
					
					//REBUILD RIG

					print "\nRebuilding Rig...\n";
					
					$lPrfx = "l_";
					$rPrfx = "r_";
					if (`objExists RRM_MAIN.lPrfx`)
					{
						$lPrfx = `getAttr RRM_MAIN.lPrfx`;
						$rPrfx = `getAttr RRM_MAIN.rPrfx`;
					}
					if (`objExists ($modRigName + "MAIN_Ctrl.leftPrefix")`)
					{
						$lPrfx = `getAttr ($modRigName + "MAIN_Ctrl.leftPrefix")`;
						$rPrfx = `getAttr ($modRigName + "MAIN_Ctrl.rightPrefix")`;
					}
					RRM_GenerateRig($modRigName, $rigGrp, 1, $singleHierarchy, `radioButtonGrp -q -sl RRM_SHJointRotationRadiButtonGrp`, $lPrfx, $rPrfx, $ea);
					{
						RRM_ColorControls($modRigName);
						if (`objExists RRM_ProxiesLayer`)
						{
							setAttr RRM_ProxiesLayer.visibility 0;
						}
					}

					//APPLY NEW NAMES////////////////////////////////////////////////////////////////////////////////////////////////
					for ($name in $origName)
					{
						//print ($name + "\n");
						eval $name;
					}			
					
					//CHECK FOR EXTRA HISTORY ON MESH
					if (`size $skinnedMesh` > 0)
					{
						$history = `listHistory $skinnedMesh`;
						if (`size $history` > 0)
						{
							$skinCheck = `confirmDialog -title "Mesh History"
							-message "Some of your skinned mesh has Construction History\nThe reskinning may take far longer.\nWould you like to delete history on your skinned mesh(es)?"
								-button "Yes" -button "No" -defaultButton "Yes"
								-cancelButton "No" -dismissString "No"`;
								
							if ($skinCheck == "Yes")
							{
								delete -ch $skinnedMesh;
							}
						}
						
						//SKIN AND REAPPLY WEIGHTS////////////////////////////////////////////////////////////////////////////////////////////////
						if ($saveSkinning == 1)
						{
							print "\nApplying Skin Weights.\n";
						
							global string $gMainProgressBar;
							progressBar -edit
								-beginProgress
								-isInterruptable true
								-status "Applying Weights..."
								-maxValue ($vertTotal)
								$gMainProgressBar;
			
							for ($cmd in $skinningCommand)
							{
								//print ($cmd + "\n");
								eval $cmd;
							}
							for ($skin in $skinPercentCommand)
							{           
								//print ($skin + "\n");
								eval $skin;
								progressBar -edit -step 1 $gMainProgressBar;
							}
							progressBar -edit -endProgress $gMainProgressBar;
						}
						

					}
					//APPLY REST POSE////////////////////////////////////////////////////////////////////////////////////////////////
					for ($rp in $restPoseCommand)
					{
						//print ($rp + "\n");;
						eval $rp;
					}
					//LOAD SHAPES////////////////////////////////////////////////////////////////////////////////////////////////
					if ($saveControlShapes == 1)
					{
						$shapeCount = `size $rebuildShapes`;
						global string $gMainProgressBar;
						progressBar -edit
							-beginProgress
							-isInterruptable true
							-status "Replacing Shapes..."
							-maxValue ($shapeCount)
							$gMainProgressBar;

						for ($rebuildShape in $rebuildShapes)
						{
							//print ($rebuildShape + "\n");
							eval $rebuildShape;
							progressBar -edit -step 1 $gMainProgressBar;
						}
						progressBar -edit -endProgress $gMainProgressBar;

						//APPLY POSE
						for ($pos in $pose)
						{
							//print ($pos + "\n");;
							eval $pos;
						}
					}
					print ("\nSuccess! \"" + $rigGrp + "\" has been rebuilt.\n");
				}
			}
			else
			{
				warning "The selected node needs to be a RRM control.";
			}
		}
		else
		{
			warning "There is no proxy rig in this scene to rebuild the rig from.";
		}
	}
	else
	{
		warning "Nothing Selected. Please select a control of the rig you wish to rebuild.";
	}
}
	
	
//////////////////////////CONTROLLER RESIZING////////////////////////////////////////
global proc RRM_ControlEnableDisableMirror()
{
 $checkVal = `radioButtonGrp -q -select RRM_ControlScaleSelection`;
 if ($checkVal == 3)
 {
  checkBox -edit -en 0 RRM_ControlMirror;
 }
 else
 {
  checkBox -edit -en 1 RRM_ControlMirror;
 }
}
global proc RRM_ControlEnableDisableUniformScales()
{
 $checkVal = `checkBox -q -value RRM_ControlUniformScale`;
 if ($checkVal == 0)
 {
  checkBoxGrp -edit -en1 1 -en2 1 -en3 1 RRM_ControlScaleAxes;
 }
 else if ($checkVal == 1)
 {
  checkBoxGrp -edit -en1 0 -en2 0 -en3 0 RRM_ControlScaleAxes;
 }
}

global proc RRM_SetWorldSpaceRotation(string $xDir, string $xPosNeg, string $yDir, string $yPosNeg)
{
	$selection = `ls -sl -type "transform"`;
	if (`size $selection` > 0)
	{
		$xOffset = 1;
		if ($xPosNeg == "-")
		{
			$xOffset = -1;
		}
		$yOffset = 1;
		if ($yPosNeg == "-")
		{
			$yOffset = -1;
		}
		
		for ($each in $selection)
		{
			$aimLctr = `spaceLocator`;
			$upLctr = `spaceLocator`;
			delete `pointConstraint $each $aimLctr`;
			delete `pointConstraint $each $upLctr`;
			if ($xDir == 1 && $yDir == 2)
			{
				move -r $xOffset 0 0 $aimLctr;
				move -r 0 $yOffset 0 $upLctr;
			}
			else if ($xDir == 1 && $yDir == 3)
			{
				move -r $xOffset 0 0 $aimLctr;
				move -r 0 0 $yOffset $upLctr;
			}
			else if ($xDir == 2 && $yDir == 1)
			{
				move -r 0 $xOffset 0 $aimLctr;
				move -r $yOffset 0 0 $upLctr;
			}
			else if ($xDir == 2 && $yDir == 3)
			{
				move -r $xOffset 0 0 $aimLctr;
				move -r 0 0 $yOffset $upLctr;
			}
			else if ($xDir == 3 && $yDir == 1)
			{
				move -r 0 0 $xOffset $aimLctr;
				move -r $yOffset 0 0 $upLctr;
			}
			else if ($xDir == 3 && $yDir == 2)
			{
				move -r $xOffset 0 0 $aimLctr;
				move -r 0 $yOffset 0 $upLctr;
			}
			if (!`getAttr -l ($each + ".rx")` && !`getAttr -l ($each + ".ry")` && !`getAttr -l ($each + ".rz")`)
			{//NO SKIPPING
				$aimConstraint = `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr (($each + ".rotate"), $rot[0], $rot[1], $rot[2]);
			}
			else if (`getAttr -l ($each + ".rx")` && !`getAttr -l ($each + ".ry")` && !`getAttr -l ($each + ".rz")`)
			{//SKIP X
				$aimConstraint = `aimConstraint -skip x -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr ($each + ".ry") $rot[1];
				setAttr ($each + ".rz") $rot[2];
			}
			else if (!`getAttr -l ($each + ".rx")` && `getAttr -l ($each + ".ry")` && !`getAttr -l ($each + ".rz")`)
			{//SKIP Y
				$aimConstraint = `aimConstraint -skip y -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr ($each + ".rx") $rot[0];
				setAttr ($each + ".rz") $rot[2];
			}			
			else if (!`getAttr -l ($each + ".rx")` && !`getAttr -l ($each + ".ry")` && `getAttr -l ($each + ".rz")`)
			{//SKIP Z
				$aimConstraint = `aimConstraint -skip z -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr ($each + ".rx") $rot[0];
				setAttr ($each + ".rz") $rot[2];
			}
			else if (`getAttr -l ($each + ".rx")` && `getAttr -l ($each + ".ry")` && !`getAttr -l ($each + ".rz")`)
			{//SKIP X AND Y
				$aimConstraint = `aimConstraint -skip x -skip y -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr ($each + ".rz") $rot[2];
			}
			else if (`getAttr -l ($each + ".rx")` && !`getAttr -l ($each + ".ry")` && `getAttr -l ($each + ".rz")`)
			{//SKIP X AND Z
				$aimConstraint = `aimConstraint -skip x -skip z -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr ($each + ".ry") $rot[1];
			}
			else if (!`getAttr -l ($each + ".rx")` && `getAttr -l ($each + ".ry")` && `getAttr -l ($each + ".rz")`)
			{//SKIP Y AND Z
				$aimConstraint = `aimConstraint -skip y -skip z -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject $upLctr $aimLctr $each`;
				$rot = `getAttr ($each + ".rotate")`;
				delete $aimConstraint;
				setAttr ($each + ".rx") $rot[0];
			}	
			delete $aimLctr $upLctr;
		}
		select $selection;
	}
	else
	{
		warning "No transforms selected.";
	}
}

global proc RRM_SetDefaultPose(string $all)
{
	string $selection[] = `ls -sl -type "transform"`;
	if (`size $selection` > 0)
	{

		if (`objExists ($selection[0] + ".modRigConnection")`)
		{
			$modRigName = `getAttr ($selection[0] + ".modRigConnection")`;
			$rigGrp = `listConnections -s 1 -d 0 ($selection[0] + ".modRigConnection")`;
			$transforms = `ls -sl`;
			if ($all == 1)
			{
				$shapes = `listRelatives -ad -type "nurbsCurve" -f $rigGrp[0]`;
				$transforms = `listRelatives -p $shapes`;
			}
			for ($each in $transforms)
			{
				if (`objExists ($each + ".modControlName")` && `objExists ($each + "_RestPoseGrp")`)
				{
					//print $each;
					//print `getAttr  -l ($each + ".tx")`;
					if (`getAttr -l ($each + ".tx")` == 0 && `getAttr -l ($each + ".ty")` == 0 && `getAttr -l ($each + ".tz")` == 0)
					{
						$pos = `xform -q -ws -t $each`;
						xform -ws -t $pos[0] $pos[1] $pos[2] ($each + "_RestPoseGrp");
						setAttr ($each + "_RestPoseGrp.TX") (`getAttr ($each + "_RestPoseGrp.tx")`);
						setAttr ($each + "_RestPoseGrp.TY") (`getAttr ($each + "_RestPoseGrp.ty")`);
						setAttr ($each + "_RestPoseGrp.TZ") (`getAttr ($each + "_RestPoseGrp.tz")`);
						setAttr (($each + ".translate"), 0, 0, 0);
					}					
					if (`getAttr -l ($each + ".rx")` == 0)
					{
						setAttr ($each + "_RestPoseGrp.rx") (`getAttr ($each + ".rx")` + `getAttr ($each + "_RestPoseGrp.rx")`);
						//setAttr ($each + "_RestPoseGrp.RX") (`getAttr ($each + ".rx")` + `getAttr ($each + "_RestPoseGrp.RX")`);
						setAttr ($each + "_RestPoseGrp.RX") (`getAttr ($each + "_RestPoseGrp.rx")`);
						setAttr ($each + ".rx") 0;
					}
					if (`getAttr -l ($each + ".ry")` == 0)
					{
						setAttr ($each + "_RestPoseGrp.ry") (`getAttr ($each + ".ry")` + `getAttr ($each + "_RestPoseGrp.ry")`);
						//setAttr ($each + "_RestPoseGrp.RY") (`getAttr ($each + ".ry")` + `getAttr ($each + "_RestPoseGrp.RY")`);
						setAttr ($each + "_RestPoseGrp.RY") (`getAttr ($each + "_RestPoseGrp.ry")`);
						setAttr ($each + ".ry") 0;
					}
					if (`getAttr -l ($each + ".rz")` == 0)
					{
						setAttr ($each + "_RestPoseGrp.rz") (`getAttr ($each + ".rz")` + `getAttr ($each + "_RestPoseGrp.rz")`);
						//setAttr ($each + "_RestPoseGrp.RZ") (`getAttr ($each + ".rz")` + `getAttr ($each + "_RestPoseGrp.RZ")`);
						setAttr ($each + "_RestPoseGrp.RZ") (`getAttr ($each + "_RestPoseGrp.rz")`);
						setAttr ($each + ".rz") 0;
					}
					if (`getAttr -l ($each + ".sx")` == 0)
					{
						setAttr ($each + "_RestPoseGrp.sx") (`getAttr ($each + ".sx")` + `getAttr ($each + "_RestPoseGrp.sx")` - 1);
						//setAttr ($each + "_RestPoseGrp.SX") (`getAttr ($each + ".sx")` + `getAttr ($each + "_RestPoseGrp.SX")` - 1);
						setAttr ($each + "_RestPoseGrp.SX") (`getAttr ($each + "_RestPoseGrp.sx")`);
						setAttr ($each + ".sx") 1;
					}
					if (`getAttr -l ($each + ".sy")` == 0)
					{
						setAttr ($each + "_RestPoseGrp.sy") (`getAttr ($each + ".sy")` + `getAttr ($each + "_RestPoseGrp.sy")` - 1);
						//setAttr ($each + "_RestPoseGrp.SY") (`getAttr ($each + ".sy")` + `getAttr ($each + "_RestPoseGrp.SY")` - 1);
						setAttr ($each + "_RestPoseGrp.SY") (`getAttr ($each + "_RestPoseGrp.sy")`);
						setAttr ($each + ".sy") 1;
					}
					if (`getAttr -l ($each + ".sz")` == 0)
					{
						setAttr ($each + "_RestPoseGrp.sz") (`getAttr ($each + ".sz")` + `getAttr ($each + "_RestPoseGrp.sz")` - 1);
						//setAttr ($each + "_RestPoseGrp.SZ") (`getAttr ($each + ".sz")` + `getAttr ($each + "_RestPoseGrp.SZ")` - 1);
						setAttr ($each + "_RestPoseGrp.SZ") (`getAttr ($each + "_RestPoseGrp.sz")`);
						setAttr ($each + ".sz") 1;
					}
				}
			}
			//SET PREFERRED ANGLE ON SH JOINTS
			if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
			{
				$shRoot = `listConnections -s 1 -d 0 ($modRigName + "ROOTJnt.singleHierarchy")`;
				$sHJnts = `listRelatives -ad -f -type "joint" $shRoot[0]`;
				$sHJnts = `ls -l $sHJnts $shRoot[0]`;

				for ($jnt in $sHJnts)
				{

					setAttr ($jnt + ".preferredAngleX") (`getAttr ($jnt + ".rotateX")`);
					setAttr ($jnt + ".preferredAngleY") (`getAttr ($jnt + ".rotateY")`);
					setAttr ($jnt + ".preferredAngleZ") (`getAttr ($jnt + ".rotateZ")`);
				}
			}
		}
	}
	else
	{
		warning "Nothing Selected. No action taken.";
	}
}

global proc RRM_GoToBindPose()
{
	$sel = `ls -sl`;
	if (`size $sel` > 0)
	{
		if (`objExists ($sel[0] + ".modRigConnection")`)
		{
			$modRigName = `getAttr ($sel[0] + ".modRigConnection")`;
			for ($grp in `ls ($modRigName + "*_RestPoseGrp")`)
			{
				if (`getAttr -l ($grp + ".tx")` == 0)
				{
					setAttr ($grp + ".tx") 0;
				}
				if (`getAttr -l ($grp + ".ty")` == 0)
				{
					setAttr ($grp + ".ty") 0;
				}
				if (`getAttr -l ($grp + ".tz")` == 0)
				{
					setAttr ($grp + ".tz") 0;
				}
				if (`getAttr -l ($grp + ".rx")` == 0)
				{
					setAttr ($grp + ".rx") 0;
				}
				
				if (`getAttr -l ($grp + ".ry")` == 0)
				{
					setAttr ($grp + ".ry") 0;
				}
				if (`getAttr -l ($grp + ".rz")` == 0)
				{
					setAttr ($grp + ".rz") 0;
				}
				if (`getAttr -l ($grp + ".sx")` == 0)
				{
					setAttr ($grp + ".sx") 1;
				}
				if (`getAttr -l ($grp + ".sy")` == 0)
				{
					setAttr ($grp + ".sy") 1;
				}
				if (`getAttr -l ($grp + ".sz")` == 0)
				{
					setAttr ($grp + ".sz") 1;
				}
			}
		}
		else
		{
			warning "You must select a control of the rig you wish to apply the bind pose to.";
		}
	}
	else
	{
		warning "Nothing Selected. You must select a control of the rig you wish to apply the bind pose to.";
	}
}

global proc RRM_GoToRestPose()
{
	$sel = `ls -sl`;
	if (`size $sel` > 0)
	{
		if (`objExists ($sel[0] + ".modRigConnection")`)
		{
			$modRigName = `getAttr ($sel[0] + ".modRigConnection")`;
			for ($grp in `ls ($modRigName + "*_RestPoseGrp")`)
			{
				if (`getAttr -l ($grp + ".tx")` == 0)
				{
					setAttr ($grp + ".tx") `getAttr ($grp + ".TX")`;
				}
				if (`getAttr -l ($grp + ".ty")` == 0)
				{
					setAttr ($grp + ".ty") `getAttr ($grp + ".TY")`;
				}
				if (`getAttr -l ($grp + ".tz")` == 0)
				{
					setAttr ($grp + ".tz") `getAttr ($grp + ".TZ")`;
				}
				if (`getAttr -l ($grp + ".rx")` == 0)
				{
					setAttr ($grp + ".rx") `getAttr ($grp + ".RX")`;
				}
				
				if (`getAttr -l ($grp + ".ry")` == 0)
				{
					setAttr ($grp + ".ry") `getAttr ($grp + ".RY")`;
				}
				if (`getAttr -l ($grp + ".rz")` == 0)
				{
					setAttr ($grp + ".rz") `getAttr ($grp + ".RZ")`;
				}
				if (`getAttr -l ($grp + ".sx")` == 0)
				{
					setAttr ($grp + ".sx") `getAttr ($grp + ".SX")`;
				}
				if (`getAttr -l ($grp + ".sy")` == 0)
				{
					setAttr ($grp + ".sy") `getAttr ($grp + ".SY")`;
				}
				if (`getAttr -l ($grp + ".sz")` == 0)
				{
					setAttr ($grp + ".sz") `getAttr ($grp + ".SZ")`;
				}
			}
		}
		else
		{
			warning "You must select a control of the rig you wish to apply the bind pose to.";
		}
	}
	else
	{
		warning "Nothing Selected. You must select a control of the rig you wish to apply the bind pose to.";
	}
}

global proc RRM_ControlScale(float $RRM_ControlScaleChange, int $selectionType, int $modScaleMirror, int $modUniformScaleAxes, int $RRM_ControlScaleAxis1, int $RRM_ControlScaleAxis2, int $RRM_ControlScaleAxis3)
{
	//GO THROUGH CURVES
	$selection = `ls -sl`;
	$controls = `ls -sl`;
	//string $controls[];
	string $tempControls[];
	string $modRigName;
	string $each;
	
	if (`size $selection` > 0)
	{
		for ($each in $selection)
		{
			if (`objExists ($selection[0] + ".modRigName")`)
			{
				$modRigName = `getAttr ($each + ".modRigName")`; 
				if ($selectionType == 1 && $modScaleMirror == 1)
				{
					if ($modScaleMirror == 1)
					{
						if (`objExists ($each + ".rightControl")`)
						{
							$oppControl = `getAttr ($each + ".rightControl")`;
							$oppControl = ($modRigName + $oppControl);
							$controls = `ls $controls $oppControl`;
						}
						else if (`objExists ($each + ".leftControl")`)
						{
							$oppControl = `getAttr ($each + ".leftControl")`;
							$oppControl = ($modRigName + $oppControl);
							$controls = `ls $controls $oppControl`;
						}
					}
				}
				else if ($selectionType == 2)
				{
					for ($each in $selection)
					{
						if (`objExists ($each + ".modRigName")`)
						{
							$modRigName = `getAttr ($each + ".modRigName")`; 
							//GET BRANCHES
							$coreName = `getAttr ($each + ".modCoreName")`;
							$crntBranch = ($modRigName + $coreName + "Grp");
							$controls = `ls $controls $crntBranch`;
							//GET MIRRORED BRANCHES
							if ($modScaleMirror == 1)
							{
								if (`objExists ($each + ".rightControl")`)
								{
									$oppControl = `getAttr ($each + ".rightControl")`;
									$oppCoreName = `getAttr ($modRigName + $oppControl + ".modCoreName")`;
									$oppBranch = ($modRigName + $oppCoreName + "Grp");
									$controls = `ls $controls $oppBranch`;
								}
								else if (`objExists ($each + ".leftControl")`)
								{
									$oppControl = `getAttr ($each + ".leftControl")`;
									$oppCoreName = `getAttr ($modRigName + $oppControl + ".modCoreName")`;
									$oppBranch = ($modRigName + $oppCoreName + "Grp");
									$controls = `ls $controls $oppBranch`;
								}
							}
						}
					}
				}
				else if ($selectionType == 3)
				{
					for ($each in $selection)
					{
						if (`objExists ($each + ".modRigName")`)
						{
							$modRigName = `getAttr ($each + ".modRigName")`; 
							//GET RIG NAMES
							$controls = `ls $controls $modRigName`;
						}
					}
				}
			}
			else
				{warning ($each + " is not a valid control. skipping.");}
		}
	}
	else
		{warning "Nothing selected. Please select a valid rrm control";}

				
	if ($selectionType == 2||$selectionType == 3)
	{
		select -hi $controls;
		$controlsHierarchy = `ls -sl -type "nurbsCurve"`;
		select $controlsHierarchy;
		pickWalk -d up;
		$controls = `ls -sl`;
		for ($each in $controls)
		{
			if (!`objExists ($each + ".nonControl")`)
			{
				$tempControls = `ls $tempControls $each`;
			}
		}
		$controls = `ls $tempControls`;
	}
				
	for ($each in $controls)
	{
		//CHECK NODE TYPE
		if (`objExists ($each + ".modRigName")`)
		{
			//SCALE
			float $controlScaleX = 1;
			float $controlScaleY = 1;
			float $controlScaleZ = 1;
			if ($modUniformScaleAxes == 1)
			{
				$controlScaleX = $RRM_ControlScaleChange;
				$controlScaleY = $RRM_ControlScaleChange;
				$controlScaleZ = $RRM_ControlScaleChange;
			}
			else
			{
				if ($RRM_ControlScaleAxis1 == 1)
				{
					$controlScaleX = $RRM_ControlScaleChange;
				}
				if ($RRM_ControlScaleAxis2 == 1)
				{
					$controlScaleY = $RRM_ControlScaleChange;
				}
				if ($RRM_ControlScaleAxis3 == 1)
				{
					$controlScaleZ = $RRM_ControlScaleChange;
				}
			}
			//GET SHAPES
			$worldSpace = `xform -q -ws -rp $each`;
			$curveShapes = `listRelatives -shapes $each`;
			string $eachShape;
			for ($eachShape in $curveShapes)
			{
				$cvs = `ls ($eachShape + ".cv[*]")`;
				if (!`objExists ($each + ".kneeLock")`)
				{
					scale -r -p $worldSpace[0] $worldSpace[1] $worldSpace[2] $controlScaleX $controlScaleY $controlScaleZ $cvs;
				}
				else
				{
					scale -r -p $worldSpace[0] 0 $worldSpace[2] $controlScaleX $controlScaleY $controlScaleZ $cvs;
				}						
			}
			//UPDATE SIZE ATTRIBUTE
			setAttr -l false ($each + ".controlSizeX");
			setAttr -l false ($each + ".controlSizeY");
			setAttr -l false ($each + ".controlSizeZ");
			float $valX = `getAttr ($each + ".controlSizeX")`;
			float $valY = `getAttr ($each + ".controlSizeY")`;
			float $valZ = `getAttr ($each + ".controlSizeZ")`;
			setAttr ($each + ".controlSizeX") ($valX * $controlScaleX);
			setAttr ($each + ".controlSizeY") ($valY * $controlScaleY);
			setAttr ($each + ".controlSizeZ") ($valZ * $controlScaleZ);
			setAttr -l true ($each + ".controlSizeX");
			setAttr -l true ($each + ".controlSizeY");
			setAttr -l true ($each + ".controlSizeZ");
		}
	}
	select $selection;
}


//////////////////////////SAVE CONTROL SHAPES////////////////////////////////////////
global proc RRM_WriteControlShapes()
{
	$initialSelection = `ls -sl`;
	$controls = `ls -sl -type "transform"`;
	if (`size $controls` > 0)
	{
		//GET ALL CONTROLS
		if (`objExists ($controls[0] + ".modRigName")`)
		{
			int $mayaVer = `about -version`;
			string $mayaFolder;
			string $fileName[];		
				
			if ($mayaVer > 2011)
			{
				$fileFilter = "RRM Control Sizes (.rrmctrl) (*.rrmctrl)";
				$fileName = `fileDialog2 -cap "Save Control Shapes & Colors" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
				if ($fileName[0] != "")
				{
					RRM_SaveControlShapes("empty", $fileName[0], "empty");
				}
			}
			else
			{
				fileBrowserDialog -mode 1
				-fileCommand ( "RRM_SaveControlShapes \"" + $mayaFolder + "\"" )
				-actionName "Save";
			}
		}
		else
		{
			string $returnVal_Generate = `confirmDialog
			-title "No RRM Control Selected"
			-message "You must first select a control from your modular rig that you wish to save the transforms from.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
		-title "Nothing Selected"
		-message "You must first select a control from your modular rig that you wish to load the transforms to.\n"
		-button "OK"
		-defaultButton "OK"
		-cancelButton "OK"
		-icon "critical"`;
	}
	select $initialSelection;
}

global proc RRM_SaveControlShapes(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;

	$selection = `ls -sl`;
	$modRigName = `getAttr ($selection[0] + ".modRigName")`;
	select -hi ($modRigName + "MAIN_Ctrl");
	
	$controls = `ls -sl -type "transform"`;
	for ($each in $controls)
	{
		if (`objExists ($each + ".controlSizeX")` && `objExists ($each + ".modRigName")`)
		{
			//GET NAME OF CONTROL WITHOUT RIG NAME
			$shapes = `listRelatives -shapes $each`;
			
			for ($eachShape in $shapes)
			{
				if (`objExists ($eachShape + ".cv[0]")`)
				{
					fprint $fileID ("if (`objExists " + $eachShape + "`) {");
					int $numSpans = `getAttr ($eachShape + ".spans")`;
					int $degree = `getAttr ($eachShape + ".degree")`;
					int $form  = `getAttr ($eachShape + ".form")`;
				
					int $numCVs = $numSpans + $degree;
				
					// Adjust for periodic curve:
					if ( $form == 2 ) $numCVs -= $degree;
					
					int $i = 0;
					while ($i <= $numCVs)
					{
						$pos = `xform -q -os -t ($eachShape + ".cv[" + $i + "]")`;
						fprint $fileID ("move -os " + $pos[0] + " " + $pos[1] + " " + $pos[2] + " " + ($eachShape + ".cv[" + $i + "]; "));
						$i++;
					}
					$overrideColor = `getAttr ($eachShape + ".overrideColor")`;
					fprint $fileID ("setAttr " + $eachShape + ".overrideColor " + $overrideColor + "; ");
					fprint $fileID ("} else {warning (\"" + $eachShape + " does not exist. Skipping\");}\n");
				}
			}
		}
	}
	fclose $fileID;
	
	print ("\nFILE SUCCESSFULLY SAVED TO: "+ $result + "\n");
}

global proc RRM_ReadControlShapes()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder2;
	string $fileName[];

	if ($mayaVer > 2011)
	{
		$fileFilter = "RRM Proxy Transforms (.rrmctrl) (*.rrmctrl)";
		$fileName = `fileDialog2 -fileMode 1 -cap "Load Control Shapes & Colours" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
		if ($fileName[0] != "")
		{
			RRM_LoadControlShapes("empty", $fileName[0], "empty");
		}
	}
	else
	{
		fileBrowserDialog -mode 0
		-fileCommand ( "RRM_LoadControlShapes \"" + $mayaFolder2 + "\"" )
		-actionName "Load";
	}
}

global proc RRM_LoadControlShapes(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING SHAPES FROM "+$result2+"\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		//print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}


//////////////////////////OVERRIDE COLOR////////////////////////////////////////

global proc RRM_ControlOverrideColor(int $colorVal)
{
	$selection = `ls -sl -type "transform"`;
	for ($each in $selection)
	{
		if (`objExists ($each + ".modRigName")`)
		{
			$shapes = `listRelatives -fullPath -shapes $each`;
			for ($eachShape in $shapes)
			{
				setAttr ($eachShape + ".overrideColor") $colorVal;
			}
		}
	}
	select $selection;
}

//DELETE RIG
global proc RRM_DeleteRig(string $modRigName, string $rigGrp, int $keep)
{
	if ($keep == 1)
	{
		if (`objExists ($rigGrp + ".singleHierarchy")`)
		{
			$source = `listConnections -p 1 ($rigGrp + ".singleHierarchy")`;
			if (`size $source` > 0)
			disconnectAttr $source[0] ($rigGrp + ".singleHierarchy");
			disconnectAttr $source[0] ($modRigName + "ROOTJnt.singleHierarchy");
		}
		if (`objExists ($modRigName + "SHJntGrp")`)
		{
			$children = `listRelatives -ad ($modRigName + "SHJntGrp")`;
			if (`size $children` == 0)
			{
				delete ($modRigName + "SHJntGrp");
			}
			else
			{
				string $parent[] = `listRelatives -p ($modRigName + "SHJntGrp")`;
				if ($parent[0] != "")
				{
					parent -w ($modRigName + "SHJntGrp");
				}
			}
		}

		string $each;
		$topJnt = `listConnections -s 1 -d 0 ($modRigName + "ROOTJnt.singleHierarchy")`;
		delete `listRelatives -ad -type "constraint" $topJnt`;
		delete -constraints $topJnt;
		//$joints = `listRelatives -ad $topJnt[0]`;
		//$joints = `listRelatives -ad -type "joint" ($modRigName + "SHJntGrp")`;

		//if (`size $joints` > 0)
		//{
		//	for ($each in `listRelatives -ad -type "joint" ($modRigName + "SHJntGrp")`)
		//	{
		//		delete -constraints $each;
		//	}
		//}
	}
	
	select -cl;
	select -hi $rigGrp;
	$dagNodes = `ls -sl`;
	select -d $dagNodes;
	$nonDagNodes = `ls -sl`;

	//GET SINGLE HIERARCHY JOINTS
	if (`objExists ($modRigName + "ROOTJnt.singleHierarchy")`)
	{
		$connections = `listConnections -s 1 -d 0 ($modRigName + "ROOTJnt.singleHierarchy")`;
		if (`size $connections` > 0)
		{
			string $joints[];
			$jointParent = `listRelatives -p $connections[0]`;
			if (`nodeType $jointParent[0]` == "joint")
			{
				$joints = `listRelatives $jointParent[0]`;
				$joints = `ls $jointParent[0] $joints`;
			}
			else
			{
				$joints = `listRelatives $connections[0]`;
				$joints = `ls $connections[0] $joints`;
			}
			delete $joints;
		}
	}

	//DELETE NODES
	//lockNode -l off $modRigName ($modRigName + "MAIN_Ctrl") ($modRigName + "ROOTSecondary_Ctrl");
	lockNode -l off $rigGrp `listRelatives -ad -type "transform" $rigGrp`;
	delete $rigGrp;
	for ($each in $nonDagNodes)
	{
		if (`objExists $each`)
		{
			delete $each;
		}
	}
	
	delete `ls -type "multiplyDivide" ($modRigName + "*")` `ls -type "blendColors" ($modRigName + "*")`
	`ls -type "condition" ($modRigName + "*")` `ls -type "plusMinusAverage" ($modRigName + "*")`
	`ls -type "clamp" ($modRigName + "*")`;
		
	//LAYERS
	if (`objExists ($modRigName + "SHJointsLayer")`)
	{
		delete ($modRigName + "SHJointsLayer");
	}
	if (`objExists ($modRigName + "GeoLayer")`)
	{
		delete ($modRigName + "GeoLayer");
	}
	if (`objExists ($modRigName + "ControlsLayer")`)
	{
		delete ($modRigName + "ControlsLayer");
	}
	if (`objExists ($modRigName + "JointsLayer")`)
	{
		delete ($modRigName + "JointsLayer");
	}
	
	//MATERIALS
	if (`objExists ($modRigName + "geoColor01")`)
	{
		delete ($modRigName + "geoColor01");
	}
	if (`objExists ($modRigName + "geoColor02")`)
	{
		delete ($modRigName + "geoColor02");
	}
	if (`objExists ($modRigName + "EyeWhites")`)
	{
		delete ($modRigName + "EyeWhites");
	}
	if (`objExists ($modRigName + "Pupils")`)
	{
		delete ($modRigName + "Pupils");
	}
}


global proc RRM_DeleteRigUI()
{
	$selection = `ls -sl`;
	
	if (`size $selection` == 1)
	{
		if (`objExists ($selection[0] + ".modRigName")`)
		{
			$isReferenced = `referenceQuery -isNodeReferenced $selection[0]`;
			if ($isReferenced == 0)
			{
				string $modRigName = `getAttr ($selection[0] + ".modRigName")`;
				string $modRigConnections[] = `listConnections ($selection[0] + ".modRigConnection")`;
				string $rigGrp = $modRigConnections[0];
				
				if (!`objExists ($rigGrp + ".singleHierarchy")`)
				{
					string $returnVal_DeleteRig = `confirmDialog
					-title ("Are you sure you want to delete \"" + ($rigGrp) + "\" rig?")
					-message ("This will delete the entire rig and anything you may have added to the \"" + ($rigGrp) + "\" hierarchy. You may not be able to undo.")
					-button "Proceed"
					-button "Cancel"
					-defaultButton "Cancel"
					-cancelButton "Cancel"`;
					
					if ($returnVal_DeleteRig == "Proceed") 
					{
						print ("DELETING \"" + ($rigGrp) + "\"...\n");
						RRM_DeleteRig($modRigName, $rigGrp, 0);
						print ("\"" + ($rigGrp) + "\" DELETED\n");
					}
				}
				else
				{
					string $returnVal_DeleteRig = `confirmDialog
					-title ("Are you sure you want to delete \"" + ($rigGrp) + "\" rig?")
					-message ("This will delete the entire rig and anything you may have added to the \"" + ($rigGrp) + "\" hierarchy. You may not be able to undo.")
					-button "Proceed"
					-button "Proceed, Keep SH Joints"
					-button "Cancel"
					-defaultButton "Cancel"
					-cancelButton "Cancel"`;
					
					if ($returnVal_DeleteRig == "Proceed") 
					{
						print ("DELETING \"" + ($rigGrp) + "\"...\n");
						RRM_DeleteRig($modRigName, $rigGrp, 0);
						print ("\"" + ($rigGrp) + "\" DELETED\n");
					}
					if ($returnVal_DeleteRig == "Proceed, Keep SH Joints") 
					{
						print ("DELETING \"" + ($rigGrp) + "\"...\n");
						RRM_DeleteRig($modRigName, $rigGrp, 1);
						print ("\"" + ($rigGrp) + "\" DELETED. SINGLE HIERARCHY JOINTS PRESERVED\n");
					}
				}
			}
			else
			{
				warning ("\"" + $selection[0] + "\" is referenced and cannot be deleted.");
			}
		}
		else
		{
			confirmDialog
			-title "Warning: Select \"MAIN_Ctrl\""
			-message "You need to select a control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
		}
	}
	else if (`size $selection` == 0)
	{
			confirmDialog
			-title "Warning: Nothing Selected"
			-message "You need to select a control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
	else
	{
			confirmDialog
			-title "Warning: More Than One Object Selected"
			-message "Please select only one control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
//CONNECT SCALES
global proc RRM_SH_ScaleConnect(int $x, int $y, int $z)
{
	$sel = `ls -sl -type "joint"`;
	if (`size $sel` > 0)
	{
		if (($x + $y + $z) > 0)
		{
			for ($j in $sel)
			{
				$constraints = `listConnections -s 1 -d 0 -type "constraint" ($j + ".tx")`;
				$constraints = `stringArrayRemoveDuplicates $constraints`;
				if (`size $constraints` > 0)
				{
					$targetJnt = `listConnections -s 1 -d 0 -type "joint" ($constraints[0] + ".target")`;
					$targetJnt = `stringArrayRemoveDuplicates $targetJnt`;

					//CONNECTIONS
					//if ($x == 1)
					//{
					//	connectAttr -f ($targetJnt[0] + ".sx") ($j + ".sx");
					//}
					//if ($y == 1)
					//{
					//	connectAttr -f ($targetJnt[0] + ".sy") ($j + ".sy");
					//}
					//if ($z == 1)
					//{
					//	connectAttr -f ($targetJnt[0] + ".sz") ($j + ".sz");
					//}
					if ($x == 1 && $y == 1 && $z == 1)
					{
						scaleConstraint $targetJnt[0] $j;
					}
					else if ($x == 0 && $y == 1 && $z == 1)
					{
						scaleConstraint -skip x $targetJnt[0] $j;
					}
					else if ($x == 1 && $y == 0 && $z == 1)
					{
						scaleConstraint -skip y $targetJnt[0] $j;
					}
					else if ($x == 1 && $y == 1 && $z == 0)
					{
						scaleConstraint -skip z $targetJnt[0] $j;
					}
					else if ($x == 0 && $y == 0 && $z == 1)
					{
						scaleConstraint -skip x -skip y $targetJnt[0] $j;
					}
					else if ($x == 0 && $y == 1 && $z == 0)
					{
						scaleConstraint -skip x -skip z $targetJnt[0] $j;
					}
					else if ($x == 1 && $y == 0 && $z == 0)
					{
						scaleConstraint -skip y -skip z $targetJnt[0] $j;
					}
					else if ($x == 0 && $y == 0 && $z == 0)
					{
						warning "No axes selected. No action taken.";
					}						
				}
				else
				{
					warning ("\"" + $j + "\" is not connected to a RRM joint.");
				}
			}
		}
		else
		{
			warning "All checkboxes are disabled. No action taken.";
		}
	}
	else
	{
		warning "No joints are selected.";
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_SH_RenameHead(int $ea)
{
	$sel = `ls -sl`;
	if (`size $sel[0]` > 0)
	{
		if (`nodeType $sel[0]` == "joint")
		{
			$head = `rename $sel[0] "Head"`;
			$childJnts = `listRelatives -c -type "joint" $head`;
			//rename $childJnts[0] "HeadEnd";
			if (`size $childJnts` >= 1)
			{
				if (`objExists ($childJnts[0] + ".head")`)
				{
					$jaw = `rename $childJnts[0] "Jaw"`;
					$jawEnd = `listRelatives -c -type "joint" $jaw`;
					rename $jawEnd[0] "JawEnd";
				}
				if (`objExists ($childJnts[1] + ".head")`)
				{				
					rename $childJnts[1] "HeadEnd";
				}
			}
		}
		else
		{
			warning "Selected object is not a joint";
		}
	}
	else
	{
		warning "Nothing Selected";
	}
}
 
global proc RRM_SH_RenameHips(int $ea)
{
	$sel = `ls -sl`;
	if (`size $sel[0]` > 0)
	{
		$sel = `ls -sl`;
		if (`nodeType $sel[0]` == "joint")
		{
			rename $sel[0] "Hips";
		}
		else
		{
			warning "Selected object is not a joint";
		}
	}
	else
	{
		warning "Nothing Selected";
	}
}

global proc RRM_SH_RenameSpline(string $type, int $ea)
{
	$sel = `ls -sl`;
	if (`size $sel[0]` > 0)
	{
		if (`nodeType $sel[0]` == "joint")
		{
			if (`objExists ($sel[0] + ".splineStart")`)
			{
				$name = `rename $sel[0] $type`;

				$i = 1;
				int $splineEnd = 0;
				while ($splineEnd != 1 || $i == 100)
				{
					$joint = `listRelatives -c -type "joint" $name`;
					$name = `rename $joint ($type + $i)`;
					if (`objExists ($name + ".splineEnd")`)
					{
						$splineEnd = 1;
					}
					$i++;
				}
			}
			else
			{
				warning "Selected object is not the first joint of a spline";
			}
		}
		else
		{
			warning "Selected object is not a joint";
		}
	}
	else
	{
		warning "Nothing Selected";
	}
}


global proc RRM_SH_RenameArm(string $side, int $ea)
{
	$sel = `ls -sl`;
	if (`size $sel[0]` > 0)
	{
		if (`nodeType $sel[0]` == "joint")
		{

			if (`objExists ($sel[0] + ".shoulder")`)
			{
				$shoulder = `rename $sel[0] ($side + "Shoulder")`;
				$shoulderChildren = `listRelatives -c -type "joint" $shoulder`;
				if ($ea == 1)
				{				
					for ($shoulderChild in $shoulderChildren)
					{
						if (`objExists ($shoulderChild + ".upperArm")`)
						{
							//ARM
							$arm = `rename $shoulderChild ($side + "Arm")`;
							$armChildren = `listRelatives -c -type "joint" $arm`;
							for ($armChild in $armChildren)
							{
								//FOREARM
								if (`objExists ($armChild + ".forearm")`)
								{
									$forearm = `rename $armChild ($side + "ForeArm")`;
									$foreArmChildren = `listRelatives -c -type "joint" $forearm`;
									for ($foreArmChild in $foreArmChildren)
									{
										//HAND
										if (`objExists ($foreArmChild + ".hand")`)
										{
											$forearm = `rename $foreArmChild ($side + "Hand")`;
										}
										else if (`objExists ($foreArmChild + ".elbowOut")`)
										{
											rename $foreArmChild ("RM_" + $side + "Elbow");
										}
										else
										{
											//TWIST JOINTS
											rename $foreArmChild ("RM_" + $side + "ForeArmTwist1");
										}
									}
								}
								else if (`objExists ($armChild + ".arm")`)
								{
									//Twist JOINTS
									$i = 1;
									if ($i < 4)
									{
										rename $armChild ("RM_" + $side + "ArmTwist" + $i);
										$i++;
									}
									else
									{
										rename $armChild ("RM_" + $side + "Elbow");
									}
								}
							}
						}
					}
				}
				else
				{
					for ($shoulderChild in $shoulderChildren)
					{
						if (`objExists ($shoulderChild + ".upperArm")`)
						{
							//ARM
							$arm = `rename $shoulderChild ($side + "Arm")`;
							$armChildren = `listRelatives -c -type "joint" $arm`;
							for ($armChild in $armChildren)
							{
								//FOREARM
								if (`objExists ($armChild + ".forearm")`)
								{
									$forearm = `rename $armChild ($side + "ForeArm")`;
									$foreArmChildren = `listRelatives -c -type "joint" $forearm`;
									for ($foreArmChild in $foreArmChildren)
									{
										//HAND
										if (`objExists ($foreArmChild + ".hand")`)
										{
											$forearm = `rename $foreArmChild ($side + "Hand")`;
										}
										else
										{
											//TWIST JOINTS
											rename $foreArmChild ($side + "ForeArmTwist1");
										}
									}
								}
								else if (`objExists ($armChild + ".arm")`)
								{
									//Twist JOINTS
									$i = 1;
									if ($i < 4)
									{
										rename $armChild ($side + "ArmTwist" + $i);
										$i++;
									}
								}
							}
						}
					}
				}
			}
			else
			{
				warning "Selected joint is not the first joint of a arm";
			}
		}
		else
		{
			warning "Selected object is not a joint";
		}
	}
	else
	{
		warning "Nothing Selected";
	}
}

global proc RRM_SH_RenameThumb(string $side, int $ea)
{
	$sel = `ls -sl`;
	if (`size $sel[0]` > 0)
	{
		$firstJnt = `rename $sel[0] ($side + "HandThumb1")`;
		$i = 2;
		$child = `listRelatives -c -type "joint" $firstJnt`;
		while (`size $child` > 0 && $i <= 4)
		{
			if ($i < 4)
			{
				$name = `rename $child ($side + "HandThumb" + $i)`;
				$child = `listRelatives -c -type "joint" $name`;
			}
			else
			{
				$name = `rename $child ($side + "HandThumbEnd")`;
			}	
			$i++;
		}
	}
	else
	{
		warning "You must select the first joint of the thumb.";
	}
}

global proc RRM_SH_RenameFingers(string $side, int $ea)
{
	$sel = `ls -sl -type "joint"`;
	
	if (`size $sel[0]` > 0)
	{
		$metaCarpals = `confirmDialog
			-title "Metacarpals (\"in\" finger joints)"
			-message "Do you want to name the first finger joint as \"in\" joint?\nThese are for metacarpals."
			-button "Yes"
			-button "No"
			-defaultButton "Yes"
			-icon "information"`;

		$i = 1;
		string $finger[];
		$finger[0] = "Index";
		$finger[1] = "Middle";
		$finger[2] = "Ring";
		$finger[3] = "Pinky";
		$fingerInt = 0;
		string $name;

		for ($f in $sel)
		{
			$i = 1;
			string $firstJnt;
			if ($metaCarpals == "Yes")
			{				
				$firstJnt = `rename $f ($side + "HandIn" + $finger[$fingerInt])`;
			}
			else
			{
				$firstJnt = `rename $f ($side + "Hand" + $finger[$fingerInt] + $i)`;
				$i = 2;
			}

			$child = `listRelatives -c -type "joint" $firstJnt`;
			while (`size $child` > 0 && $i <= 4)
			{
				if ($i < 4)
				{
					$name = `rename $child ($side + "Hand" + $finger[$fingerInt] + $i)`;
					$child = `listRelatives -c -type "joint" $name`;
				}
				else
				{
					$name = `rename $child ($side + "Hand" + $finger[$fingerInt] + "End")`;
				}	
				$i++;
			}
			$fingerInt++;
		}
	}
	else
	{
		warning "You must select the first joint of each finger. In order of: Index, Middle, Ring, Pinky.";
	}
	
}


global proc RRM_SH_RenameLeg(string $side, int $ea)
{
	$sel = `ls -sl`;
	if (`size $sel[0]` > 0)
	{
		if (`nodeType $sel[0]` == "joint")
		{
			if (`objExists ($sel[0] + ".upLeg")`)
			{
				$upLeg = `rename $sel[0] ($side + "UpLeg")`;
				$upLegChildren = `listRelatives -c -type "joint" $upLeg`;
				if ($ea == 1)
				{
					for ($upLegChild in $upLegChildren)
					{
						//LEG
						if (`objExists ($upLegChild + ".leg")`)
						{
							if (`objExists ($upLegChild + ".knee")`)
							{
								$leg = `rename $upLegChild ($side + "Leg")`;
								$legChildren = `listRelatives -c -type "joint" $leg`;
								for ($legChild in $legChildren)
								{
									//HAND
									if (`objExists ($legChild + ".foot")`)
									{
										$foot = `rename $legChild ($side + "Foot")`;
										$footChildren = `listRelatives -c -type "joint" $foot`;
										for ($footChild in $footChildren)
										{
											if (`objExists ($footChild + ".toeBase")`)
											{
												$toeBase = `rename $footChild ($side + "ToeBase")`;
												$toeBaseChildren = `listRelatives -c -type "joint" $toeBase`;
												for ($toeBaseChild in $toeBaseChildren)
												{
													rename $toeBaseChild ($side + "FootEnd");
												}
											}
										}
									}
									else if (`objExists ($legChild + ".kneeOut")`)
									{
										rename $legChild ("RM_" + $side + "Knee");
									}
									else
									{
										//TWIST JOINTS
										rename $legChild ("RM_" + $side + "LegTwist1");
									}
								}
							}
							else if (`objExists ($upLegChild + ".leg")`)
							{
								$i = 1;
								if ($i < 4)
								{
									rename $upLegChild ("RM_" + $side + "UpLegTwist" + $i);
									$i++;
								}
								else
								{
									rename $upLegChild ("RM_" + $side + "Knee");
								}
							}
						}
					}
				}
				else
				{
					for ($upLegChild in $upLegChildren)
					{
						//LEG
						if (`objExists ($upLegChild + ".leg")`)
						{
							if (`objExists ($upLegChild + ".knee")`)
							{
								$leg = `rename $upLegChild ($side + "Leg")`;
								$legChildren = `listRelatives -c -type "joint" $leg`;
								for ($legChild in $legChildren)
								{
									//HAND
									if (`objExists ($legChild + ".foot")`)
									{
										$foot = `rename $legChild ($side + "Foot")`;
										$footChildren = `listRelatives -c -type "joint" $foot`;
										for ($footChild in $footChildren)
										{
											if (`objExists ($footChild + ".toeBase")`)
											{
												$toeBase = `rename $footChild ($side + "ToeBase")`;
												$toeBaseChildren = `listRelatives -c -type "joint" $toeBase`;
												for ($toeBaseChild in $toeBaseChildren)
												{
													rename $toeBaseChild ($side + "FootEnd");
												}
											}
										}
									}
									else
									{
										//TWIST JOINTS
										rename $legChild ($side + "LegTwist1");
									}
								}
							}
							else if (`objExists ($upLegChild + ".leg")`)
							{
								$i = 1;
								if ($i < 4)
								{
									rename $upLegChild ($side + "UpLegTwist" + $i);
									$i++;
								}
							}
						}
					}					
				}
			}
			else
			{
				warning "Selected joint is not the first joint of a leg";
			}
		}
		else
		{
			warning "Selected object is not a joint";
		}
	}
	else
	{
		warning "Nothing Selected";
	}
}


global proc RRM_GetVersionNumber()
{
	$selection = `ls -sl`;
	
	if (`size $selection` == 1)
	{
		if (`objExists ($selection[0] + ".versionNumber")`)
		{
			$modRigName = `getAttr ($selection[0] + ".modRigName")`;
			$rigVersionNumber = `getAttr ($selection[0] + ".versionNumber")`;
			
			string $returnVal_DeleteRig = `confirmDialog
			-title ("The rig \"" + ($modRigName) + "\" is version: " + $rigVersionNumber)
			-message ("Click the \"Go To Rapid Rig Web Page\" button to see if you have the latest version.")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"`;
		}
		else
		{
			confirmDialog
			-title "Warning: Select \"MAINC\""
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
		}
	}
	else if (`size $selection` == 0)
	{
			confirmDialog
			-title "Warning: Nothing Selected"
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
	else
	{
			confirmDialog
			-title "Warning: More Than One Object Selected"
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
}

global proc RRM_GoToCreativeCrash()
{
	launch -web "http://www.creativecrash.com/maya/script/-rapid-rig-modular-procedural-auto-rig-for-maya";
}
//////////////////////////////////////////////////////////////////
////////////////////////Main Window///////////////////////////////
//////////////////////////////////////////////////////////////////

global proc RRM_CreateProxyMainGUI(int $ea)
{
	string $form = `formLayout`;
	string $tabs = `tabLayout -cr false RRM_RigTab`;
	
	//TAB 1////////////////////////////////////////////////////////////////////////
	rowColumnLayout -nc 2 -cw 1 385 -cw 2 385 RRM_ProxySteps;
	//STEP 1.1: Name
		frameLayout -label "Step 1.1: Create Proxy Module Base"
			-width 375
			RRM_ProxyCreateProxyBaseFrameLayout;
			
		columnLayout RRM_ProxyCreateProxyBaseColumnLayout;
			
		rowColumnLayout -nc 2 -columnWidth 1 110 -columnWidth 2 180;
			checkBox -label "Use Template:"
			-v 0 -cc RRM_ToggleTemplate
			RRM_TemplateCheckBox;
			optionMenu -w 120
			-en 0
			RRM_TemplateType;
			menuItem -label "Bi-Ped (human)";
			menuItem -label "Quadruped";
			menuItem -label "Arachnid";
			menuItem -label "Bird";
			setParent RRM_ProxyCreateProxyBaseColumnLayout;

		rowColumnLayout -nc 3 -cw 1 320 -cw 2 10 -cw 3 26;
			button -label "Create New Proxy Rig" -bgc 0.7 0.7 0.7
			-command "RRM_PrefixPrompt(`checkBox -q -v RRM_TemplateCheckBox`)" RRM_CreateProxyMainProxyButton;
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(25)";

			setParent RRM_ProxyCreateProxyBaseColumnLayout;
		
	string $RRM_ProxyTabs = `tabLayout -cr false -h 588 RRM_ProxyTabs`;
	//STEP 1.2
	columnLayout RRM_AddModules;
		frameLayout -label "Step 1.2: Add Modules"
		RRM_AddModulesFrameLayout;
			scrollLayout
				-w 376
				-h 542
  		-horizontalScrollBarThickness 16
  		-verticalScrollBarThickness 16
  		addModScrollLayout;
  		
	columnLayout RRM_AddModulesColumnLayout;

		
	//RIBBON SPLINE
		frameLayout -label "Ribbon Spline Options (Spine, Neck)"
			-width 350
			-collapsable 1
			-bgc 0.114 0.356 0.451
			RRM_SplineOptionsFrameLayout;
			
			columnLayout RRM_SplineOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_SplineButton" -aie 1 RRM_TextFieldSplineName;
  
	setParent..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-max 100
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4
			RRM_SplineNum;

		radioButtonGrp -numberOfRadioButtons 2
			-labelArray2 "X-axis twist" "Y-Axis twist" -sl 2 RRM_SplineTwistAxis;
		
	 checkBox
			-label "Mirror Module"
			-value 0
			RRM_SplineMirror;
			
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;
		
		button -label "Create Spline" -bgc 0.114 0.356 0.451
		-command "RRM_SplinePrompts(\
		`textField -q -text RRM_TextFieldSplineName`,\
		`intSliderGrp -q -v RRM_SplineNum`,\
		`radioButtonGrp -q -select RRM_SplineTwistAxis`,\
		`checkBox -q -v RRM_SplineMirror`);"
		RRM_SplineButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(216)";
		
		setParent RRM_AddModulesColumnLayout;
	
	//ARM
		frameLayout -label "Arm Options"
			-width 350
			-collapsable 1
			-bgc 0 .275 .098
			RRM_ArmOptionsFrameLayout;
			
		columnLayout RRM_ArmOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_ArmButton" -aie 1 RRM_TextFieldArmName;
  
	setParent RRM_ArmOptionsColumnLayout;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_UpperArmNum;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_ForearmNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "One Elbow Joint" "Two Elbow Joints"
		-sl 1 -cc RRM_ElbowNumLock RRM_ElbowJoints;

		intSliderGrp
			-min 0
			-max 4
			-label "Mid Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_ElbowNum;
			
		checkBox
			-label "Toon Arms (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonArmCheckBox;
			
		radioButtonGrp -numberOfRadioButtons 3
		/*-label "Three Buttons"*/ -labelArray3 "Left" "Pair" "Right"
		-sl 2 RRM_ArmMirror;
 
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Arm" -bgc 0 .275 .098		
		-command "RRM_ArmPrompts(\
		`textField -q -text RRM_TextFieldArmName`,\
		`intSliderGrp -q -v RRM_UpperArmNum`,\
		`intSliderGrp -q -v RRM_ForearmNum`,\
		`intSliderGrp -q -v RRM_ElbowNum`,\
		`radioButtonGrp -q -select RRM_ElbowJoints`,\
		`checkBox -q -v RRM_ToonArmCheckBox`,\
		`radioButtonGrp -q -select RRM_ArmMirror`);"		
		RRM_ArmButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(638)";

		setParent RRM_AddModulesColumnLayout;
		
		
	//LEG
		frameLayout -label "Leg Options"
			-width 350
			-collapsable 1
			-bgc .631 .188 .412
			RRM_LegOptionsFrameLayout;
			
			columnLayout RRM_LegOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_LegButton" -aie 1 RRM_TextFieldLegName;
  
	setParent..;


		columnLayout -cw 200 -cat "left" 5;
		$RRM_UpperLegNum = `intSliderGrp
			-min 0
			-max 4
			-label "Upper Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_UpperLegNum`;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_LowerLegNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "One Knee Joint" "Two Knee Joints"
		-sl 1 -cc RRM_KneeNumLock RRM_KneeJoints;

		intSliderGrp
			-min 0
			-max 4
			-label "Mid Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_KneeNum;
			
		checkBox
			-label "Toon Legs (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonLegCheckBox;
			
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "Single" "Pair"
		-sl 2 RRM_LegMirror;
 
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Leg" -bgc .631 .188 .412
		-command "RRM_LegPrompts(\
		`textField -q -text RRM_TextFieldLegName`,\
		`intSliderGrp -q -v RRM_UpperLegNum`,\
		`intSliderGrp -q -v RRM_LowerLegNum`,\
		`intSliderGrp -q -v RRM_KneeNum`,\
		`radioButtonGrp -q -select RRM_KneeJoints`,\
		`checkBox -q -v RRM_ToonLegCheckBox`,\
		`radioButtonGrp -q -select RRM_LegMirror`);"
		RRM_LegButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(1369)";

		setParent RRM_AddModulesColumnLayout;

		
	//Fk CHAINS
		frameLayout -label "Fk Chain Options (Fingers, Toes, Tail, Tentacle, Antenna)"
			-width 350
			-collapsable 1
			-bgc .784 0 .784
			RRM_FkChainOptionsFrameLayout;
			
			columnLayout RRM_FkChainOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_FkChainButton" -aie 1 RRM_TextFieldFkChainName;
  
	setParent..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Chains"
			-field true
			-cal 1 center
			-cw 1 90
			-value 5 RRM_FkChain_Chains;
			
		intSliderGrp
			-min 1
			-label "Joints per Chain"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4 RRM_FkChain_JointsPerChain;
			
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "X Outward" "+Y" "+Z" -sl 1 RRM_FkChainDirection;
		radioButtonGrp -numberOfRadioButtons 3
		-shareCollection RRM_FkChainDirection
		-labelArray3 "X Inward" "-Y" "-Z" RRM_FkChainDirection2;
		
		checkBox
			-label "Enable Ik"
			-value 1
			RRM_FkEnableIk;
			
	 checkBox
			-label "Mirror Module"
			-value 1
			RRM_FkMirror;
 

		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Fk Chain" -bgc .784 0 .784
		-command "RRM_FkChainPrompts(\
		`textField -q -text RRM_TextFieldFkChainName`,\
		`intSliderGrp -q -v RRM_FkChain_Chains`,\
		`intSliderGrp -q -v RRM_FkChain_JointsPerChain`,\
		`checkBox -q -v RRM_FkEnableIk`,\
		`checkBox -q -v RRM_FkMirror`,\
		`radioButtonGrp -q -select RRM_FkChainDirection`,\
		`radioButtonGrp -q -select RRM_FkChainDirection2`);"
		RRM_FkChainButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(1797)";

		setParent RRM_AddModulesColumnLayout;

	
	//HEAD
		frameLayout -label "Head"
			-width 350
			-collapsable 1
			-bgc .608 0 .157
			RRM_HeadOptionsFrameLayout;
			
		columnLayout RRM_HeadOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_HeadButton" -aie 1 RRM_TextFieldHeadName;
  
	setParent..;
			
		columnLayout -cw 200 -cat "left" 5;
	 checkBox
			-label "Jaw"
			-value 1
			RRM_Jaw;
			
		columnLayout -cw 200 -cat "left" -1;
	 checkBox
			-label "Mirror Module"
			-value 0
			RRM_HeadMirror;
			
		setParent..;
 
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Head" -bgc .608 0 .157
		-command "RRM_HeadPrompts(\
		`textField -q -text RRM_TextFieldHeadName`,\
		`checkBox -q -v RRM_Jaw`,\
		`checkBox -q -v RRM_HeadMirror`);"
		RRM_HeadButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(2463)";

		setParent RRM_AddModulesColumnLayout;
		
	//LOOK-AT
		frameLayout -label "Look-At Joints (Eyes, etc)"
			-width 350
			-collapsable 1
			-bgc .435 .188 .631
			RRM_LookAtOptionsFrameLayout;
			
		columnLayout RRM_LookAtOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_LookAtButton" -aie 1 textFieldLookAtModName;
  
	setParent RRM_LookAtOptionsColumnLayout;
    

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 1 lookAtModJoints;
			
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "X Outward" "+Y" "+Z" -sl 3 RRM_LookAtDirection;
		radioButtonGrp -numberOfRadioButtons 3
		-shareCollection RRM_LookAtDirection
		-labelArray3 "X Inward" "-Y" "-Z" RRM_LookAtDirection2;
		
	 checkBox
			-label "Mirror Module"
			-value 1
			lookAtModMirror;
 
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Look-At" -bgc .435 .188 .631		
		-command "RRM_LookAtPrompts(\
		`textField -q -text textFieldLookAtModName`,\
		`intSliderGrp -q -v lookAtModJoints`,\
		`checkBox -q -v lookAtModMirror`,\
		`radioButtonGrp -q -select RRM_LookAtDirection`,\
		`radioButtonGrp -q -select RRM_LookAtDirection2`);"
		RRM_LookAtButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(2682)";

		setParent RRM_AddModulesColumnLayout;

	//AUXILIARY
		frameLayout -label "Auxiliary Joints (Single Joint)"
			-width 350
			-collapsable 1
			-bgc .639 .416 .169
			RRM_AuxiliaryOptionsFrameLayout;
			
		columnLayout RRM_AuxiliaryOptionsColumnLayout;
	
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 68 -columnWidth 2 276;


	text -label "Name";
	textField -enterCommand "setFocus RRM_AuxiliaryButton" -aie 1 textFieldAuxiliaryModName;
  
		setParent RRM_AuxiliaryOptionsColumnLayout;

		columnLayout -cw 200 -cat "left" 5;
	 checkBox
			-label "Mirror Module"
			-value 1
			AuxiliaryModMirror;
			
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Auxiliary" -bgc .639 .416 .169
		-command "RRM_AuxiliaryPrompts(\
		`textField -q -text textFieldAuxiliaryModName`,\
		`checkBox -q -v AuxiliaryModMirror`);"
		RRM_AuxiliaryButton;

		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(2853)";

		setParent RRM_AuxiliaryOptionsColumnLayout;

	setParent RRM_ProxyTabs;

	
	//STEP 1.3
	columnLayout RRM_EditModules;
		frameLayout -label "Step 1.3: Edit Modules" RRM_EditModuleFrameLayout;
			scrollLayout
				-w 376
				-h 542
  		-horizontalScrollBarThickness 16
  		-verticalScrollBarThickness 16
  		-bgc .45 .45 .45
  		RRM_EditScrollFrameLayout;
  		
  	columnLayout RRM_EditScrollColumnLayout;
		
	//EDIT SPLINE
		frameLayout -label "Edit Ribbon Splines"
			-width 350
			-collapsable 1
			-bgc 0.114 0.356 0.451
			RRM_EditSplineFrameLayout;
			
			columnLayout RRM_EditSplineColumnLayout;
	
	textFieldButtonGrp -label " Spline Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"spline\" )" RRM_EditLoadsplineTextField;


		setParent ..;
		
		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-max 99
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4
			RRM_SplineEditNum;
			
		radioButtonGrp -numberOfRadioButtons 2
			-labelArray2 "X-axis twist" "Y-Axis twist" -sl 2 RRM_SplineEditTwistAxis;
			
		setParent ..;
		columnLayout;
		button -label "Apply Edits to Loaded Spline" -w 340 -bgc 0.114 0.356 0.451 -command RRM_EditSpline;

		
		setParent RRM_EditScrollColumnLayout;
	
	//EDIT ARM
		frameLayout -label "Edit Arms"
			-width 350
			-collapsable 1
			-bgc 0 .275 .098
			RRM_EditArmsFrameLayout;
			
		columnLayout RRM_EditArmsColumnLayout;
	
	textFieldButtonGrp -label " Arm Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"arm\" )" RRM_EditLoadarmTextField;

		setParent ..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 upperArmModEditNum;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 forearmModEditNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		-labelArray2 "One Elbow Joint" "Two Elbow Joints"
		-sl 1 -cc RRM_ElbowEditNumLock RRM_ElbowEditJoints;

		intSliderGrp
			-min 0
			-max 4
			-label "Mid Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_ElbowEditNum;
		
	 checkBox
			-label "Toon Arms (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonArmEditCheckBox;
			
		setParent ..;
		button -label "Apply Edits to Loaded Arm" -w 340 -bgc 0 .275 .098 -command RRM_EditArm;
		
		setParent RRM_EditScrollColumnLayout;
		
	//EDIT LEGS
		frameLayout -label "Edit Legs"
			-width 350
			-collapsable 1
			-bgc .631 .188 .412
			RRM_EditLegsFrameLayout;
			
		columnLayout RRM_EditLegsColumnLayout;
	
	textFieldButtonGrp -label " Leg Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"leg\" )" RRM_EditLoadlegTextField;


		setParent ..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 upperLegModEditNum;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 lowerLegModEditNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		-labelArray2 "One Knee Joint" "Two Knee Joints"
		-sl 1 -cc RRM_KneeEditNumLock RRM_KneeEditJoints;
		
	 checkBox
			-label "Toon Legs (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonLegEditCheckBox;
			
			
		intSliderGrp
			-min 0
			-max 4
			-label "Mid Twist Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_KneeEditNum;
		
		setParent ..;
		columnLayout;
		button -label "Apply Edits to Loaded Leg" -w 340 -bgc .631 .188 .412 -command RRM_EditLeg;
		
		setParent RRM_EditScrollColumnLayout;
		
		
	//EDIT Fk CHAINS
		frameLayout -label "Edit Fk Chains"
			-width 350
			-collapsable 1
			-bgc .784 0 .784
			RRM_EditFkChainFrameLayout;
			
		columnLayout RRM_EditFkChainColumnLayout;
	

	textFieldButtonGrp -label " Fk Chain Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"fkChain\" )" RRM_EditLoadfkChainTextField;
  
	setParent..;


		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Chains"
			-field true
			-cal 1 center
			-cw 1 90
			-value 5 fkChainModEditChains;
			
		intSliderGrp
			-min 1
			-label "Joints per Chain"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4 fkChainModEditJointsPerChain;
			
		columnLayout -cw 200 -cat "left" 5;
		checkBox
			-label "Enable Ik"
			-value 1
			fkChainModEditIk;
			
		button -w 340 -label "Apply Edits to Loaded Fk Chain" -bgc .784 0 .784 -command RRM_EditFkChain;
		
		setParent RRM_EditScrollColumnLayout;

	
	//EDIT HEAD
		frameLayout -label "Edit Head"
			-width 350
			-collapsable 1
			-bgc 0.529 0.162 0.199
			RRM_EditHeadFrameLayout;
	
	columnLayout;
	textFieldButtonGrp -label " Head Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"head\" )" RRM_EditLoadheadTextField;

		button -label "Toggle Jaw" -w 340 -bgc 0.529 0.162 0.199 -command RRM_EditHead;
		
		setParent RRM_EditScrollColumnLayout;
	
		
	//EDIT LOOK-AT
		frameLayout -label "Edit Look-Ats"
			-width 350
			-collapsable 1
			-bgc .435 .188 .631
			RRM_EditLookAtFrameLayout;
	
	columnLayout;
	textFieldButtonGrp -label " Look-At Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"lookAt\" )" RRM_EditLoadlookAtTextField;

  
		intSliderGrp
			-min 1
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 1 lookAtModEditJoints;
			
		button -label "Apply Edits to Loaded Look-At" -w 340 -bgc .435 .188 .631 -command RRM_EditLookAt;

		
		setParent RRM_EditScrollColumnLayout;
		setParent..;

		
  
		tabLayout -edit -h 588 -tabLabel RRM_AddModules "Create Modules" -tabLabel RRM_EditModules "Edit Modules" $RRM_ProxyTabs;
  
		setParent RRM_ProxySteps;

 
	 //STEP 2.1 CHANGE PROXY COLORS
	 columnLayout RRM_ModifyProxies;
		frameLayout -label "Step 2.1 Override Selected Proxy Branch Color" -bgc .25 .25 .25 RRM_ControlColorOverrides;
		rowColumnLayout -nc 16 -bgc .25 .25 .25 -w 384;
		button -bgc .471 .471 .471		-label "0" -w 24 -ann "0" -c "RRM_ProxyOverrideColor(00)";
		button -bgc 0 0 0				-label "1" -w 24 -ann "1" -c "RRM_ProxyOverrideColor(01)";
		button -bgc .251 .251 .251		-label "2" -w 24 -ann "2" -c "RRM_ProxyOverrideColor(02)";
		button -bgc .502 .502 .502		-label "3" -w 24 -ann "3" -c "RRM_ProxyOverrideColor(03)";
		button -bgc .608 0 .157			-label "4" -w 24 -ann "4" -c "RRM_ProxyOverrideColor(04)";
		button -bgc 0 .016 .376			-label "5" -w 23 -ann "5" -c "RRM_ProxyOverrideColor(05)";
		button -bgc 0 0 1				-label "6" -w 23 -ann "6" -c "RRM_ProxyOverrideColor(06)";
		button -bgc 0 .275 .098			-label "7" -w 23 -ann "7" -c "RRM_ProxyOverrideColor(07)";
		button -bgc .149 0 .263			-label "8" -w 23 -ann "8" -c "RRM_ProxyOverrideColor(08)";
		button -bgc .784 0 .784			-label "9" -w 23 -ann "9" -c "RRM_ProxyOverrideColor(09)";
		button -bgc .541 .282 .2		-label "10" -w 24 -ann "10" -c "RRM_ProxyOverrideColor(10)";
		button -bgc .247 .137 .122		-label "11" -w 24 -ann "11" -c "RRM_ProxyOverrideColor(11)";
		button -bgc .6 .149 0			-label "12" -w 24 -ann "12" -c "RRM_ProxyOverrideColor(12)";
		button -bgc 1 0 0				-label "13" -w 24 -ann "13" -c "RRM_ProxyOverrideColor(13)";
		button -bgc 0 1 0				-label "14" -w 24 -ann "14" -c "RRM_ProxyOverrideColor(14)";
		
		button -bgc 0 .255 .6			-label "15" -w 24 -ann "15" -c "RRM_ProxyOverrideColor(15)";
		button -bgc 1 1 1				-label "16" -w 24 -ann "16" -c "RRM_ProxyOverrideColor(16)";
		button -bgc 1 1 0				-label "17" -w 24 -ann "17" -c "RRM_ProxyOverrideColor(17)";
		button -bgc .392 .863 1			-label "18" -w 24 -ann "18" -c "RRM_ProxyOverrideColor(18)";
		button -bgc .263 1 .639			-label "19" -w 24 -ann "23" -c "RRM_ProxyOverrideColor(23)";
		button -bgc 1 .69 .69			-label "20" -w 23 -ann "20" -c "RRM_ProxyOverrideColor(20)";
		button -bgc .967 .675 .475		-label "21" -w 23 -ann "21" -c "RRM_ProxyOverrideColor(21)";
		button -bgc 1 1 .388			-label "22" -w 23 -ann "22" -c "RRM_ProxyOverrideColor(22)";
		button -bgc 0 .6 .329			-label "23" -w 23 -ann "23" -c "RRM_ProxyOverrideColor(23)";
		button -bgc .631 .412 .188		-label "24" -w 23 -ann "24" -c "RRM_ProxyOverrideColor(24)";
		button -bgc .624 .631 .188		-label "25" -w 23 -ann "25" -c "RRM_ProxyOverrideColor(25)";
		button -bgc .408 .631 .188		-label "26" -w 23 -ann "26" -c "RRM_ProxyOverrideColor(26)";
		button -bgc .188 .631 .365		-label "27" -w 24 -ann "27" -c "RRM_ProxyOverrideColor(27)";
		button -bgc .188 .631 .631		-label "28" -w 24 -ann "28" -c "RRM_ProxyOverrideColor(28)";
		button -bgc .188 .404 .631		-label "29" -w 24 -ann "29" -c "RRM_ProxyOverrideColor(29)";
		button -bgc .435 .188 .631		-label "30" -w 24 -ann "30" -c "RRM_ProxyOverrideColor(30)";
		button -bgc .631 .188 .412		-label "31" -w 24 -ann "31" -c "RRM_ProxyOverrideColor(31)";

		setParent RRM_ModifyProxies;
	

	//STEP 2.2 RENAME MODULE
		frameLayout -label "Step 2.2: Rename Selected Module"
			-width 384
			-bgc .35 .35 .35
			RRM_RenameModFrameLayout;
	
	 columnLayout 
	 -bgc .35 .35 .35
	 RRM_RenameModColumnLayout;
 
	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 120 -columnWidth 2 258;
 
	 text -label "Module's New Name: ";
		textField -enterCommand "setFocus RRM_RenameButton" -aie 1 textFieldRenameName;
		
	 setParent RRM_RenameModColumnLayout;
	 
		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;
	 				
		button -label "Rename Selected Module" -command "RRM_ClonePrompts(\
		`textField -q -text textFieldRenameName`,\
		0, 0);"
		RRM_RenameButton;

		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(2968)";
		
		setParent RRM_ModifyProxies;
 
		
	//STEP 2.3 CLONE MODULE
		frameLayout -label "Step 2.3: Clone Selected Module"
			-width 384
			-bgc .25 .25 .25
			RRM_CloneModFrameLayout;
	
	 columnLayout
	 -bgc .25 .25 .25 RRM_CloneModColumnLayout;

	 rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	 	-columnWidth 1 132 -columnWidth 2 246;

	 text -label "Cloned Module's Name: ";
		textField -enterCommand "setFocus RRM_CloneButton" -aie 1 textFieldCloneName;
		
	 setParent RRM_CloneModColumnLayout;
	 
	 rowColumnLayout -numberOfColumns 4 -columnAttach 1 "right" 0
	 	-columnWidth 1 128 -columnWidth 2 212 -cw 3 10 -cw 4 26;
	 	
	 checkBox
			-label "Include branches"
			-value 1
			RRM_CloneBranchCheckBox;
			
		button -label "Clone Selected Module" -command "RRM_ClonePrompts(\
		`textField -q -text textFieldCloneName`,\
		`checkBox -q -v RRM_CloneBranchCheckBox`,1);"
		RRM_CloneButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3013)";
		
		setParent RRM_ModifyProxies;
  

		//STEP 2.4 RE-ATTACH
		frameLayout -label "Step 2.4: Attach Module to New Node"
			-width 384
			-bgc .35 .35 .35
			RRM_RetargetModFrameLayout;
		
		columnLayout -bgc .35 .35 .35;
  textFieldButtonGrp -label " New Attach Module:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 114 220 80 -bc RRM_LoadNewModuleAttachNode RRM_LoadNewModuleAttachNodeTextField;

		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;

  button -label "Attach Selected Modules to New Module"
  -command "RRM_AttachToNewModule (`textFieldButtonGrp -q -text RRM_LoadNewModuleAttachNodeTextField`)";
  
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3126)";
  
			setParent RRM_ModifyProxies;
			
		//STEP 2.5 DELETE MODULE
		frameLayout -label "Step 2.5: Delete Module"
			-width 384
			-bgc .25 .25 .25
			RRM_DeleteModFrameLayout;
	
		//DELETE
		columnLayout -bgc .25 .25 .25;
		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;

		button -label "Delete Selected Module and Branches" -bgc .5 0.0 0.0 -command RRM_DeleteBranchPrompts;

		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3169)";

		setParent RRM_ModifyProxies;
		
		//STEP 2.6 POSE
		frameLayout -label "Step 2.6: Pose Proxy Rig (Does not affect ROOT or Parent nodes)"
			-width 384
			-bgc .35 .35 .35
			RRM_PoseProxyFrameLayout;
	
		columnLayout -cw 200 -cat "left" 0 -bgc .35 .35 .35;
		radioButtonGrp -numberOfRadioButtons 4
		/*-label "Three Buttons"*/ -labelArray4 "Selected" "Module" "Branch" "All"
		-sl 1 RRM_PoseSelection;
		
		rowColumnLayout -nc 5 -cw 1 113 -cw 2 114 -cw 3 113 -cw 4 10 -cw 5 26;
			button -label "Right to Left"
			-command ("RRM_TransferProxies(\"right\", " + "`radioButtonGrp -q -select RRM_PoseSelection`)")
			RRM_RightToLeftProxiesButton;
			button -label "Reset"
			-command "RRM_ResetProxies(`radioButtonGrp -q -select RRM_PoseSelection`)"
			RRM_ResetProxies;		
			button -label "Left to Right"
			-command ("RRM_TransferProxies(\"left\", " + "`radioButtonGrp -q -select RRM_PoseSelection`)")
			RRM_LeftToRightProxiesButton;

			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3225)";

			setParent RRM_ModifyProxies;

			
	//STEP 2.7 PINNING
		frameLayout -label "Step 2.7: Pinning (pinned modules are not influenced by parent)"
			-width 384
			-bgc .25 .25 .25
			RRM_PinProxyFrameLayout;
				
			rowColumnLayout -nc 4 -cw 1 171 -cw 2 171 -cw 3 10 -cw 4 26 -bgc .25 .25 .25;
			button -label "Pin Module" -bgc 0.780 0.330 0.330
			-command "RRM_PinProxies(1, 0)";
			button -label "Unpin Module" -bgc 0.330 0.420 0.780
			-command "RRM_PinProxies(0, 1)";		
	
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3342)";

			setParent RRM_ModifyProxies;
	
	
	//STEP 2.8 TRANSFER
		frameLayout -label "Step 2.8: Transfer Transforms *Select Target Then Destination*"
			-width 384
			-bgc .35 .35 .35
			RRM_TransferProxyTransformsFrameLayout;
			
		columnLayout 
		-bgc .35 .35 .35 RRM_TransferProxyTransformsColumnLayout;
	
			$selectedOrBranch = `radioButtonGrp -numberOfRadioButtons 3
			-labelArray3 "Selected" "Module" "Branch"
			-sl 1
			-cc RRM_ToggleTransferParent
			RRM_TransferSelectionButton`;
			
			$transferParentCheck = `checkBox -v 0 -label "Include Parent" -ed 0 RRM_TransferParent`;
		
			setParent RRM_TransferProxyTransformsColumnLayout;
		//columnLayout ;//-cw 370 -cat "left" 5;
		
		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;

			button -label "Transfer"
			-bgc .35 .35 .35
			-command "RRM_TransferModTransforms"
			RRM_TransferModTransformsButton;

			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3409)";

		setParent RRM_ModifyProxies;

			
		//STEP 2.9 SAVE LOAD
		frameLayout -label "Step 2.9: Save/Load Proxy Transforms"
			-width 384
			-bgc .25 .25 .25
			RRM_SaveLoadProxyTransformsFrameLayout;
				
			rowColumnLayout -nc 4 -cw 1 171 -cw 2 171 -cw 3 10 -cw 4 26
			-bgc .25 .25 .25;
			button -label "Save Transforms"  
			-command "RRM_WritePathProxyTransforms";
			button -label "Load Transforms"
			-command "RRM_ReadPathProxyTransform";		
	
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3489)";

			setParent RRM_ModifyProxies;
			
			
		//STEP 2.10 SAVE LOAD
		frameLayout -label "Step 2.10: Save/Load Proxy Setup"
			-width 384
			-bgc .35 .35 .35
			RRM_SaveLoadProxySetupFrameLayout;
				
			rowColumnLayout -nc 4 -cw 1 171 -cw 2 171 -cw 3 10 -cw 4 26
			-bgc .35 .35 .35;
			button -label "Save Setup"  
			-command "RRM_WritePathProxySetup";
			button -label "Load Setup"
			-command "RRM_ReadPathProxySetup";		
	
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial(3590)";
			
		//STEP 2.11
		frameLayout -label "Step 2.11: Delete the Proxy Rig"
			-width 384
			-bgc .25 .25 .25
			RRM_DeleteProxyRigFrameLayout2;
			
		button -label "Delete Entire Proxy Rig" -w 354
		-bgc .5 0.0 0.0 
		-ann "This will delete your proxy rig once you have no further use for it."
		-command "RRM_DeleteProxyRig"
		RRM_DeleteProxyRigButton;
		
		setParent RRM_RigTab;
	
	
	//TAB 2////////////////////////////////////////////////////////////////////////
	rowColumnLayout -nc 2 -cw 1 385 -cw 2 385 RRM_RigSteps;
	//STEP 3.1
		columnLayout -w 350 RRM_GenerateRigLeftColumnLayout;
		frameLayout -label "Step 3.1: Generate Rig" -bgc .35 .35 .35
			-width 380 RRM_GenerateRigFrameLayout;
			
		columnLayout -bgc .35 .35 .35 RRM_GenerateRigColumnLayout;
		
		checkBox -label "Add Custom Prefix Name to your Rig" -v 0
		-onc ("text -e -en 1 RRM_CharNameLabelText; textField -e -en 1 RRM_CharNameTextField")
		-ofc ("text -e -en 0 RRM_CharNameLabelText; textField -e -en 0 RRM_CharNameTextField")

		RRM_NameRigCheckBox;

		rowColumnLayout -nc 2 -cw 1 65 -cw 2 310 RRM_RigNameRowColumnLayout;
		text -en 0 -label "Rig Name:" RRM_CharNameLabelText;
		$charModName = `textField
			-width 380 -en 0 RRM_CharNameTextField`;
			
			button -h 30 -w 376 -bgc .30 .65 .30 -label "Generate Modular Rig"
			-command ("RRM_GenerateRigPrompts(`checkBox -q -v RRM_NameRigCheckBox`, `textField -q -text RRM_CharNameTextField`, " + $ea + ")")
			RRM_GenerateRigPromptsButton;
	
			setParent RRM_GenerateRigLeftColumnLayout;
	
	//STEP 3.2
		frameLayout -label "Step 3.2: Skin Geometry to Rig" -bgc .25 .25 .25
			-width 380
			RRM_SelectSkinningJointsFrameLayout;
		
			columnLayout -bgc .25 .25 .25 RRM_SelectSkinningJointsColumnLayout;
	
			textFieldButtonGrp -buttonLabel "Load Rig"
			-cal 1 "left"
			-columnWidth2 290 70
			-ann "Select a control of the Rapid Rig you want to load"
			-buttonCommand "RRM_LoadRig"
			RRM_LoadRigTextFieldButtonGrp;
			
			columnLayout -cw 380 -cat "left" 5;
			
			setParent..;
			text -label "Hold down the shift-key when you press the button";
			text -label "to add the joints to an existing selection.";
			separator -h 10;
			button -w 380 -label "Select Skinning Joints"
			-command "RRM_SelectJoints(`textFieldButtonGrp -q -tx RRM_LoadRigTextFieldButtonGrp`)"
			RRM_SelectJointsButton;
	
		setParent RRM_GenerateRigLeftColumnLayout;
		
	//STEP 3.3
	frameLayout -label "Step 3.3: Character Set Creation" -bgc .35 .35 .35
		-width 380
		RRM_CreateCharacterSetFrameLayout;
		
		columnLayout -bgc .35 .35 .35 RRM_CreateCharacterSetColumnLayout;
		checkBox -label "Create Subcharacter Set for Each Module" RRM_SubCharacterCheckBox;
		
		button -w 380 -label "Create Character Set"
			-ann "Select MAINC of the Rig you want to create the character set for."
			-command "RRM_CreateCharacterSet(`checkBox -q -v RRM_SubCharacterCheckBox`)"
			RRM_CreateCharacterSetButton;
			
		//setParent RRM_GenerateRigColumnLayout;

		setParent RRM_RigSteps;

		
		columnLayout -w 350 RRM_GenerateRigRightColumnLayout;
	//STEP 3.4
	frameLayout -label "Step 3.4: Rebuild Rig" -bgc .25 .25 .25
		-width 380
		RRM_RebuildRigFrameLayout;
		
		columnLayout -bgc .25 .25 .25 -h 160 RRM_RebuildRigColumnLayout;
		text -ww 1 -w 375 -align "left" -label "-Use this to rebuild your rig after making adjustments to your proxies.";
		//text -ww 1 -w 320 -align "left" -label "Your weights will be preserved on any meshes that are skinned to the joints of your rig.";
		text -ww 1 -w 375 -align "left" -label "-'Rebuild Rig' only works if a proxy rig exists in your scene.";
		text -ww 1 -w 375 -align "left" -label "-Beware that any animation on the rig will be lost.";
		separator -h 10;
		checkBox -l "Override current Single Hierarchy joint orients (if applicable)" -v 0 
			-onc "radioButtonGrp -e -en 1 RRM_SHJointRotationRadiButtonGrp"
			-ofc "radioButtonGrp -e -en 0 RRM_SHJointRotationRadiButtonGrp"
			RRM_OverideJointOrientationCheckBox;
		radioButtonGrp -numberOfRadioButtons 2 -labelArray2 "Preserve Rotation" "Freeze Rotation" -sl 1 -en 0 RRM_SHJointRotationRadiButtonGrp;
		checkBox -l "Preserve current skinning and weights" -v 1 RRM_RebuildSaveSkinningCheckBox;
		checkBox -l "Reuse current control shapes" -v $ea RRM_RebuildRigControlsCheckBox;
		button -w 380 -h 20 -label "Rebuild Rig" -bgc 1.00 .50 .00
		-command ("RRM_RebuildRig(`checkBox -q -v RRM_RebuildSaveSkinningCheckBox`, `checkBox -q -v RRM_RebuildRigControlsCheckBox`, " + $ea + ")")
		RRM_RebuildRigButton;
		//button -label "test";
		
	setParent RRM_GenerateRigRightColumnLayout;
		
		//STEP 3.5
	frameLayout -label "Step 3.5: Delete Selected Rig" -bgc .35 .35 .35
		-width 380
		RRM_DeleteRigFrameLayout;
		
		columnLayout -bgc .35 .35 .35 RRM_DeleteRigColumnLayout;
		text -ww 1 -w 320 -align "left" -label "Select any control of the rig you wish to delete.";
		button -label "Delete Rig"
		-bgc .75 0.1 0.1
		-w 380
		//-h 32
		-annotation "Select any control of your rig and click this button to delete that rig."
		-command "RRM_DeleteRigUI"
		RRM_DeleteRigUIButton;


		//setParent RRM_RigSteps;
		setParent RRM_RigTab;

	//TAB 3////////////////////////////////////////////////////////////////////////	
	rowColumnLayout -nc 2 -cw 1 365 -cw 2 405 RRM_ControlSettings;
	//STEP 4.1
	columnLayout -w 365 RRM_LeftControlSettingsColumnLayout;
	frameLayout -label "Step 4.1: Adjust Rig's Rest Pose (Optional)"
	 	-bgc .25 .25 .25
		-width 365
		RRM_SetRestPoseFrameLayout;

		columnLayout -cw 365 -cat "left" 0 -bgc .25 .25 .25;
		text -align "left" -label "Pose your rig and press the Record button to define your rest pose.";
		text -align "left" -label "The rest pose is used to set the 'zero' values of controls.";
		separator -height 5;
		text -align "left" -label "Useful for T-Posing a character that was modeled in A-Pose";
		separator -height 10;

		rowColumnLayout -nc 2 -cw 1 250 -cw 2 50;
		radioButtonGrp -label "X direction" -numberOfRadioButtons 3 -labelArray3 "X" "Y" "Z"
		-sl 1
		-onCommand1("radioButtonGrp -e -en1 0 -en2 1 -en3 1 RRM_YdirectionRadioButtonGrp;\
		if (`radioButtonGrp -q -sl RRM_YdirectionRadioButtonGrp` == 1)\
		{radioButtonGrp -e -sl 2 RRM_YdirectionRadioButtonGrp;}")
		-onCommand2("radioButtonGrp -e -en1 1 -en2 0 -en3 1 RRM_YdirectionRadioButtonGrp;\
		if (`radioButtonGrp -q -sl RRM_YdirectionRadioButtonGrp` == 2)\
		{radioButtonGrp -e -sl 1 RRM_YdirectionRadioButtonGrp;}")
		-onCommand3("radioButtonGrp -e -en1 1 -en2 1 -en3 0 RRM_YdirectionRadioButtonGrp;\
		if (`radioButtonGrp -q -sl RRM_YdirectionRadioButtonGrp` == 3)\
		{radioButtonGrp -e -sl 2 RRM_YdirectionRadioButtonGrp;}")
		-cw 1 70 -cw 2 40 -cw 3 40 -cw 4 40
		RRM_XdirectionRadioButtonGrp;
		
		optionMenu RRM_XdirectionOptionMenu;
		menuItem -label "+";
		menuItem -label "-";
		radioButtonGrp -label "Y direction" -numberOfRadioButtons 3 -labelArray3 "X" "Y" "Z"
		-en1 0 -sl 2
		
		-cw 1 70 -cw 2 40 -cw 3 40 -cw 4 40
		RRM_YdirectionRadioButtonGrp;
		
		optionMenu RRM_YdirectionOptionMenu;
		menuItem -label "+";
		menuItem -label "-";
		setParent..;
		
		button -label "Apply World Space Rotation to Selected" -width 362 -bgc 0.6 0.6 1.0	
		-command ("RRM_SetWorldSpaceRotation(\
		`radioButtonGrp -q -select RRM_XdirectionRadioButtonGrp`,\
		`optionMenu -q -value RRM_XdirectionOptionMenu`,\
		`radioButtonGrp -q -select RRM_YdirectionRadioButtonGrp`,\
		`optionMenu -q -value RRM_YdirectionOptionMenu`)")
		RRM_SetWorldSpaceRotation;
		
		text -align "left" -label "";
		text -align "left" -label "Once you have posed the rig, press 'Record Rest Pose'.";
		rowColumnLayout -nc 2 -cw 1 140 -cw 2 212;
		checkBox -label "Apply to All Controls" -v 1 RRM_ApplyDefaultPoseToAll;
		button -label "Record Rest Pose" -width 200 -bgc 0.1 0.1 0.4
		-command ("RRM_SetDefaultPose(`checkBox -q -v RRM_ApplyDefaultPoseToAll`)") RRM_RecordDefaultPoseButton;

		setParent RRM_LeftControlSettingsColumnLayout;
 

	//STEP 4.2
		frameLayout -label "Step 4.2: Apply Set Poses to Rig"
			-bgc .35 .35 .35
			-width 365
			RRM_GoToPoseFrameLayout;
		
		rowColumnLayout -nc 2 -cw 1 181 -cw 2 181 RRM_GoToPoseRowColumnLayout;
		button -label "Set Rig To Bind Pose" -bgc 0.9 0.2 0.4 -command "RRM_GoToBindPose" RRM_GoToBindPoseButton;
		button -label "Set Rig To Rest Pose" -bgc 0.9 0.3 0.7 -command "RRM_GoToRestPose" RRM_GoToRestPoseButton;

		setParent RRM_ControlSettings;


	columnLayout -w 345 RRM_RightControlSettingsColumnLayout;

	//STEP 4.3
		frameLayout -label "Step 4.3: Resize Controllers"
		 	-bgc .25 .25 .25
			-width 415
			RRM_ResizeControllersFrameLayout;
			
		columnLayout -cw 415 -cat "left" 0 -bgc .25 .25 .25;

  rowColumnLayout -nc 2 -cw 1 340 -cw 2 75;
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "Selected" "Branch" "All"
		-sl 1
		-cc RRM_ControlEnableDisableMirror
		RRM_ControlScaleSelection;
		
		checkBox -label "Mirror"
		-v 1 -enable 1 RRM_ControlMirror;
		setParent..;		

		columnLayout -cal "left";
		checkBox -label "Uniform Scale"
		-v 1 -enable 1
		-cc RRM_ControlEnableDisableUniformScales
		RRM_ControlUniformScale;
		
		checkBoxGrp -numberOfCheckBoxes 3
		-label "Local Axes:"
		-labelArray3 "X" "Y" "Z"
		-valueArray3 1 1 1
		-en1 0 -en2 0 -en3 0
		RRM_ControlScaleAxes;
		
		
		floatSliderGrp -label "Scale Factor:" -field true
		-min 0.1 -max 2 -fieldMaxValue 10 -value 1
		-precision 3
		RRM_ControlScaleChange;
		setParent..;
		columnLayout;
		button -label "Scale Control(s)"
		-width 410
		-command "RRM_ControlScale(`floatSliderGrp -query -value RRM_ControlScaleChange`,\
		`radioButtonGrp -q -select RRM_ControlScaleSelection`,\
		`checkBox -q -v RRM_ControlMirror`,\
		`checkBox -q -v RRM_ControlUniformScale`,\
		`checkBoxGrp -q -value1 RRM_ControlScaleAxes`,\
		`checkBoxGrp -q -value2 RRM_ControlScaleAxes`,\
		`checkBoxGrp -q -value3 RRM_ControlScaleAxes`);"
		RRM_ControlScaleButton;
		
		setParent RRM_RightControlSettingsColumnLayout;
		
	//STEP 4.4: SAVE CONTROLS
		frameLayout -label "Step 4.4: Save & Load Control Shapes and Colors"
		-bgc .35 .35 .35
		-width 405 RRA_SaveLoadControlShapes;
		rowColumnLayout -nc 2 -bgc .35 .35 .35;
		button -label "Save Shapes and Colors" -w 202 -c "RRM_WriteControlShapes";
		button -label "Load Shapes and Colors" -w 202 -c "RRM_ReadControlShapes";
		
		setParent RRM_RightControlSettingsColumnLayout;
		
	//STEP 4.5
		frameLayout -label "Step 4.5: Override Control Color"
		-bgc .25 .25 .25
		RRM_ControlColorOverrides;
		rowColumnLayout -nc 16 -bgc .25 .25 .25;
		button -bgc .471 .471 .471		-label "0" -w 25 -ann "0" -c "RRM_ControlOverrideColor(00)";
		button -bgc 0 0 0				-label "1" -w 25 -ann "1" -c "RRM_ControlOverrideColor(01)";
		button -bgc .251 .251 .251		-label "2" -w 25 -ann "2" -c "RRM_ControlOverrideColor(02)";
		button -bgc .502 .502 .502		-label "3" -w 25 -ann "3" -c "RRM_ControlOverrideColor(03)";
		button -bgc .608 0 .157			-label "4" -w 25 -ann "4" -c "RRM_ControlOverrideColor(04)";
		button -bgc 0 .016 .376			-label "5" -w 25 -ann "5" -c "RRM_ControlOverrideColor(05)";
		button -bgc 0 0 1				-label "6" -w 25 -ann "6" -c "RRM_ControlOverrideColor(06)";
		button -bgc 0 .275 .098			-label "7" -w 25 -ann "7" -c "RRM_ControlOverrideColor(07)";
		button -bgc .149 0 .263			-label "8" -w 25 -ann "8" -c "RRM_ControlOverrideColor(08)";
		button -bgc .784 0 .784			-label "9" -w 25 -ann "9" -c "RRM_ControlOverrideColor(09)";
		button -bgc .541 .282 .2		-label "10" -w 25 -ann "10" -c "RRM_ControlOverrideColor(10)";
		button -bgc .247 .137 .122		-label "11" -w 25 -ann "11" -c "RRM_ControlOverrideColor(11)";
		button -bgc .6 .149 0			-label "12" -w 25 -ann "12" -c "RRM_ControlOverrideColor(12)";
		button -bgc 1 0 0				-label "13" -w 25 -ann "13" -c "RRM_ControlOverrideColor(13)";
		button -bgc 0 1 0				-label "14" -w 25 -ann "14" -c "RRM_ControlOverrideColor(14)";
		button -bgc 0 .255 .6			-label "15" -w 25 -ann "15" -c "RRM_ControlOverrideColor(15)";
		button -bgc 1 1 1				-label "16" -w 25 -ann "16" -c "RRM_ControlOverrideColor(16)";
		button -bgc 1 1 0				-label "17" -w 25 -ann "17" -c "RRM_ControlOverrideColor(17)";
		button -bgc .392 .863 1			-label "18" -w 25 -ann "18" -c "RRM_ControlOverrideColor(18)";
		button -bgc .263 1 .639			-label "19" -w 25 -ann "19" -c "RRM_ControlOverrideColor(19)";
		button -bgc 1 .69 .69			-label "20" -w 25 -ann "20" -c "RRM_ControlOverrideColor(20)";
		button -bgc .967 .675 .475		-label "21" -w 25 -ann "21" -c "RRM_ControlOverrideColor(21)";
		button -bgc 1 1 .388			-label "22" -w 25 -ann "22" -c "RRM_ControlOverrideColor(22)";
		button -bgc 0 .6 .329			-label "23" -w 25 -ann "23" -c "RRM_ControlOverrideColor(23)";
		button -bgc .631 .412 .188		-label "24" -w 25 -ann "24" -c "RRM_ControlOverrideColor(24)";
		button -bgc .624 .631 .188		-label "25" -w 25 -ann "25" -c "RRM_ControlOverrideColor(25)";
		button -bgc .408 .631 .188		-label "26" -w 25 -ann "26" -c "RRM_ControlOverrideColor(26)";
		button -bgc .188 .631 .365		-label "27" -w 25 -ann "27" -c "RRM_ControlOverrideColor(27)";
		button -bgc .188 .631 .631		-label "28" -w 25 -ann "28" -c "RRM_ControlOverrideColor(28)";
		button -bgc .188 .404 .631		-label "29" -w 25 -ann "29" -c "RRM_ControlOverrideColor(29)";
		button -bgc .435 .188 .631		-label "30" -w 25 -ann "30" -c "RRM_ControlOverrideColor(30)";
		button -bgc .631 .188 .412		-label "31" -w 25 -ann "31" -c "RRM_ControlOverrideColor(31)";

	setParent RRM_RigTab;

	//TAB 4////////////////////////////////////////////////////////////////////////	
	rowColumnLayout -nc 2 -cw 1 380 -cw 2 380 RRM_JointSettings;

		//STEP 6.1
			//setParent RRM_RigExtras;
			columnLayout RRM_ExtrasColumn2;
			
			frameLayout -label "Step 6.1 Connect Scale for Single Joint Hierarchy" RRM_SH_ScaleConnectFrameLayout;
			rowColumnLayout -nc 2 -cw 1 60 -cw 2 320 RRM_SH_ScaleConnectRowColumnLayout;
			text -label "axis:";
			checkBoxGrp -numberOfCheckBoxes 3 -labelArray3 "X" "Y" "Z" -valueArray3 1 1 1
			RRM_SH_ScaleConnectCheckBox;
			setParent RRM_SH_ScaleConnectFrameLayout;
			button -label "Connect Scale of Selected Single Hierarchy Joints"
			-c "RRM_SH_ScaleConnect(`checkBoxGrp -q -value1 RRM_SH_ScaleConnectCheckBox`,\
			`checkBoxGrp -q -value2 RRM_SH_ScaleConnectCheckBox`,\
			`checkBoxGrp -q -value3 RRM_SH_ScaleConnectCheckBox`);"
			RRM_SH_ScaleConnectButton;
			
			setParent RRM_ExtrasColumn2;
			
		//STEP 6.2
			frameLayout -label "Step 6.2: Rename Single Hierarchy to Match Motionbuilder Naming"
			-w 415 RRM_RenameSHJointsFrameLayout;
			
			rowColumnLayout -nc 3 -cw 1 150 -cw 2 80 -cw 3 150 RRM_RenameSHJointsHeadColumnLayout;
			separator -vis 0;
			button -label "Head" -bgc 0.0 0.75 0.0 -h 60 -ann "Select a joint to rename to Head" -c ("RRM_SH_RenameHead(" + $ea + ")");

			setParent RRM_RenameSHJointsFrameLayout;
			rowColumnLayout -nc 5 -cw 1 75 -cw 2 90 -cw 3 50 -cw 4 90 -cw 5 75 RRM_RenameSHJointsThumbsNeckColumnLayout;
			button -label "Right Thumb" -bgc 0.9 0.0 0.0 -ann "Select first joint of Right Thumb" -c ("RRM_SH_RenameThumb(\"Right\"," + $ea + ")");
			separator -vis 0;
			button -label "Neck" -bgc 0.0 0.75 0.0 -ann "Select the first joint of a chain to rename to Neck" -c ("RRM_SH_RenameSpline(\"Neck\"," + $ea + ")");
			separator -vis 0;
			button -label "Left Thumb" -bgc 0.1 0.2 0.9 -ann "Select first joint of Left Thumb" -c ("RRM_SH_RenameThumb(\"Left\"," + $ea + ")");
			//separator;
			setParent RRM_RenameSHJointsFrameLayout;
			rowColumnLayout -nc 7 -cw 1 90 -cw 2 2 -cw 3 92 -cw 4 12 -cw 5 92 -cw 6 2 -cw 7 90 RRM_RenameSHJointsArmsColumnLayout;
			button -label "Right Fingers" -bgc 0.9 0.1 0.1 -ann "Select first joint of each finger (from index to pinkie) for Right Hand" -c ("RRM_SH_RenameFingers(\"Right\"," + $ea + ")");
			separator;
			button -label "Right Arm" -bgc 0.9 0.1 0.1 -ann "Select clavicle joint of Right Arm" -c ("RRM_SH_RenameArm(\"Right\"," + $ea + ")");
			separator;
			button -label "Left Arm" -bgc 0.2 0.2 0.9 -ann "Select clavicle joint of Left Arm" -c ("RRM_SH_RenameArm(\"Left\"," + $ea + ")");
			separator;
			button -label "Left Fingers" -bgc 0.2 0.2 0.9 -ann "Select first joint of each finger (from index to pinkie) for Left Hand" -c ("RRM_SH_RenameFingers(\"Left\"," + $ea + ")");
			setParent RRM_RenameSHJointsFrameLayout;

			rowColumnLayout -nc 3 -cw 1 160 -cw 2 60 -cw 3 160 RRM_RenameSHJointsSpineColumnLayout;
			separator -vis 0;
			button -label "Spine" -bgc 0.0 0.75 0.0 -h 80 -ann "Select the first joint of a chain to rename to Spine" -c ("RRM_SH_RenameSpline(\"Spine\"," + $ea + ")");
			separator -vis 0;

			setParent RRM_RenameSHJointsFrameLayout;

			rowColumnLayout -nc 3 -cw 1 150 -cw 2 80 -cw 3 150 RRM_RenameSHJointsHipsColumnLayout;
			separator -vis 0;
			button -label "Hips" -bgc 0.0 0.75 0.0 -ann "Select a joint to rename to Hips" -c ("RRM_SH_RenameHips(" + $ea + ")");
			setParent RRM_RenameSHJointsFrameLayout;

			rowColumnLayout -nc 5 -cw 1 135 -cw 2 40 -cw 3 30 -cw 4 40 -cw 5 135 RRM_RenameSHJointsLegsColumnLayout;
			separator -vis 0;
			button -label "Right\nLeg" -bgc 0.9 0.1 0.1 -h 140 -ann "Select hip joint of a Leg" -c ("RRM_SH_RenameLeg(\"Right\"," + $ea + ")");
			separator -vis 0;
			button -label "Left\nLeg" -bgc 0.2 0.2 0.9 -h 140 -ann "Select hip joint of a Leg" -c ("RRM_SH_RenameLeg(\"Left\"," + $ea + ")");

	setParent RRM_RigTab;



	//TAB 5////////////////////////////////////////////////////////////////////////	
	rowColumnLayout -nc 2 -cw 1 355 -cw 2 415 RRM_RigExtras;
	
		//STEP 5.1
		frameLayout -label "Step 5.1: Delete the Proxy Rig"
			-width 355
			RRM_DeleteProxyRigFrameLayout2;
			
		columnLayout RRM_DeleteProxyRigColumnLayout;

			
			button -label "Delete Proxies" -w 354
			-bgc .8 0.25 0.25
			-ann "This will delete your proxy rig once you have no further use for it."
			-command "RRM_DeleteProxyRig"
			RRM_DeleteProxyRigButton2;
			
			
			setParent RRM_DeleteProxyRigColumnLayout;
			
			//STEP 5.2
		frameLayout -label "Step 5.2: Select Any Control to Delete the Entire Rig"
			-width 355
			RRM_DeleteModularRigFrameLayout;
			
		button -label "Delete Rig"
		-bgc .8 0.25 0.25
		-annotation "Select a control of your rig and click this button to delete that rig."
		-command "RRM_DeleteRigUI"
		RRM_DeleteRigUIButton2;
		
		setParent RRM_DeleteProxyRigColumnLayout;

		//STEP 5.3
		frameLayout -label "Rapid Rig Info"
			-width 355
			RRM_RapidRigInfoFrameLayout;
			
		columnLayout -cw 355;

		columnLayout -cw 50 -cat "left" 5;
		button -w 355 -label "RRM Version Number"
		-annotation "Select the Main Control and click this button to see what version your rig is."
		-command "RRM_GetVersionNumber"
		RRM_GetVersionNumberButton;
		
		button -w 355 -label "Go To \"Rapid Rig: Modular\" Web Page"
		-annotation "Go to the CreativecCrash webpage for Rapid Rig: Modular."
		-command "RRM_GoToCreativeCrash"
		RRM_GoToCreativeCrashButton;
		
		
		text -label "\n\n\n\n                email me with questions and feedback:\n\n                              dustin@rapidrig.com\n\n\n" -align "left";
	
	
			
		setParent ..;
			
	
	tabLayout -edit -tabLabel RRM_ProxySteps "Setup Proxies" -tabLabel RRM_RigSteps "Generate Rig" -tabLabel RRM_ControlSettings "Control Settings" -tabLabel RRM_JointSettings "Joint Settings" -tabLabel RRM_RigExtras "Extras" $tabs;

		int $top, $left, $value[2];
		$value = `scrollLayout -query -scrollAreaValue addModScrollLayout`;
		$top = $value[0];
		$left = $value[1];
}


//MAIN PROCEDURE FOR WINDOW
global proc RapidRig_Modular_V2()          
{
	if (`window -exists RRM_Window`) 
	{
		deleteUI RRM_Window; 
	}
	if (`window -exists RRM_PrefixPromptWindow`)
	{
		deleteUI RRM_PrefixPromptWindow;
	}
	window -title "Rapid Rig: Modular 2.0.1"
		-wh 778 686
		-rtf on
		-mnb true
		-mxb false
		-s 1
		RRM_Window;
	
	RRM_CreateProxyMainGUI(0);
	
	showWindow RRM_Window;
	window -e -w 778 -h 686 RRM_Window;
}

RapidRig_Modular_V2();